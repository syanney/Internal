{"version":3,"sources":["webpack:///main-bundle.js","webpack:///./node_modules/rxjs/util/EmptyError.js","webpack:///./components/root-module/home/home.component.ts","webpack:///./components/root-module/page-not-found/page-not-found.component.ts","webpack:///./node_modules/@angular/router/esm5/router.js","webpack:///./node_modules/rxjs/observable/of.js","webpack:///./node_modules/rxjs/operator/concatMap.js","webpack:///./node_modules/rxjs/operator/filter.js","webpack:///./components/main.ts","webpack:///./components/root-module/root.module.ts","webpack:///./components/root-module/root-routing.module.ts","webpack:///./node_modules/rxjs/BehaviorSubject.js","webpack:///./node_modules/rxjs/operators/concatMap.js","webpack:///./node_modules/rxjs/operator/mergeMap.js","webpack:///./node_modules/rxjs/observable/from.js","webpack:///./node_modules/rxjs/observable/FromObservable.js","webpack:///./node_modules/rxjs/observable/IteratorObservable.js","webpack:///./node_modules/rxjs/observable/ArrayLikeObservable.js","webpack:///./node_modules/rxjs/operators/observeOn.js","webpack:///./node_modules/rxjs/Notification.js","webpack:///./node_modules/rxjs/operator/catch.js","webpack:///./node_modules/rxjs/operators/catchError.js","webpack:///./node_modules/rxjs/operator/concatAll.js","webpack:///./node_modules/rxjs/operators/concatAll.js","webpack:///./node_modules/rxjs/operator/first.js","webpack:///./node_modules/rxjs/operators/first.js","webpack:///./node_modules/rxjs/operator/every.js","webpack:///./node_modules/rxjs/operators/every.js","webpack:///./node_modules/rxjs/operator/last.js","webpack:///./node_modules/rxjs/operators/last.js","webpack:///./node_modules/rxjs/operator/mergeAll.js","webpack:///./node_modules/rxjs/operator/reduce.js","webpack:///./node_modules/rxjs/operators/reduce.js","webpack:///./node_modules/rxjs/operators/scan.js","webpack:///./node_modules/rxjs/operators/takeLast.js","webpack:///./node_modules/rxjs/util/ArgumentOutOfRangeError.js","webpack:///./node_modules/rxjs/operators/defaultIfEmpty.js","webpack:///./node_modules/rxjs/operators/filter.js","webpack:///./components/root-module/home/home.component.html","webpack:///./components/root-module/page-not-found/page-not-found.component.html","webpack:///./components/root-module/root.component.ts","webpack:///./components/root-module/root.component.html"],"names":["webpackJsonp","Array","concat","module","exports","__webpack_require__","__extends","this","d","b","__","constructor","p","hasOwnProperty","prototype","Object","create","EmptyError","_super","err","call","name","stack","message","Error","__decorate","decorators","target","key","desc","c","arguments","length","r","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","value","core_1","HomeComponent","Component","selector","template","PageNotFoundComponent","__webpack_exports__","convertToParamMap","params","ParamsAsMap","navigationCancelingError","error","NAVIGATION_CANCELING_ERROR","isNavigationCancelingError","defaultUrlMatcher","segments","segmentGroup","route","parts","split","pathMatch","hasChildren","posParams","index","part","segment","startsWith","substring","path","consumed","slice","validateConfig","config","parentPath","validateNode","getFullPath","fullPath","isArray","component","outlet","PRIMARY_OUTLET","redirectTo","children","loadChildren","matcher","charAt","currentRoute","shallowEqualArrays","a","shallowEqual","k1","keys","k2","flatten","arr","apply","last$1","forEach","map$$1","callback","prop","waitForMap","obj","fn","__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_of__","waitHead","waitTail","res","k","mapped","__WEBPACK_IMPORTED_MODULE_7_rxjs_operator_map__","push","concat$","__WEBPACK_IMPORTED_MODULE_12_rxjs_operator_concatAll__","last$","__WEBPACK_IMPORTED_MODULE_17_rxjs_operator_last__","andObservables","observables","merged$","__WEBPACK_IMPORTED_MODULE_18_rxjs_operator_mergeAll__","__WEBPACK_IMPORTED_MODULE_16_rxjs_operator_every__","result","wrapIntoObservable","__WEBPACK_IMPORTED_MODULE_1__angular_core__","__WEBPACK_IMPORTED_MODULE_15_rxjs_observable_fromPromise__","Promise","resolve","createEmptyUrlTree","UrlTree","UrlSegmentGroup","containsTree","container","containee","exact","equalQueryParams","queryParams","equalSegmentGroups","root","containsQueryParams","containsSegmentGroup","equalPath","numberOfChildren","every","containsSegmentGroupHelper","containeePaths","current","next","equalSegments","as","bs","parameters","mapChildrenIntoArray","child","childOutlet","serializePaths","map","serializePath","join","serializeSegment","primary","children_1","v","encode","s","encodeURIComponent","replace","decode","decodeURIComponent","serializeParams","serializeQueryParams","strParams","matchSegments","str","match","SEGMENT_RE","matchQueryParams","QUERY_PARAM_RE","matchUrlQueryParamValue","QUERY_PARAM_VALUE_RE","noMatch","__WEBPACK_IMPORTED_MODULE_9_rxjs_Observable__","obs","NoMatch","absoluteRedirect","newTree","AbsoluteRedirect","namedOutletsRedirect","canLoadFails","applyRedirects","moduleInjector","configLoader","urlSerializer","urlTree","ApplyRedirects","runCanLoadGuard","canLoad","__WEBPACK_IMPORTED_MODULE_10_rxjs_observable_from__","injectionToken","guard","get","matched","consumedSegments","lastChild","positionalParamSegments","slicedSegments","containsEmptyPathRedirectsWithNamedOutlets","createChildrenForEmptySegments","mergeTrivialChildren","containsEmptyPathRedirects","addEmptySegmentsToChildrenIfNeeded","routes","_i","routes_1","isEmptyPathRedirect","getOutlet","__WEBPACK_IMPORTED_MODULE_2_tslib__","primarySegmentGroup","routes_2","some","undefined","findNode","node","_a","node_1","findPath","unshift","nodeChildrenAsMap","createEmptyState","rootComponent","snapshot","createEmptyStateSnapshot","emptyUrl","__WEBPACK_IMPORTED_MODULE_3_rxjs_BehaviorSubject__","UrlSegment","emptyParams","emptyData","emptyQueryParams","fragment","activated","ActivatedRoute","RouterState","TreeNode","ActivatedRouteSnapshot","RouterStateSnapshot","inheritedParamsDataResolve","pathToRoot","pathFromRoot","inhertingStartingFrom","parent_1","routeConfig","reduce","curr","data","_resolvedData","setRouterState","state","_routerState","serializeNode","advanceActivatedRoute","currentSnapshot","nextSnapshot","_futureSnapshot","url","equalParamsAndUrlSegments","equalUrlParams","parentsMismatch","parent","createRouterState","routeReuseStrategy","prevState","createNode","_root","shouldReuseRoute","createOrReuseChildren","retrieve","tree","setFutureSnapshotsOfActivatedRoutes","createActivatedRoute","createUrlTree","commands","nav","computeNavigation","toRoot","startingPosition","findStartingPosition","processChildren","updateSegmentGroupChildren","updateSegmentGroup","isMatrixParams","command","outlets","segmentPath","oldSegmentGroup","newSegmentGroup","qp","replaceSegment","oldSegment","newSegment","outletName","Navigation","numberOfDoubleDots","isAbsolute","cmd","cmdIdx","outlets_1","urlPart","partIndex","Position","_lastPathIndex","_urlSegment","modifier","createPositionApplyingDoubleDots","group","g","ci","dd","getPath","getOutlets","_b","startIndex","m","prefixedWith","slicedCommands","commandIndex","pathIndex","createNewSegmentGroup","outlets_2","currentCommandIndex","currentPathIndex","compare","paths","createNewSegmentChildren","stringify","closestLoadedConfig","_loadedConfig","recognize","rootComponentType","Recognizer","sortActivatedRouteSnapshots","nodes","sort","localeCompare","getChildConfig","match$1","NoMatch$1","checkOutletNameUniqueness","names","n","routeWithSameOutletName","toString","getSourceSegmentGroup","_sourceSegment","getPathIndexShift","_segmentIndexShift","split$1","containsEmptyPathMatchesWithNamedOutlets","s_1","createChildrenForEmptyPaths","containsEmptyPathMatches","s_2","addEmptyPathsToChildrenIfNeeded","emptyPathMatch","getOutlet$1","primarySegment","getData","getResolve","defaultErrorHandler","defaultRouterHook","advanceActivatedRouteNodeAndItsChildren","parentLoadedConfig","validateCommands","attrBoolValue","routerNgProbeToken","Router","provideLocationStrategy","platformLocationStrategy","baseHref","options","useHash","__WEBPACK_IMPORTED_MODULE_0__angular_common__","provideForRootGuard","router","provideRoutes","provide","multi","useValue","ROUTES","setupRouter","ref","contexts","location","injector","loader","compiler","opts","urlHandlingStrategy","errorHandler","enableTracing","dom_1","__WEBPACK_IMPORTED_MODULE_20__angular_platform_browser__","events","subscribe","e","logGroup","log","logGroupEnd","rootRoute","routerState","getAppInitializer","appInitializer","bind","getBootstrapListener","bootstrapListener","provideRouterInitializer","RouterInitializer","useFactory","deps","ROUTER_INITIALIZER","useExisting","RouterLink","RouterLinkWithHref","RouterLinkActive","RouterOutlet","ActivationEnd","ActivationStart","ChildActivationEnd","ChildActivationStart","GuardsCheckEnd","GuardsCheckStart","NavigationCancel","NavigationEnd","NavigationError","NavigationStart","ResolveEnd","ResolveStart","RouteConfigLoadEnd","RouteConfigLoadStart","RouterEvent","RoutesRecognized","RouteReuseStrategy","ROUTER_CONFIGURATION","RouterModule","ChildrenOutletContexts","OutletContext","NoPreloading","PreloadAllModules","PreloadingStrategy","RouterPreloader","UrlHandlingStrategy","DefaultUrlSerializer","UrlSerializer","VERSION","ROUTER_PROVIDERS","ROUTER_FORROOT_GUARD","Tree","__WEBPACK_IMPORTED_MODULE_4_rxjs_Subject__","__WEBPACK_IMPORTED_MODULE_6_rxjs_operator_concatMap__","__WEBPACK_IMPORTED_MODULE_8_rxjs_operator_mergeMap__","__WEBPACK_IMPORTED_MODULE_11_rxjs_operator_catch__","__WEBPACK_IMPORTED_MODULE_13_rxjs_operator_first__","__WEBPACK_IMPORTED_MODULE_14_rxjs_util_EmptyError__","__WEBPACK_IMPORTED_MODULE_19_rxjs_operator_reduce__","__WEBPACK_IMPORTED_MODULE_21_rxjs_operator_filter__","id","urlAfterRedirects","_this","reason","shouldActivate","has","getAll","enumerable","configurable","LoadedRouterConfig","_queryParamMap","DEFAULT_SERIALIZER","serialize","_parameterMap","parse","UrlParser","parseRootSegment","parseQueryParams","parseFragment","encodeURI","remaining","consumeOptional","peekStartsWith","parseChildren","parseQueryParam","decodeURI","parseSegment","capture","parseParens","parseMatrixParams","parseParam","valueMatch","decodedKey","decodedVal","currentVal","allowPrimary","indexOf","substr","allowRedirects","ngModule","expanded$","expandSegmentGroup","urlTrees$","rootSegmentGroup","noMatchError","mapped$","rootCandidate","expandChildren","expandSegment","routes$","processedRoutes$","expandSegmentAgainstRoute","concattedProcessedRoutes$","first$","_","noLeftoversInUrl","matchSegmentAgainstRoute","expandSegmentAgainstRouteUsingRedirect","expandWildCardWithParamsAgainstRouteUsingRedirect","expandRegularSegmentAgainstRouteUsingRedirect","applyRedirectCommands","lineralizeSegments","newSegments","rawSegmentGroup","load","cfg","rawSlicedSegments","childConfig$","routerConfig","childModule","childConfig","expanded$_1","cs","shouldLoad","applyRedirectCreatreUrlTree","newRoot","createSegmentGroup","createQueryParams","redirectToParams","actualParams","sourceName","updatedSegments","createSegments","redirectToSegments","actualSegments","findPosParam","findOrReturn","redirectToUrlSegment","pos","idx","actualSegments_1","splice","t","firstChild","siblings","filter","cc","futureSnapshot","_paramMap","urlSegment","lastPathIndex","_resolve","cmdWithOutlet","find","CanActivate","CanDeactivate","PreActivation","future","forwardEvent","canActivateChecks","canDeactivateChecks","initialize","parentContexts","futureRoot","currRoot","setupChildRouteGuards","checkGuards","isDeactivating","isActivating","canDeactivate$","runCanDeactivateChecks","canDeactivate","runCanActivateChecks","resolveData","checks$","runningChecks$","check","runResolve","futureNode","currNode","futurePath","prevChildren","setupRouteGuards","deactivateRouteAndItsChildren","getContext","context","shouldRunGuardsAndResolvers","runGuardsAndResolvers","mode","childName","isActivated","runCanDeactivate","fireChildActivationStart","fireActivationStart","runCanActivateChild","runCanActivate","canActivate","observable","getToken","canActivateChildGuards","reverse","extractCanActivateChild","guards","canActivateChild","resolveNode","resolvedData","key_1","getResolver","runningResolvers$","resolver","token","processSegmentGroup","freeze","rootNode","routeState","inheritParamsAndData","routeNode","processSegment","config_1","processSegmentAgainstRoute","rawSegment","snapshot_1","DefaultRouteReuseStrategy","shouldDetach","store","detachedTree","shouldAttach","RouterConfigLoader","onLoadStartListener","onLoadEndListener","parentInjector","moduleFactory$","loadModuleFactory","factory","compileModuleAsync","DefaultUrlHandlingStrategy","shouldProcessUrl","extract","merge","newUrlPart","wholeUrl","rootContexts","navigations","navigationId","navigated","hooks","beforePreactivation","afterPreactivation","onLoadStart","triggerEvent","onLoadEnd","resetConfig","currentUrlTree","rawUrlTree","processNavigations","resetRootComponentType","initialNavigation","setUpLocationChangeListener","navigateByUrl","replaceUrl","locationSubscription","Zone","wrap","change","source","setTimeout","scheduleNavigation","serializeUrl","ngOnDestroy","dispose","unsubscribe","navigationExtras","relativeTo","preserveQueryParams","queryParamsHandling","preserveFragment","console","warn","f","q","extras","skipLocationChange","parseUrl","mergedTree","navigate","removeEmptyProps","isActive","executeScheduledNavigation","promise","catch","rawUrl","lastNavigation","reject","rej","urlTransition","then","runNavigate","shouldPreventPushState","shouldReplaceUrl","precreatedState","go","resolvePromise","rejectPromise","urlAndSnapshot$","appliedUrl","redirectsApplied$","preActivation","navigationIsSuccessful","beforePreactivationDone$","preactivationSetup$","evt","preactivationCheckGuards$","preactivationResolveData$","preactivationDone$","routerState$","storedState","storedUrl","isCurrentPathEqualTo","replaceState","ActivateRoutes","activate","resetUrlToCurrentUrlTree","ee","futureState","currState","deactivateChildRoutes","activateChildRoutes","futureChild","childOutletName","deactivateRoutes","parentContext","detachAndStoreRouteSubtree","deactivateRouteAndOutlet","componentRef","detach","onOutletDeactivated","contexts_1","deactivate","activateRoutes","getOrCreateContext","stored","onOutletReAttached","attachRef","attach","cmpFactoryResolver","componentFactoryResolver","activateWith","tabIndex","renderer","el","setAttribute","nativeElement","set","preserve","onClick","type","args","ctorParameters","propDecorators","routerLink","locationStrategy","subscription","updateTargetUrlAndHref","ngOnChanges","changes","button","ctrlKey","metaKey","shiftKey","href","prepareExternalUrl","element","cdr","classes","routerLinkActiveOptions","update","ngAfterContentInit","links","linksWithHrefs","hasActiveLinks","addClass","removeClass","isLinkActive","link","exportAs","descendants","routerLinkActive","Map","onChildOutletCreated","onChildOutletDestroyed","changeDetector","_activatedRoute","activateEvents","deactivateEvents","ngOnInit","instance","cmp","activatedRoute","insert","hostView","destroy","emit","resolveComponentFactory","childContexts","OutletInjector","createComponent","markForCheck","notFoundValue","preload","moduleLoader","preloadingStrategy","onStartLoad","onEndLoad","setUpPreloading","navigations$","processRoutes","preloadConfig","loaded$","ROUTER_DIRECTIVES","useClass","forRoot","providers","forChild","declarations","initNavigation","resultOfPreactivationDone","isLegacyDisabled","isLegacyEnabled","bootstrappedComponentRef","preloader","components","componentTypes","complete","ArrayObservable_1","of","ArrayObservable","concatMap","project","resultSelector","concatMap_1","predicate","thisArg","filter_1","process","platform_browser_dynamic_1","root_module_1","env","NODE_ENV","enableProdMode","platformBrowserDynamic","bootstrapModule","RootModule","platform_browser_1","root_routing_module_1","root_component_1","home_component_1","page_not_found_component_1","NgModule","imports","BrowserModule","RootRoutingModule","RootComponent","bootstrap","router_1","appRoutes","require","oe","Subject_1","ObjectUnsubscribedError_1","BehaviorSubject","_value","getValue","_subscribe","subscriber","closed","hasError","thrownError","ObjectUnsubscribedError","Subject","mergeMap_1","mergeMap","concurrent","Number","POSITIVE_INFINITY","FromObservable_1","from","FromObservable","isArray_1","isArrayLike_1","isPromise_1","PromiseObservable_1","IteratorObservable_1","ArrayLikeObservable_1","iterator_1","Observable_1","observeOn_1","observable_1","ish","scheduler","Observable","isPromise","PromiseObservable","iterator","IteratorObservable","isArrayLike","ArrayLikeObservable","TypeError","ObserveOnSubscriber","getIterator","StringIterator","ArrayIterator","toLength","o","len","isNaN","numberIsFinite","sign","Math","floor","abs","maxSafeInteger","root_1","isFinite","valueAsNumber","dispatch","done","return","schedule","pow","ScalarObservable_1","EmptyObservable_1","arrayLike","_isScalar","EmptyObservable","ScalarObservable","observeOn","delay","lift","ObserveOnOperator","Subscriber_1","Notification_1","destination","arg","notification","observe","scheduleMessage","add","ObserveOnMessage","_next","Notification","createNext","_error","createError","_complete","createComplete","Subscriber","kind","hasValue","observer","do","accept","nextOrObserver","toObservable","throw","empty","undefinedValueNotification","completeNotification","_catch","catchError_1","catchError","operator","CatchOperator","caught","OuterSubscriber_1","subscribeToResult_1","CatchSubscriber","isStopped","err2","_unsubscribeAndRecycle","subscribeToResult","OuterSubscriber","concatAll","concatAll_1","mergeAll_1","mergeAll","first","defaultValue","first_1","FirstOperator","EmptyError_1","FirstSubscriber","hasCompleted","_emitted","_tryPredicate","_emit","_tryResultSelector","_emitFinal","every_1","EveryOperator","EverySubscriber","notifyComplete","everyValueMatch","last","last_1","LastOperator","LastSubscriber","lastValue","accumulator","seed","reduce_1","pipe_1","pipe","scan_1","scan","takeLast_1","takeLast","defaultIfEmpty_1","defaultIfEmpty","acc","hasSeed","ScanOperator","ScanSubscriber","_seed","_tryNext","count","TakeLastOperator","ArgumentOutOfRangeError_1","total","ArgumentOutOfRangeError","TakeLastSubscriber","ring","DefaultIfEmptyOperator","DefaultIfEmptySubscriber","isEmpty","FilterOperator","FilterSubscriber"],"mappings":"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","file":"main-bundle.js","sourcesContent":["webpackJsonp([2],Array(20).concat([\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * An error thrown when an Observable or a sequence was queried but has no\n * elements.\n *\n * @see {@link first}\n * @see {@link last}\n * @see {@link single}\n *\n * @class EmptyError\n */\nvar EmptyError = (function (_super) {\n    __extends(EmptyError, _super);\n    function EmptyError() {\n        var err = _super.call(this, 'no elements in sequence');\n        this.name = err.name = 'EmptyError';\n        this.stack = err.stack;\n        this.message = err.message;\n    }\n    return EmptyError;\n}(Error));\nexports.EmptyError = EmptyError;\n//# sourceMappingURL=EmptyError.js.map\n\n/***/ }),\n/* 21 */,\n/* 22 */,\n/* 23 */,\n/* 24 */,\n/* 25 */,\n/* 26 */,\n/* 27 */,\n/* 28 */,\n/* 29 */,\n/* 30 */,\n/* 31 */,\n/* 32 */,\n/* 33 */,\n/* 34 */,\n/* 35 */,\n/* 36 */,\n/* 37 */,\n/* 38 */,\n/* 39 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar core_1 = __webpack_require__(2);\r\nvar HomeComponent = /** @class */ (function () {\r\n    function HomeComponent() {\r\n    }\r\n    HomeComponent = __decorate([\r\n        core_1.Component({\r\n            selector: 'internal-home',\r\n            template: __webpack_require__(101)\r\n        })\r\n    ], HomeComponent);\r\n    return HomeComponent;\r\n}());\r\nexports.HomeComponent = HomeComponent;\r\n\n\n/***/ }),\n/* 40 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar core_1 = __webpack_require__(2);\r\nvar PageNotFoundComponent = /** @class */ (function () {\r\n    function PageNotFoundComponent() {\r\n    }\r\n    PageNotFoundComponent = __decorate([\r\n        core_1.Component({\r\n            template: __webpack_require__(102)\r\n        })\r\n    ], PageNotFoundComponent);\r\n    return PageNotFoundComponent;\r\n}());\r\nexports.PageNotFoundComponent = PageNotFoundComponent;\r\n\n\n/***/ }),\n/* 41 */,\n/* 42 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RouterLink\", function() { return RouterLink; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RouterLinkWithHref\", function() { return RouterLinkWithHref; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RouterLinkActive\", function() { return RouterLinkActive; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RouterOutlet\", function() { return RouterOutlet; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ActivationEnd\", function() { return ActivationEnd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ActivationStart\", function() { return ActivationStart; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ChildActivationEnd\", function() { return ChildActivationEnd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ChildActivationStart\", function() { return ChildActivationStart; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GuardsCheckEnd\", function() { return GuardsCheckEnd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GuardsCheckStart\", function() { return GuardsCheckStart; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NavigationCancel\", function() { return NavigationCancel; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NavigationEnd\", function() { return NavigationEnd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NavigationError\", function() { return NavigationError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NavigationStart\", function() { return NavigationStart; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ResolveEnd\", function() { return ResolveEnd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ResolveStart\", function() { return ResolveStart; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RouteConfigLoadEnd\", function() { return RouteConfigLoadEnd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RouteConfigLoadStart\", function() { return RouteConfigLoadStart; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RouterEvent\", function() { return RouterEvent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RoutesRecognized\", function() { return RoutesRecognized; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RouteReuseStrategy\", function() { return RouteReuseStrategy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Router\", function() { return Router; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ROUTES\", function() { return ROUTES; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ROUTER_CONFIGURATION\", function() { return ROUTER_CONFIGURATION; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ROUTER_INITIALIZER\", function() { return ROUTER_INITIALIZER; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RouterModule\", function() { return RouterModule; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"provideRoutes\", function() { return provideRoutes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ChildrenOutletContexts\", function() { return ChildrenOutletContexts; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OutletContext\", function() { return OutletContext; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NoPreloading\", function() { return NoPreloading; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PreloadAllModules\", function() { return PreloadAllModules; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PreloadingStrategy\", function() { return PreloadingStrategy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RouterPreloader\", function() { return RouterPreloader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ActivatedRoute\", function() { return ActivatedRoute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ActivatedRouteSnapshot\", function() { return ActivatedRouteSnapshot; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RouterState\", function() { return RouterState; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RouterStateSnapshot\", function() { return RouterStateSnapshot; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PRIMARY_OUTLET\", function() { return PRIMARY_OUTLET; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"convertToParamMap\", function() { return convertToParamMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UrlHandlingStrategy\", function() { return UrlHandlingStrategy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DefaultUrlSerializer\", function() { return DefaultUrlSerializer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UrlSegment\", function() { return UrlSegment; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UrlSegmentGroup\", function() { return UrlSegmentGroup; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UrlSerializer\", function() { return UrlSerializer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UrlTree\", function() { return UrlTree; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VERSION\", function() { return VERSION; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ROUTER_PROVIDERS\", function() { return ROUTER_PROVIDERS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"flatten\", function() { return flatten; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return ROUTER_FORROOT_GUARD; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"g\", function() { return RouterInitializer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"h\", function() { return getAppInitializer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"i\", function() { return getBootstrapListener; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return provideForRootGuard; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return provideLocationStrategy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"j\", function() { return provideRouterInitializer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"f\", function() { return rootRoute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return routerNgProbeToken; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return setupRouter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"k\", function() { return Tree; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"l\", function() { return TreeNode; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_common__ = __webpack_require__(8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_tslib__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_rxjs_BehaviorSubject__ = __webpack_require__(74);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_rxjs_BehaviorSubject___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_rxjs_BehaviorSubject__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_rxjs_Subject__ = __webpack_require__(7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_rxjs_Subject___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_rxjs_Subject__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs_observable_of__ = __webpack_require__(44);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs_observable_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_of__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_rxjs_operator_concatMap__ = __webpack_require__(45);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_rxjs_operator_concatMap___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_rxjs_operator_concatMap__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_rxjs_operator_map__ = __webpack_require__(21);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_rxjs_operator_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_rxjs_operator_map__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_rxjs_operator_mergeMap__ = __webpack_require__(76);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_rxjs_operator_mergeMap___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_rxjs_operator_mergeMap__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_rxjs_Observable__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9_rxjs_Observable__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_rxjs_observable_from__ = __webpack_require__(77);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_rxjs_observable_from___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10_rxjs_observable_from__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_catch__ = __webpack_require__(83);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_catch___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_11_rxjs_operator_catch__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_rxjs_operator_concatAll__ = __webpack_require__(85);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_rxjs_operator_concatAll___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_12_rxjs_operator_concatAll__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_rxjs_operator_first__ = __webpack_require__(87);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_rxjs_operator_first___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_13_rxjs_operator_first__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_rxjs_util_EmptyError__ = __webpack_require__(20);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_rxjs_util_EmptyError___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_14_rxjs_util_EmptyError__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_rxjs_observable_fromPromise__ = __webpack_require__(37);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_rxjs_observable_fromPromise___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_15_rxjs_observable_fromPromise__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16_rxjs_operator_every__ = __webpack_require__(89);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16_rxjs_operator_every___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_16_rxjs_operator_every__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17_rxjs_operator_last__ = __webpack_require__(91);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17_rxjs_operator_last___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_17_rxjs_operator_last__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18_rxjs_operator_mergeAll__ = __webpack_require__(93);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18_rxjs_operator_mergeAll___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_18_rxjs_operator_mergeAll__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19_rxjs_operator_reduce__ = __webpack_require__(94);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19_rxjs_operator_reduce___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_19_rxjs_operator_reduce__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__angular_platform_browser__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21_rxjs_operator_filter__ = __webpack_require__(46);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21_rxjs_operator_filter___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_21_rxjs_operator_filter__);\n/**\n * @license Angular v5.0.1\n * (c) 2010-2017 Google, Inc. https://angular.io/\n * License: MIT\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * \\@whatItDoes Base for events the Router goes through, as opposed to events tied to a specific\n * Route. `RouterEvent`s will only be fired one time for any given navigation.\n *\n * Example:\n *\n * ```\n * class MyService {\n *   constructor(public router: Router, logger: Logger) {\n *     router.events.filter(e => e instanceof RouterEvent).subscribe(e => {\n *       logger.log(e.id, e.url);\n *     });\n *   }\n * }\n * ```\n *\n * \\@experimental\n */\nvar RouterEvent = (function () {\n    function RouterEvent(id, url) {\n        this.id = id;\n        this.url = url;\n    }\n    return RouterEvent;\n}());\n/**\n * \\@whatItDoes Represents an event triggered when a navigation starts.\n *\n * \\@stable\n */\nvar NavigationStart = (function (_super) {\n    Object(__WEBPACK_IMPORTED_MODULE_2_tslib__[\"b\" /* __extends */])(NavigationStart, _super);\n    function NavigationStart() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /** @docsNotRequired */\n    /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    NavigationStart.prototype.toString = /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    function () { return \"NavigationStart(id: \" + this.id + \", url: '\" + this.url + \"')\"; };\n    return NavigationStart;\n}(RouterEvent));\n/**\n * \\@whatItDoes Represents an event triggered when a navigation ends successfully.\n *\n * \\@stable\n */\nvar NavigationEnd = (function (_super) {\n    Object(__WEBPACK_IMPORTED_MODULE_2_tslib__[\"b\" /* __extends */])(NavigationEnd, _super);\n    function NavigationEnd(/** @docsNotRequired */\n        /** @docsNotRequired */\n        id, /** @docsNotRequired */\n        /** @docsNotRequired */\n        url, urlAfterRedirects) {\n        var _this = _super.call(this, id, url) || this;\n        _this.urlAfterRedirects = urlAfterRedirects;\n        return _this;\n    }\n    /** @docsNotRequired */\n    /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    NavigationEnd.prototype.toString = /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    function () {\n        return \"NavigationEnd(id: \" + this.id + \", url: '\" + this.url + \"', urlAfterRedirects: '\" + this.urlAfterRedirects + \"')\";\n    };\n    return NavigationEnd;\n}(RouterEvent));\n/**\n * \\@whatItDoes Represents an event triggered when a navigation is canceled.\n *\n * \\@stable\n */\nvar NavigationCancel = (function (_super) {\n    Object(__WEBPACK_IMPORTED_MODULE_2_tslib__[\"b\" /* __extends */])(NavigationCancel, _super);\n    function NavigationCancel(/** @docsNotRequired */\n        /** @docsNotRequired */\n        id, /** @docsNotRequired */\n        /** @docsNotRequired */\n        url, reason) {\n        var _this = _super.call(this, id, url) || this;\n        _this.reason = reason;\n        return _this;\n    }\n    /** @docsNotRequired */\n    /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    NavigationCancel.prototype.toString = /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    function () { return \"NavigationCancel(id: \" + this.id + \", url: '\" + this.url + \"')\"; };\n    return NavigationCancel;\n}(RouterEvent));\n/**\n * \\@whatItDoes Represents an event triggered when a navigation fails due to an unexpected error.\n *\n * \\@stable\n */\nvar NavigationError = (function (_super) {\n    Object(__WEBPACK_IMPORTED_MODULE_2_tslib__[\"b\" /* __extends */])(NavigationError, _super);\n    function NavigationError(/** @docsNotRequired */\n        /** @docsNotRequired */\n        id, /** @docsNotRequired */\n        /** @docsNotRequired */\n        url, error) {\n        var _this = _super.call(this, id, url) || this;\n        _this.error = error;\n        return _this;\n    }\n    /** @docsNotRequired */\n    /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    NavigationError.prototype.toString = /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    function () {\n        return \"NavigationError(id: \" + this.id + \", url: '\" + this.url + \"', error: \" + this.error + \")\";\n    };\n    return NavigationError;\n}(RouterEvent));\n/**\n * \\@whatItDoes Represents an event triggered when routes are recognized.\n *\n * \\@stable\n */\nvar RoutesRecognized = (function (_super) {\n    Object(__WEBPACK_IMPORTED_MODULE_2_tslib__[\"b\" /* __extends */])(RoutesRecognized, _super);\n    function RoutesRecognized(/** @docsNotRequired */\n        /** @docsNotRequired */\n        id, /** @docsNotRequired */\n        /** @docsNotRequired */\n        url, urlAfterRedirects, state) {\n        var _this = _super.call(this, id, url) || this;\n        _this.urlAfterRedirects = urlAfterRedirects;\n        _this.state = state;\n        return _this;\n    }\n    /** @docsNotRequired */\n    /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    RoutesRecognized.prototype.toString = /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    function () {\n        return \"RoutesRecognized(id: \" + this.id + \", url: '\" + this.url + \"', urlAfterRedirects: '\" + this.urlAfterRedirects + \"', state: \" + this.state + \")\";\n    };\n    return RoutesRecognized;\n}(RouterEvent));\n/**\n * \\@whatItDoes Represents the start of the Guard phase of routing.\n *\n * \\@experimental\n */\nvar GuardsCheckStart = (function (_super) {\n    Object(__WEBPACK_IMPORTED_MODULE_2_tslib__[\"b\" /* __extends */])(GuardsCheckStart, _super);\n    function GuardsCheckStart(/** @docsNotRequired */\n        /** @docsNotRequired */\n        id, /** @docsNotRequired */\n        /** @docsNotRequired */\n        url, urlAfterRedirects, state) {\n        var _this = _super.call(this, id, url) || this;\n        _this.urlAfterRedirects = urlAfterRedirects;\n        _this.state = state;\n        return _this;\n    }\n    /**\n     * @return {?}\n     */\n    GuardsCheckStart.prototype.toString = /**\n     * @return {?}\n     */\n    function () {\n        return \"GuardsCheckStart(id: \" + this.id + \", url: '\" + this.url + \"', urlAfterRedirects: '\" + this.urlAfterRedirects + \"', state: \" + this.state + \")\";\n    };\n    return GuardsCheckStart;\n}(RouterEvent));\n/**\n * \\@whatItDoes Represents the end of the Guard phase of routing.\n *\n * \\@experimental\n */\nvar GuardsCheckEnd = (function (_super) {\n    Object(__WEBPACK_IMPORTED_MODULE_2_tslib__[\"b\" /* __extends */])(GuardsCheckEnd, _super);\n    function GuardsCheckEnd(/** @docsNotRequired */\n        /** @docsNotRequired */\n        id, /** @docsNotRequired */\n        /** @docsNotRequired */\n        url, urlAfterRedirects, state, shouldActivate) {\n        var _this = _super.call(this, id, url) || this;\n        _this.urlAfterRedirects = urlAfterRedirects;\n        _this.state = state;\n        _this.shouldActivate = shouldActivate;\n        return _this;\n    }\n    /**\n     * @return {?}\n     */\n    GuardsCheckEnd.prototype.toString = /**\n     * @return {?}\n     */\n    function () {\n        return \"GuardsCheckEnd(id: \" + this.id + \", url: '\" + this.url + \"', urlAfterRedirects: '\" + this.urlAfterRedirects + \"', state: \" + this.state + \", shouldActivate: \" + this.shouldActivate + \")\";\n    };\n    return GuardsCheckEnd;\n}(RouterEvent));\n/**\n * \\@whatItDoes Represents the start of the Resolve phase of routing. The timing of this\n * event may change, thus it's experimental. In the current iteration it will run\n * in the \"resolve\" phase whether there's things to resolve or not. In the future this\n * behavior may change to only run when there are things to be resolved.\n *\n * \\@experimental\n */\nvar ResolveStart = (function (_super) {\n    Object(__WEBPACK_IMPORTED_MODULE_2_tslib__[\"b\" /* __extends */])(ResolveStart, _super);\n    function ResolveStart(/** @docsNotRequired */\n        /** @docsNotRequired */\n        id, /** @docsNotRequired */\n        /** @docsNotRequired */\n        url, urlAfterRedirects, state) {\n        var _this = _super.call(this, id, url) || this;\n        _this.urlAfterRedirects = urlAfterRedirects;\n        _this.state = state;\n        return _this;\n    }\n    /**\n     * @return {?}\n     */\n    ResolveStart.prototype.toString = /**\n     * @return {?}\n     */\n    function () {\n        return \"ResolveStart(id: \" + this.id + \", url: '\" + this.url + \"', urlAfterRedirects: '\" + this.urlAfterRedirects + \"', state: \" + this.state + \")\";\n    };\n    return ResolveStart;\n}(RouterEvent));\n/**\n * \\@whatItDoes Represents the end of the Resolve phase of routing. See note on\n * {\\@link ResolveStart} for use of this experimental API.\n *\n * \\@experimental\n */\nvar ResolveEnd = (function (_super) {\n    Object(__WEBPACK_IMPORTED_MODULE_2_tslib__[\"b\" /* __extends */])(ResolveEnd, _super);\n    function ResolveEnd(/** @docsNotRequired */\n        /** @docsNotRequired */\n        id, /** @docsNotRequired */\n        /** @docsNotRequired */\n        url, urlAfterRedirects, state) {\n        var _this = _super.call(this, id, url) || this;\n        _this.urlAfterRedirects = urlAfterRedirects;\n        _this.state = state;\n        return _this;\n    }\n    /**\n     * @return {?}\n     */\n    ResolveEnd.prototype.toString = /**\n     * @return {?}\n     */\n    function () {\n        return \"ResolveEnd(id: \" + this.id + \", url: '\" + this.url + \"', urlAfterRedirects: '\" + this.urlAfterRedirects + \"', state: \" + this.state + \")\";\n    };\n    return ResolveEnd;\n}(RouterEvent));\n/**\n * \\@whatItDoes Represents an event triggered before lazy loading a route config.\n *\n * \\@experimental\n */\nvar RouteConfigLoadStart = (function () {\n    function RouteConfigLoadStart(route) {\n        this.route = route;\n    }\n    /**\n     * @return {?}\n     */\n    RouteConfigLoadStart.prototype.toString = /**\n     * @return {?}\n     */\n    function () { return \"RouteConfigLoadStart(path: \" + this.route.path + \")\"; };\n    return RouteConfigLoadStart;\n}());\n/**\n * \\@whatItDoes Represents an event triggered when a route has been lazy loaded.\n *\n * \\@experimental\n */\nvar RouteConfigLoadEnd = (function () {\n    function RouteConfigLoadEnd(route) {\n        this.route = route;\n    }\n    /**\n     * @return {?}\n     */\n    RouteConfigLoadEnd.prototype.toString = /**\n     * @return {?}\n     */\n    function () { return \"RouteConfigLoadEnd(path: \" + this.route.path + \")\"; };\n    return RouteConfigLoadEnd;\n}());\n/**\n * \\@whatItDoes Represents the start of end of the Resolve phase of routing. See note on\n * {\\@link ChildActivationEnd} for use of this experimental API.\n *\n * \\@experimental\n */\nvar ChildActivationStart = (function () {\n    function ChildActivationStart(snapshot) {\n        this.snapshot = snapshot;\n    }\n    /**\n     * @return {?}\n     */\n    ChildActivationStart.prototype.toString = /**\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n        return \"ChildActivationStart(path: '\" + path + \"')\";\n    };\n    return ChildActivationStart;\n}());\n/**\n * \\@whatItDoes Represents the start of end of the Resolve phase of routing. See note on\n * {\\@link ChildActivationStart} for use of this experimental API.\n *\n * \\@experimental\n */\nvar ChildActivationEnd = (function () {\n    function ChildActivationEnd(snapshot) {\n        this.snapshot = snapshot;\n    }\n    /**\n     * @return {?}\n     */\n    ChildActivationEnd.prototype.toString = /**\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n        return \"ChildActivationEnd(path: '\" + path + \"')\";\n    };\n    return ChildActivationEnd;\n}());\n/**\n * \\@whatItDoes Represents the start of end of the Resolve phase of routing. See note on\n * {\\@link ActivationEnd} for use of this experimental API.\n *\n * \\@experimental\n */\nvar ActivationStart = (function () {\n    function ActivationStart(snapshot) {\n        this.snapshot = snapshot;\n    }\n    /**\n     * @return {?}\n     */\n    ActivationStart.prototype.toString = /**\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n        return \"ActivationStart(path: '\" + path + \"')\";\n    };\n    return ActivationStart;\n}());\n/**\n * \\@whatItDoes Represents the start of end of the Resolve phase of routing. See note on\n * {\\@link ActivationStart} for use of this experimental API.\n *\n * \\@experimental\n */\nvar ActivationEnd = (function () {\n    function ActivationEnd(snapshot) {\n        this.snapshot = snapshot;\n    }\n    /**\n     * @return {?}\n     */\n    ActivationEnd.prototype.toString = /**\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n        return \"ActivationEnd(path: '\" + path + \"')\";\n    };\n    return ActivationEnd;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * \\@whatItDoes Name of the primary outlet.\n *\n * \\@stable\n */\nvar PRIMARY_OUTLET = 'primary';\n/**\n * Matrix and Query parameters.\n *\n * `ParamMap` makes it easier to work with parameters as they could have either a single value or\n * multiple value. Because this should be known by the user, calling `get` or `getAll` returns the\n * correct type (either `string` or `string[]`).\n *\n * The API is inspired by the URLSearchParams interface.\n * see https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams\n *\n * \\@stable\n * @record\n */\n\nvar ParamsAsMap = (function () {\n    function ParamsAsMap(params) {\n        this.params = params || {};\n    }\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    ParamsAsMap.prototype.has = /**\n     * @param {?} name\n     * @return {?}\n     */\n    function (name) { return this.params.hasOwnProperty(name); };\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    ParamsAsMap.prototype.get = /**\n     * @param {?} name\n     * @return {?}\n     */\n    function (name) {\n        if (this.has(name)) {\n            var /** @type {?} */ v = this.params[name];\n            return Array.isArray(v) ? v[0] : v;\n        }\n        return null;\n    };\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    ParamsAsMap.prototype.getAll = /**\n     * @param {?} name\n     * @return {?}\n     */\n    function (name) {\n        if (this.has(name)) {\n            var /** @type {?} */ v = this.params[name];\n            return Array.isArray(v) ? v : [v];\n        }\n        return [];\n    };\n    Object.defineProperty(ParamsAsMap.prototype, \"keys\", {\n        get: /**\n         * @return {?}\n         */\n        function () { return Object.keys(this.params); },\n        enumerable: true,\n        configurable: true\n    });\n    return ParamsAsMap;\n}());\n/**\n * Convert a {\\@link Params} instance to a {\\@link ParamMap}.\n *\n * \\@stable\n * @param {?} params\n * @return {?}\n */\nfunction convertToParamMap(params) {\n    return new ParamsAsMap(params);\n}\nvar NAVIGATION_CANCELING_ERROR = 'ngNavigationCancelingError';\n/**\n * @param {?} message\n * @return {?}\n */\nfunction navigationCancelingError(message) {\n    var /** @type {?} */ error = Error('NavigationCancelingError: ' + message);\n    (/** @type {?} */ (error))[NAVIGATION_CANCELING_ERROR] = true;\n    return error;\n}\n/**\n * @param {?} error\n * @return {?}\n */\nfunction isNavigationCancelingError(error) {\n    return error && (/** @type {?} */ (error))[NAVIGATION_CANCELING_ERROR];\n}\n/**\n * @param {?} segments\n * @param {?} segmentGroup\n * @param {?} route\n * @return {?}\n */\nfunction defaultUrlMatcher(segments, segmentGroup, route) {\n    var /** @type {?} */ parts = /** @type {?} */ ((route.path)).split('/');\n    if (parts.length > segments.length) {\n        // The actual URL is shorter than the config, no match\n        return null;\n    }\n    if (route.pathMatch === 'full' &&\n        (segmentGroup.hasChildren() || parts.length < segments.length)) {\n        // The config is longer than the actual URL but we are looking for a full match, return null\n        return null;\n    }\n    var /** @type {?} */ posParams = {};\n    // Check each config part against the actual URL\n    for (var /** @type {?} */ index = 0; index < parts.length; index++) {\n        var /** @type {?} */ part = parts[index];\n        var /** @type {?} */ segment = segments[index];\n        var /** @type {?} */ isParameter = part.startsWith(':');\n        if (isParameter) {\n            posParams[part.substring(1)] = segment;\n        }\n        else if (part !== segment.path) {\n            // The actual URL part does not match the config, no match\n            return null;\n        }\n    }\n    return { consumed: segments.slice(0, parts.length), posParams: posParams };\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * See {\\@link Routes} for more details.\n * \\@stable\n * @record\n */\n\nvar LoadedRouterConfig = (function () {\n    function LoadedRouterConfig(routes, module) {\n        this.routes = routes;\n        this.module = module;\n    }\n    return LoadedRouterConfig;\n}());\n/**\n * @param {?} config\n * @param {?=} parentPath\n * @return {?}\n */\nfunction validateConfig(config, parentPath) {\n    if (parentPath === void 0) { parentPath = ''; }\n    // forEach doesn't iterate undefined values\n    for (var /** @type {?} */ i = 0; i < config.length; i++) {\n        var /** @type {?} */ route = config[i];\n        var /** @type {?} */ fullPath = getFullPath(parentPath, route);\n        validateNode(route, fullPath);\n    }\n}\n/**\n * @param {?} route\n * @param {?} fullPath\n * @return {?}\n */\nfunction validateNode(route, fullPath) {\n    if (!route) {\n        throw new Error(\"\\n      Invalid configuration of route '\" + fullPath + \"': Encountered undefined route.\\n      The reason might be an extra comma.\\n\\n      Example:\\n      const routes: Routes = [\\n        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },\\n        { path: 'dashboard',  component: DashboardComponent },, << two commas\\n        { path: 'detail/:id', component: HeroDetailComponent }\\n      ];\\n    \");\n    }\n    if (Array.isArray(route)) {\n        throw new Error(\"Invalid configuration of route '\" + fullPath + \"': Array cannot be specified\");\n    }\n    if (!route.component && (route.outlet && route.outlet !== PRIMARY_OUTLET)) {\n        throw new Error(\"Invalid configuration of route '\" + fullPath + \"': a componentless route cannot have a named outlet set\");\n    }\n    if (route.redirectTo && route.children) {\n        throw new Error(\"Invalid configuration of route '\" + fullPath + \"': redirectTo and children cannot be used together\");\n    }\n    if (route.redirectTo && route.loadChildren) {\n        throw new Error(\"Invalid configuration of route '\" + fullPath + \"': redirectTo and loadChildren cannot be used together\");\n    }\n    if (route.children && route.loadChildren) {\n        throw new Error(\"Invalid configuration of route '\" + fullPath + \"': children and loadChildren cannot be used together\");\n    }\n    if (route.redirectTo && route.component) {\n        throw new Error(\"Invalid configuration of route '\" + fullPath + \"': redirectTo and component cannot be used together\");\n    }\n    if (route.path && route.matcher) {\n        throw new Error(\"Invalid configuration of route '\" + fullPath + \"': path and matcher cannot be used together\");\n    }\n    if (route.redirectTo === void 0 && !route.component && !route.children && !route.loadChildren) {\n        throw new Error(\"Invalid configuration of route '\" + fullPath + \"'. One of the following must be provided: component, redirectTo, children or loadChildren\");\n    }\n    if (route.path === void 0 && route.matcher === void 0) {\n        throw new Error(\"Invalid configuration of route '\" + fullPath + \"': routes must have either a path or a matcher specified\");\n    }\n    if (typeof route.path === 'string' && route.path.charAt(0) === '/') {\n        throw new Error(\"Invalid configuration of route '\" + fullPath + \"': path cannot start with a slash\");\n    }\n    if (route.path === '' && route.redirectTo !== void 0 && route.pathMatch === void 0) {\n        var /** @type {?} */ exp = \"The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.\";\n        throw new Error(\"Invalid configuration of route '{path: \\\"\" + fullPath + \"\\\", redirectTo: \\\"\" + route.redirectTo + \"\\\"}': please provide 'pathMatch'. \" + exp);\n    }\n    if (route.pathMatch !== void 0 && route.pathMatch !== 'full' && route.pathMatch !== 'prefix') {\n        throw new Error(\"Invalid configuration of route '\" + fullPath + \"': pathMatch can only be set to 'prefix' or 'full'\");\n    }\n    if (route.children) {\n        validateConfig(route.children, fullPath);\n    }\n}\n/**\n * @param {?} parentPath\n * @param {?} currentRoute\n * @return {?}\n */\nfunction getFullPath(parentPath, currentRoute) {\n    if (!currentRoute) {\n        return parentPath;\n    }\n    if (!parentPath && !currentRoute.path) {\n        return '';\n    }\n    else if (parentPath && !currentRoute.path) {\n        return parentPath + \"/\";\n    }\n    else if (!parentPath && currentRoute.path) {\n        return currentRoute.path;\n    }\n    else {\n        return parentPath + \"/\" + currentRoute.path;\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @param {?} a\n * @param {?} b\n * @return {?}\n */\nfunction shallowEqualArrays(a, b) {\n    if (a.length !== b.length)\n        return false;\n    for (var /** @type {?} */ i = 0; i < a.length; ++i) {\n        if (!shallowEqual(a[i], b[i]))\n            return false;\n    }\n    return true;\n}\n/**\n * @param {?} a\n * @param {?} b\n * @return {?}\n */\nfunction shallowEqual(a, b) {\n    var /** @type {?} */ k1 = Object.keys(a);\n    var /** @type {?} */ k2 = Object.keys(b);\n    if (k1.length != k2.length) {\n        return false;\n    }\n    var /** @type {?} */ key;\n    for (var /** @type {?} */ i = 0; i < k1.length; i++) {\n        key = k1[i];\n        if (a[key] !== b[key]) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Flattens single-level nested arrays.\n * @template T\n * @param {?} arr\n * @return {?}\n */\nfunction flatten(arr) {\n    return Array.prototype.concat.apply([], arr);\n}\n/**\n * Return the last element of an array.\n * @template T\n * @param {?} a\n * @return {?}\n */\nfunction last$1(a) {\n    return a.length > 0 ? a[a.length - 1] : null;\n}\n/**\n * Verifys all booleans in an array are `true`.\n * @param {?} bools\n * @return {?}\n */\n\n/**\n * @template K, V\n * @param {?} map\n * @param {?} callback\n * @return {?}\n */\nfunction forEach(map$$1, callback) {\n    for (var /** @type {?} */ prop in map$$1) {\n        if (map$$1.hasOwnProperty(prop)) {\n            callback(map$$1[prop], prop);\n        }\n    }\n}\n/**\n * @template A, B\n * @param {?} obj\n * @param {?} fn\n * @return {?}\n */\nfunction waitForMap(obj, fn) {\n    if (Object.keys(obj).length === 0) {\n        return Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_of__[\"of\"])({});\n    }\n    var /** @type {?} */ waitHead = [];\n    var /** @type {?} */ waitTail = [];\n    var /** @type {?} */ res = {};\n    forEach(obj, function (a, k) {\n        var /** @type {?} */ mapped = __WEBPACK_IMPORTED_MODULE_7_rxjs_operator_map__[\"map\"].call(fn(k, a), function (r) { return res[k] = r; });\n        if (k === PRIMARY_OUTLET) {\n            waitHead.push(mapped);\n        }\n        else {\n            waitTail.push(mapped);\n        }\n    });\n    var /** @type {?} */ concat$ = __WEBPACK_IMPORTED_MODULE_12_rxjs_operator_concatAll__[\"concatAll\"].call(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_of__[\"of\"].apply(void 0, waitHead.concat(waitTail)));\n    var /** @type {?} */ last$ = __WEBPACK_IMPORTED_MODULE_17_rxjs_operator_last__[\"last\"].call(concat$);\n    return __WEBPACK_IMPORTED_MODULE_7_rxjs_operator_map__[\"map\"].call(last$, function () { return res; });\n}\n/**\n * ANDs Observables by merging all input observables, reducing to an Observable verifying all\n * input Observables return `true`.\n * @param {?} observables\n * @return {?}\n */\nfunction andObservables(observables) {\n    var /** @type {?} */ merged$ = __WEBPACK_IMPORTED_MODULE_18_rxjs_operator_mergeAll__[\"mergeAll\"].call(observables);\n    return __WEBPACK_IMPORTED_MODULE_16_rxjs_operator_every__[\"every\"].call(merged$, function (result) { return result === true; });\n}\n/**\n * @template T\n * @param {?} value\n * @return {?}\n */\nfunction wrapIntoObservable(value) {\n    if (Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"isObservable\"])(value)) {\n        return value;\n    }\n    if (Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"isPromise\"])(value)) {\n        // Use `Promise.resolve()` to wrap promise-like instances.\n        // Required ie when a Resolver returns a AngularJS `$q` promise to correctly trigger the\n        // change detection.\n        return Object(__WEBPACK_IMPORTED_MODULE_15_rxjs_observable_fromPromise__[\"fromPromise\"])(Promise.resolve(value));\n    }\n    return Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_of__[\"of\"])(/** @type {?} */ (value));\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @return {?}\n */\nfunction createEmptyUrlTree() {\n    return new UrlTree(new UrlSegmentGroup([], {}), {}, null);\n}\n/**\n * @param {?} container\n * @param {?} containee\n * @param {?} exact\n * @return {?}\n */\nfunction containsTree(container, containee, exact) {\n    if (exact) {\n        return equalQueryParams(container.queryParams, containee.queryParams) &&\n            equalSegmentGroups(container.root, containee.root);\n    }\n    return containsQueryParams(container.queryParams, containee.queryParams) &&\n        containsSegmentGroup(container.root, containee.root);\n}\n/**\n * @param {?} container\n * @param {?} containee\n * @return {?}\n */\nfunction equalQueryParams(container, containee) {\n    return shallowEqual(container, containee);\n}\n/**\n * @param {?} container\n * @param {?} containee\n * @return {?}\n */\nfunction equalSegmentGroups(container, containee) {\n    if (!equalPath(container.segments, containee.segments))\n        return false;\n    if (container.numberOfChildren !== containee.numberOfChildren)\n        return false;\n    for (var /** @type {?} */ c in containee.children) {\n        if (!container.children[c])\n            return false;\n        if (!equalSegmentGroups(container.children[c], containee.children[c]))\n            return false;\n    }\n    return true;\n}\n/**\n * @param {?} container\n * @param {?} containee\n * @return {?}\n */\nfunction containsQueryParams(container, containee) {\n    return Object.keys(containee).length <= Object.keys(container).length &&\n        Object.keys(containee).every(function (key) { return containee[key] === container[key]; });\n}\n/**\n * @param {?} container\n * @param {?} containee\n * @return {?}\n */\nfunction containsSegmentGroup(container, containee) {\n    return containsSegmentGroupHelper(container, containee, containee.segments);\n}\n/**\n * @param {?} container\n * @param {?} containee\n * @param {?} containeePaths\n * @return {?}\n */\nfunction containsSegmentGroupHelper(container, containee, containeePaths) {\n    if (container.segments.length > containeePaths.length) {\n        var /** @type {?} */ current = container.segments.slice(0, containeePaths.length);\n        if (!equalPath(current, containeePaths))\n            return false;\n        if (containee.hasChildren())\n            return false;\n        return true;\n    }\n    else if (container.segments.length === containeePaths.length) {\n        if (!equalPath(container.segments, containeePaths))\n            return false;\n        for (var /** @type {?} */ c in containee.children) {\n            if (!container.children[c])\n                return false;\n            if (!containsSegmentGroup(container.children[c], containee.children[c]))\n                return false;\n        }\n        return true;\n    }\n    else {\n        var /** @type {?} */ current = containeePaths.slice(0, container.segments.length);\n        var /** @type {?} */ next = containeePaths.slice(container.segments.length);\n        if (!equalPath(container.segments, current))\n            return false;\n        if (!container.children[PRIMARY_OUTLET])\n            return false;\n        return containsSegmentGroupHelper(container.children[PRIMARY_OUTLET], containee, next);\n    }\n}\n/**\n * \\@whatItDoes Represents the parsed URL.\n *\n * \\@howToUse\n *\n * ```\n * \\@Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const tree: UrlTree =\n *       router.parseUrl('/team/33/(user/victor//support:help)?debug=true#fragment');\n *     const f = tree.fragment; // return 'fragment'\n *     const q = tree.queryParams; // returns {debug: 'true'}\n *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n *     const s: UrlSegment[] = g.segments; // returns 2 segments 'team' and '33'\n *     g.children[PRIMARY_OUTLET].segments; // returns 2 segments 'user' and 'victor'\n *     g.children['support'].segments; // return 1 segment 'help'\n *   }\n * }\n * ```\n *\n * \\@description\n *\n * Since a router state is a tree, and the URL is nothing but a serialized state, the URL is a\n * serialized tree.\n * UrlTree is a data structure that provides a lot of affordances in dealing with URLs\n *\n * \\@stable\n */\nvar UrlTree = (function () {\n    /** @internal */\n    function UrlTree(root, queryParams, fragment) {\n        this.root = root;\n        this.queryParams = queryParams;\n        this.fragment = fragment;\n    }\n    Object.defineProperty(UrlTree.prototype, \"queryParamMap\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            if (!this._queryParamMap) {\n                this._queryParamMap = convertToParamMap(this.queryParams);\n            }\n            return this._queryParamMap;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** @docsNotRequired */\n    /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    UrlTree.prototype.toString = /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    function () { return DEFAULT_SERIALIZER.serialize(this); };\n    return UrlTree;\n}());\n/**\n * \\@whatItDoes Represents the parsed URL segment group.\n *\n * See {\\@link UrlTree} for more information.\n *\n * \\@stable\n */\nvar UrlSegmentGroup = (function () {\n    function UrlSegmentGroup(segments, children) {\n        var _this = this;\n        this.segments = segments;\n        this.children = children;\n        /**\n         * The parent node in the url tree\n         */\n        this.parent = null;\n        forEach(children, function (v, k) { return v.parent = _this; });\n    }\n    /** Whether the segment has child segments */\n    /**\n     * Whether the segment has child segments\n     * @return {?}\n     */\n    UrlSegmentGroup.prototype.hasChildren = /**\n     * Whether the segment has child segments\n     * @return {?}\n     */\n    function () { return this.numberOfChildren > 0; };\n    Object.defineProperty(UrlSegmentGroup.prototype, \"numberOfChildren\", {\n        /** Number of child segments */\n        get: /**\n         * Number of child segments\n         * @return {?}\n         */\n        function () { return Object.keys(this.children).length; },\n        enumerable: true,\n        configurable: true\n    });\n    /** @docsNotRequired */\n    /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    UrlSegmentGroup.prototype.toString = /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    function () { return serializePaths(this); };\n    return UrlSegmentGroup;\n}());\n/**\n * \\@whatItDoes Represents a single URL segment.\n *\n * \\@howToUse\n *\n * ```\n * \\@Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const tree: UrlTree = router.parseUrl('/team;id=33');\n *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n *     const s: UrlSegment[] = g.segments;\n *     s[0].path; // returns 'team'\n *     s[0].parameters; // returns {id: 33}\n *   }\n * }\n * ```\n *\n * \\@description\n *\n * A UrlSegment is a part of a URL between the two slashes. It contains a path and the matrix\n * parameters associated with the segment.\n *\n * \\@stable\n */\nvar UrlSegment = (function () {\n    function UrlSegment(path, parameters) {\n        this.path = path;\n        this.parameters = parameters;\n    }\n    Object.defineProperty(UrlSegment.prototype, \"parameterMap\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            if (!this._parameterMap) {\n                this._parameterMap = convertToParamMap(this.parameters);\n            }\n            return this._parameterMap;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** @docsNotRequired */\n    /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    UrlSegment.prototype.toString = /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    function () { return serializePath(this); };\n    return UrlSegment;\n}());\n/**\n * @param {?} as\n * @param {?} bs\n * @return {?}\n */\nfunction equalSegments(as, bs) {\n    return equalPath(as, bs) && as.every(function (a, i) { return shallowEqual(a.parameters, bs[i].parameters); });\n}\n/**\n * @param {?} as\n * @param {?} bs\n * @return {?}\n */\nfunction equalPath(as, bs) {\n    if (as.length !== bs.length)\n        return false;\n    return as.every(function (a, i) { return a.path === bs[i].path; });\n}\n/**\n * @template T\n * @param {?} segment\n * @param {?} fn\n * @return {?}\n */\nfunction mapChildrenIntoArray(segment, fn) {\n    var /** @type {?} */ res = [];\n    forEach(segment.children, function (child, childOutlet) {\n        if (childOutlet === PRIMARY_OUTLET) {\n            res = res.concat(fn(child, childOutlet));\n        }\n    });\n    forEach(segment.children, function (child, childOutlet) {\n        if (childOutlet !== PRIMARY_OUTLET) {\n            res = res.concat(fn(child, childOutlet));\n        }\n    });\n    return res;\n}\n/**\n * \\@whatItDoes Serializes and deserializes a URL string into a URL tree.\n *\n * \\@description The url serialization strategy is customizable. You can\n * make all URLs case insensitive by providing a custom UrlSerializer.\n *\n * See {\\@link DefaultUrlSerializer} for an example of a URL serializer.\n *\n * \\@stable\n * @abstract\n */\nvar UrlSerializer = (function () {\n    function UrlSerializer() {\n    }\n    return UrlSerializer;\n}());\n/**\n * \\@whatItDoes A default implementation of the {\\@link UrlSerializer}.\n *\n * \\@description\n *\n * Example URLs:\n *\n * ```\n * /inbox/33(popup:compose)\n * /inbox/33;open=true/messages/44\n * ```\n *\n * DefaultUrlSerializer uses parentheses to serialize secondary segments (e.g., popup:compose), the\n * colon syntax to specify the outlet, and the ';parameter=value' syntax (e.g., open=true) to\n * specify route specific parameters.\n *\n * \\@stable\n */\nvar DefaultUrlSerializer = (function () {\n    function DefaultUrlSerializer() {\n    }\n    /** Parses a url into a {@link UrlTree} */\n    /**\n     * Parses a url into a {\\@link UrlTree}\n     * @param {?} url\n     * @return {?}\n     */\n    DefaultUrlSerializer.prototype.parse = /**\n     * Parses a url into a {\\@link UrlTree}\n     * @param {?} url\n     * @return {?}\n     */\n    function (url) {\n        var /** @type {?} */ p = new UrlParser(url);\n        return new UrlTree(p.parseRootSegment(), p.parseQueryParams(), p.parseFragment());\n    };\n    /** Converts a {@link UrlTree} into a url */\n    /**\n     * Converts a {\\@link UrlTree} into a url\n     * @param {?} tree\n     * @return {?}\n     */\n    DefaultUrlSerializer.prototype.serialize = /**\n     * Converts a {\\@link UrlTree} into a url\n     * @param {?} tree\n     * @return {?}\n     */\n    function (tree) {\n        var /** @type {?} */ segment = \"/\" + serializeSegment(tree.root, true);\n        var /** @type {?} */ query = serializeQueryParams(tree.queryParams);\n        var /** @type {?} */ fragment = typeof tree.fragment === \"string\" ? \"#\" + encodeURI((/** @type {?} */ ((tree.fragment)))) : '';\n        return \"\" + segment + query + fragment;\n    };\n    return DefaultUrlSerializer;\n}());\nvar DEFAULT_SERIALIZER = new DefaultUrlSerializer();\n/**\n * @param {?} segment\n * @return {?}\n */\nfunction serializePaths(segment) {\n    return segment.segments.map(function (p) { return serializePath(p); }).join('/');\n}\n/**\n * @param {?} segment\n * @param {?} root\n * @return {?}\n */\nfunction serializeSegment(segment, root) {\n    if (!segment.hasChildren()) {\n        return serializePaths(segment);\n    }\n    if (root) {\n        var /** @type {?} */ primary = segment.children[PRIMARY_OUTLET] ?\n            serializeSegment(segment.children[PRIMARY_OUTLET], false) :\n            '';\n        var /** @type {?} */ children_1 = [];\n        forEach(segment.children, function (v, k) {\n            if (k !== PRIMARY_OUTLET) {\n                children_1.push(k + \":\" + serializeSegment(v, false));\n            }\n        });\n        return children_1.length > 0 ? primary + \"(\" + children_1.join('//') + \")\" : primary;\n    }\n    else {\n        var /** @type {?} */ children = mapChildrenIntoArray(segment, function (v, k) {\n            if (k === PRIMARY_OUTLET) {\n                return [serializeSegment(segment.children[PRIMARY_OUTLET], false)];\n            }\n            return [k + \":\" + serializeSegment(v, false)];\n        });\n        return serializePaths(segment) + \"/(\" + children.join('//') + \")\";\n    }\n}\n/**\n * This method is intended for encoding *key* or *value* parts of query component. We need a custom\n * method because encodeURIComponent is too aggressive and encodes stuff that doesn't have to be\n * encoded per http://tools.ietf.org/html/rfc3986:\n *    query         = *( pchar / \"/\" / \"?\" )\n *    pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"\\@\"\n *    unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n *    pct-encoded   = \"%\" HEXDIG HEXDIG\n *    sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n *                     / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n * @param {?} s\n * @return {?}\n */\nfunction encode(s) {\n    return encodeURIComponent(s)\n        .replace(/%40/g, '@')\n        .replace(/%3A/gi, ':')\n        .replace(/%24/g, '$')\n        .replace(/%2C/gi, ',')\n        .replace(/%3B/gi, ';');\n}\n/**\n * @param {?} s\n * @return {?}\n */\nfunction decode(s) {\n    return decodeURIComponent(s);\n}\n/**\n * @param {?} path\n * @return {?}\n */\nfunction serializePath(path) {\n    return \"\" + encode(path.path) + serializeParams(path.parameters);\n}\n/**\n * @param {?} params\n * @return {?}\n */\nfunction serializeParams(params) {\n    return Object.keys(params).map(function (key) { return \";\" + encode(key) + \"=\" + encode(params[key]); }).join('');\n}\n/**\n * @param {?} params\n * @return {?}\n */\nfunction serializeQueryParams(params) {\n    var /** @type {?} */ strParams = Object.keys(params).map(function (name) {\n        var /** @type {?} */ value = params[name];\n        return Array.isArray(value) ? value.map(function (v) { return encode(name) + \"=\" + encode(v); }).join('&') :\n            encode(name) + \"=\" + encode(value);\n    });\n    return strParams.length ? \"?\" + strParams.join(\"&\") : '';\n}\nvar SEGMENT_RE = /^[^\\/()?;=&#]+/;\n/**\n * @param {?} str\n * @return {?}\n */\nfunction matchSegments(str) {\n    var /** @type {?} */ match = str.match(SEGMENT_RE);\n    return match ? match[0] : '';\n}\nvar QUERY_PARAM_RE = /^[^=?&#]+/;\n/**\n * @param {?} str\n * @return {?}\n */\nfunction matchQueryParams(str) {\n    var /** @type {?} */ match = str.match(QUERY_PARAM_RE);\n    return match ? match[0] : '';\n}\nvar QUERY_PARAM_VALUE_RE = /^[^?&#]+/;\n/**\n * @param {?} str\n * @return {?}\n */\nfunction matchUrlQueryParamValue(str) {\n    var /** @type {?} */ match = str.match(QUERY_PARAM_VALUE_RE);\n    return match ? match[0] : '';\n}\nvar UrlParser = (function () {\n    function UrlParser(url) {\n        this.url = url;\n        this.remaining = url;\n    }\n    /**\n     * @return {?}\n     */\n    UrlParser.prototype.parseRootSegment = /**\n     * @return {?}\n     */\n    function () {\n        this.consumeOptional('/');\n        if (this.remaining === '' || this.peekStartsWith('?') || this.peekStartsWith('#')) {\n            return new UrlSegmentGroup([], {});\n        }\n        // The root segment group never has segments\n        return new UrlSegmentGroup([], this.parseChildren());\n    };\n    /**\n     * @return {?}\n     */\n    UrlParser.prototype.parseQueryParams = /**\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ params = {};\n        if (this.consumeOptional('?')) {\n            do {\n                this.parseQueryParam(params);\n            } while (this.consumeOptional('&'));\n        }\n        return params;\n    };\n    /**\n     * @return {?}\n     */\n    UrlParser.prototype.parseFragment = /**\n     * @return {?}\n     */\n    function () {\n        return this.consumeOptional('#') ? decodeURI(this.remaining) : null;\n    };\n    /**\n     * @return {?}\n     */\n    UrlParser.prototype.parseChildren = /**\n     * @return {?}\n     */\n    function () {\n        if (this.remaining === '') {\n            return {};\n        }\n        this.consumeOptional('/');\n        var /** @type {?} */ segments = [];\n        if (!this.peekStartsWith('(')) {\n            segments.push(this.parseSegment());\n        }\n        while (this.peekStartsWith('/') && !this.peekStartsWith('//') && !this.peekStartsWith('/(')) {\n            this.capture('/');\n            segments.push(this.parseSegment());\n        }\n        var /** @type {?} */ children = {};\n        if (this.peekStartsWith('/(')) {\n            this.capture('/');\n            children = this.parseParens(true);\n        }\n        var /** @type {?} */ res = {};\n        if (this.peekStartsWith('(')) {\n            res = this.parseParens(false);\n        }\n        if (segments.length > 0 || Object.keys(children).length > 0) {\n            res[PRIMARY_OUTLET] = new UrlSegmentGroup(segments, children);\n        }\n        return res;\n    };\n    /**\n     * @return {?}\n     */\n    UrlParser.prototype.parseSegment = /**\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ path = matchSegments(this.remaining);\n        if (path === '' && this.peekStartsWith(';')) {\n            throw new Error(\"Empty path url segment cannot have parameters: '\" + this.remaining + \"'.\");\n        }\n        this.capture(path);\n        return new UrlSegment(decode(path), this.parseMatrixParams());\n    };\n    /**\n     * @return {?}\n     */\n    UrlParser.prototype.parseMatrixParams = /**\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ params = {};\n        while (this.consumeOptional(';')) {\n            this.parseParam(params);\n        }\n        return params;\n    };\n    /**\n     * @param {?} params\n     * @return {?}\n     */\n    UrlParser.prototype.parseParam = /**\n     * @param {?} params\n     * @return {?}\n     */\n    function (params) {\n        var /** @type {?} */ key = matchSegments(this.remaining);\n        if (!key) {\n            return;\n        }\n        this.capture(key);\n        var /** @type {?} */ value = '';\n        if (this.consumeOptional('=')) {\n            var /** @type {?} */ valueMatch = matchSegments(this.remaining);\n            if (valueMatch) {\n                value = valueMatch;\n                this.capture(value);\n            }\n        }\n        params[decode(key)] = decode(value);\n    };\n    /**\n     * @param {?} params\n     * @return {?}\n     */\n    UrlParser.prototype.parseQueryParam = /**\n     * @param {?} params\n     * @return {?}\n     */\n    function (params) {\n        var /** @type {?} */ key = matchQueryParams(this.remaining);\n        if (!key) {\n            return;\n        }\n        this.capture(key);\n        var /** @type {?} */ value = '';\n        if (this.consumeOptional('=')) {\n            var /** @type {?} */ valueMatch = matchUrlQueryParamValue(this.remaining);\n            if (valueMatch) {\n                value = valueMatch;\n                this.capture(value);\n            }\n        }\n        var /** @type {?} */ decodedKey = decode(key);\n        var /** @type {?} */ decodedVal = decode(value);\n        if (params.hasOwnProperty(decodedKey)) {\n            // Append to existing values\n            var /** @type {?} */ currentVal = params[decodedKey];\n            if (!Array.isArray(currentVal)) {\n                currentVal = [currentVal];\n                params[decodedKey] = currentVal;\n            }\n            currentVal.push(decodedVal);\n        }\n        else {\n            // Create a new value\n            params[decodedKey] = decodedVal;\n        }\n    };\n    /**\n     * @param {?} allowPrimary\n     * @return {?}\n     */\n    UrlParser.prototype.parseParens = /**\n     * @param {?} allowPrimary\n     * @return {?}\n     */\n    function (allowPrimary) {\n        var /** @type {?} */ segments = {};\n        this.capture('(');\n        while (!this.consumeOptional(')') && this.remaining.length > 0) {\n            var /** @type {?} */ path = matchSegments(this.remaining);\n            var /** @type {?} */ next = this.remaining[path.length];\n            // if is is not one of these characters, then the segment was unescaped\n            // or the group was not closed\n            if (next !== '/' && next !== ')' && next !== ';') {\n                throw new Error(\"Cannot parse url '\" + this.url + \"'\");\n            }\n            var /** @type {?} */ outletName = /** @type {?} */ ((undefined));\n            if (path.indexOf(':') > -1) {\n                outletName = path.substr(0, path.indexOf(':'));\n                this.capture(outletName);\n                this.capture(':');\n            }\n            else if (allowPrimary) {\n                outletName = PRIMARY_OUTLET;\n            }\n            var /** @type {?} */ children = this.parseChildren();\n            segments[outletName] = Object.keys(children).length === 1 ? children[PRIMARY_OUTLET] :\n                new UrlSegmentGroup([], children);\n            this.consumeOptional('//');\n        }\n        return segments;\n    };\n    /**\n     * @param {?} str\n     * @return {?}\n     */\n    UrlParser.prototype.peekStartsWith = /**\n     * @param {?} str\n     * @return {?}\n     */\n    function (str) { return this.remaining.startsWith(str); };\n    /**\n     * @param {?} str\n     * @return {?}\n     */\n    UrlParser.prototype.consumeOptional = /**\n     * @param {?} str\n     * @return {?}\n     */\n    function (str) {\n        if (this.peekStartsWith(str)) {\n            this.remaining = this.remaining.substring(str.length);\n            return true;\n        }\n        return false;\n    };\n    /**\n     * @param {?} str\n     * @return {?}\n     */\n    UrlParser.prototype.capture = /**\n     * @param {?} str\n     * @return {?}\n     */\n    function (str) {\n        if (!this.consumeOptional(str)) {\n            throw new Error(\"Expected \\\"\" + str + \"\\\".\");\n        }\n    };\n    return UrlParser;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar NoMatch = (function () {\n    function NoMatch(segmentGroup) {\n        this.segmentGroup = segmentGroup || null;\n    }\n    return NoMatch;\n}());\nvar AbsoluteRedirect = (function () {\n    function AbsoluteRedirect(urlTree) {\n        this.urlTree = urlTree;\n    }\n    return AbsoluteRedirect;\n}());\n/**\n * @param {?} segmentGroup\n * @return {?}\n */\nfunction noMatch(segmentGroup) {\n    return new __WEBPACK_IMPORTED_MODULE_9_rxjs_Observable__[\"Observable\"](function (obs) { return obs.error(new NoMatch(segmentGroup)); });\n}\n/**\n * @param {?} newTree\n * @return {?}\n */\nfunction absoluteRedirect(newTree) {\n    return new __WEBPACK_IMPORTED_MODULE_9_rxjs_Observable__[\"Observable\"](function (obs) { return obs.error(new AbsoluteRedirect(newTree)); });\n}\n/**\n * @param {?} redirectTo\n * @return {?}\n */\nfunction namedOutletsRedirect(redirectTo) {\n    return new __WEBPACK_IMPORTED_MODULE_9_rxjs_Observable__[\"Observable\"](function (obs) {\n        return obs.error(new Error(\"Only absolute redirects can have named outlets. redirectTo: '\" + redirectTo + \"'\"));\n    });\n}\n/**\n * @param {?} route\n * @return {?}\n */\nfunction canLoadFails(route) {\n    return new __WEBPACK_IMPORTED_MODULE_9_rxjs_Observable__[\"Observable\"](function (obs) {\n        return obs.error(navigationCancelingError(\"Cannot load children because the guard of the route \\\"path: '\" + route.path + \"'\\\" returned false\"));\n    });\n}\n/**\n * Returns the `UrlTree` with the redirection applied.\n *\n * Lazy modules are loaded along the way.\n * @param {?} moduleInjector\n * @param {?} configLoader\n * @param {?} urlSerializer\n * @param {?} urlTree\n * @param {?} config\n * @return {?}\n */\nfunction applyRedirects(moduleInjector, configLoader, urlSerializer, urlTree, config) {\n    return new ApplyRedirects(moduleInjector, configLoader, urlSerializer, urlTree, config).apply();\n}\nvar ApplyRedirects = (function () {\n    function ApplyRedirects(moduleInjector, configLoader, urlSerializer, urlTree, config) {\n        this.configLoader = configLoader;\n        this.urlSerializer = urlSerializer;\n        this.urlTree = urlTree;\n        this.config = config;\n        this.allowRedirects = true;\n        this.ngModule = moduleInjector.get(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModuleRef\"]);\n    }\n    /**\n     * @return {?}\n     */\n    ApplyRedirects.prototype.apply = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        var /** @type {?} */ expanded$ = this.expandSegmentGroup(this.ngModule, this.config, this.urlTree.root, PRIMARY_OUTLET);\n        var /** @type {?} */ urlTrees$ = __WEBPACK_IMPORTED_MODULE_7_rxjs_operator_map__[\"map\"].call(expanded$, function (rootSegmentGroup) {\n            return _this.createUrlTree(rootSegmentGroup, _this.urlTree.queryParams, /** @type {?} */ ((_this.urlTree.fragment)));\n        });\n        return __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_catch__[\"_catch\"].call(urlTrees$, function (e) {\n            if (e instanceof AbsoluteRedirect) {\n                // after an absolute redirect we do not apply any more redirects!\n                // after an absolute redirect we do not apply any more redirects!\n                _this.allowRedirects = false;\n                // we need to run matching, so we can fetch all lazy-loaded modules\n                return _this.match(e.urlTree);\n            }\n            if (e instanceof NoMatch) {\n                throw _this.noMatchError(e);\n            }\n            throw e;\n        });\n    };\n    /**\n     * @param {?} tree\n     * @return {?}\n     */\n    ApplyRedirects.prototype.match = /**\n     * @param {?} tree\n     * @return {?}\n     */\n    function (tree) {\n        var _this = this;\n        var /** @type {?} */ expanded$ = this.expandSegmentGroup(this.ngModule, this.config, tree.root, PRIMARY_OUTLET);\n        var /** @type {?} */ mapped$ = __WEBPACK_IMPORTED_MODULE_7_rxjs_operator_map__[\"map\"].call(expanded$, function (rootSegmentGroup) {\n            return _this.createUrlTree(rootSegmentGroup, tree.queryParams, /** @type {?} */ ((tree.fragment)));\n        });\n        return __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_catch__[\"_catch\"].call(mapped$, function (e) {\n            if (e instanceof NoMatch) {\n                throw _this.noMatchError(e);\n            }\n            throw e;\n        });\n    };\n    /**\n     * @param {?} e\n     * @return {?}\n     */\n    ApplyRedirects.prototype.noMatchError = /**\n     * @param {?} e\n     * @return {?}\n     */\n    function (e) {\n        return new Error(\"Cannot match any routes. URL Segment: '\" + e.segmentGroup + \"'\");\n    };\n    /**\n     * @param {?} rootCandidate\n     * @param {?} queryParams\n     * @param {?} fragment\n     * @return {?}\n     */\n    ApplyRedirects.prototype.createUrlTree = /**\n     * @param {?} rootCandidate\n     * @param {?} queryParams\n     * @param {?} fragment\n     * @return {?}\n     */\n    function (rootCandidate, queryParams, fragment) {\n        var /** @type {?} */ root = rootCandidate.segments.length > 0 ?\n            new UrlSegmentGroup([], (_a = {}, _a[PRIMARY_OUTLET] = rootCandidate, _a)) :\n            rootCandidate;\n        return new UrlTree(root, queryParams, fragment);\n        var _a;\n    };\n    /**\n     * @param {?} ngModule\n     * @param {?} routes\n     * @param {?} segmentGroup\n     * @param {?} outlet\n     * @return {?}\n     */\n    ApplyRedirects.prototype.expandSegmentGroup = /**\n     * @param {?} ngModule\n     * @param {?} routes\n     * @param {?} segmentGroup\n     * @param {?} outlet\n     * @return {?}\n     */\n    function (ngModule, routes, segmentGroup, outlet) {\n        if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n            return __WEBPACK_IMPORTED_MODULE_7_rxjs_operator_map__[\"map\"].call(this.expandChildren(ngModule, routes, segmentGroup), function (children) { return new UrlSegmentGroup([], children); });\n        }\n        return this.expandSegment(ngModule, segmentGroup, routes, segmentGroup.segments, outlet, true);\n    };\n    /**\n     * @param {?} ngModule\n     * @param {?} routes\n     * @param {?} segmentGroup\n     * @return {?}\n     */\n    ApplyRedirects.prototype.expandChildren = /**\n     * @param {?} ngModule\n     * @param {?} routes\n     * @param {?} segmentGroup\n     * @return {?}\n     */\n    function (ngModule, routes, segmentGroup) {\n        var _this = this;\n        return waitForMap(segmentGroup.children, function (childOutlet, child) { return _this.expandSegmentGroup(ngModule, routes, child, childOutlet); });\n    };\n    /**\n     * @param {?} ngModule\n     * @param {?} segmentGroup\n     * @param {?} routes\n     * @param {?} segments\n     * @param {?} outlet\n     * @param {?} allowRedirects\n     * @return {?}\n     */\n    ApplyRedirects.prototype.expandSegment = /**\n     * @param {?} ngModule\n     * @param {?} segmentGroup\n     * @param {?} routes\n     * @param {?} segments\n     * @param {?} outlet\n     * @param {?} allowRedirects\n     * @return {?}\n     */\n    function (ngModule, segmentGroup, routes, segments, outlet, allowRedirects) {\n        var _this = this;\n        var /** @type {?} */ routes$ = __WEBPACK_IMPORTED_MODULE_5_rxjs_observable_of__[\"of\"].apply(void 0, routes);\n        var /** @type {?} */ processedRoutes$ = __WEBPACK_IMPORTED_MODULE_7_rxjs_operator_map__[\"map\"].call(routes$, function (r) {\n            var /** @type {?} */ expanded$ = _this.expandSegmentAgainstRoute(ngModule, segmentGroup, routes, r, segments, outlet, allowRedirects);\n            return __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_catch__[\"_catch\"].call(expanded$, function (e) {\n                if (e instanceof NoMatch) {\n                    return Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_of__[\"of\"])(null);\n                }\n                throw e;\n            });\n        });\n        var /** @type {?} */ concattedProcessedRoutes$ = __WEBPACK_IMPORTED_MODULE_12_rxjs_operator_concatAll__[\"concatAll\"].call(processedRoutes$);\n        var /** @type {?} */ first$ = __WEBPACK_IMPORTED_MODULE_13_rxjs_operator_first__[\"first\"].call(concattedProcessedRoutes$, function (s) { return !!s; });\n        return __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_catch__[\"_catch\"].call(first$, function (e, _) {\n            if (e instanceof __WEBPACK_IMPORTED_MODULE_14_rxjs_util_EmptyError__[\"EmptyError\"]) {\n                if (_this.noLeftoversInUrl(segmentGroup, segments, outlet)) {\n                    return Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_of__[\"of\"])(new UrlSegmentGroup([], {}));\n                }\n                throw new NoMatch(segmentGroup);\n            }\n            throw e;\n        });\n    };\n    /**\n     * @param {?} segmentGroup\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n    ApplyRedirects.prototype.noLeftoversInUrl = /**\n     * @param {?} segmentGroup\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n    function (segmentGroup, segments, outlet) {\n        return segments.length === 0 && !segmentGroup.children[outlet];\n    };\n    /**\n     * @param {?} ngModule\n     * @param {?} segmentGroup\n     * @param {?} routes\n     * @param {?} route\n     * @param {?} paths\n     * @param {?} outlet\n     * @param {?} allowRedirects\n     * @return {?}\n     */\n    ApplyRedirects.prototype.expandSegmentAgainstRoute = /**\n     * @param {?} ngModule\n     * @param {?} segmentGroup\n     * @param {?} routes\n     * @param {?} route\n     * @param {?} paths\n     * @param {?} outlet\n     * @param {?} allowRedirects\n     * @return {?}\n     */\n    function (ngModule, segmentGroup, routes, route, paths, outlet, allowRedirects) {\n        if (getOutlet(route) !== outlet) {\n            return noMatch(segmentGroup);\n        }\n        if (route.redirectTo === undefined) {\n            return this.matchSegmentAgainstRoute(ngModule, segmentGroup, route, paths);\n        }\n        if (allowRedirects && this.allowRedirects) {\n            return this.expandSegmentAgainstRouteUsingRedirect(ngModule, segmentGroup, routes, route, paths, outlet);\n        }\n        return noMatch(segmentGroup);\n    };\n    /**\n     * @param {?} ngModule\n     * @param {?} segmentGroup\n     * @param {?} routes\n     * @param {?} route\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n    ApplyRedirects.prototype.expandSegmentAgainstRouteUsingRedirect = /**\n     * @param {?} ngModule\n     * @param {?} segmentGroup\n     * @param {?} routes\n     * @param {?} route\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n    function (ngModule, segmentGroup, routes, route, segments, outlet) {\n        if (route.path === '**') {\n            return this.expandWildCardWithParamsAgainstRouteUsingRedirect(ngModule, routes, route, outlet);\n        }\n        return this.expandRegularSegmentAgainstRouteUsingRedirect(ngModule, segmentGroup, routes, route, segments, outlet);\n    };\n    /**\n     * @param {?} ngModule\n     * @param {?} routes\n     * @param {?} route\n     * @param {?} outlet\n     * @return {?}\n     */\n    ApplyRedirects.prototype.expandWildCardWithParamsAgainstRouteUsingRedirect = /**\n     * @param {?} ngModule\n     * @param {?} routes\n     * @param {?} route\n     * @param {?} outlet\n     * @return {?}\n     */\n    function (ngModule, routes, route, outlet) {\n        var _this = this;\n        var /** @type {?} */ newTree = this.applyRedirectCommands([], /** @type {?} */ ((route.redirectTo)), {});\n        if (/** @type {?} */ ((route.redirectTo)).startsWith('/')) {\n            return absoluteRedirect(newTree);\n        }\n        return __WEBPACK_IMPORTED_MODULE_8_rxjs_operator_mergeMap__[\"mergeMap\"].call(this.lineralizeSegments(route, newTree), function (newSegments) {\n            var /** @type {?} */ group = new UrlSegmentGroup(newSegments, {});\n            return _this.expandSegment(ngModule, group, routes, newSegments, outlet, false);\n        });\n    };\n    /**\n     * @param {?} ngModule\n     * @param {?} segmentGroup\n     * @param {?} routes\n     * @param {?} route\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n    ApplyRedirects.prototype.expandRegularSegmentAgainstRouteUsingRedirect = /**\n     * @param {?} ngModule\n     * @param {?} segmentGroup\n     * @param {?} routes\n     * @param {?} route\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n    function (ngModule, segmentGroup, routes, route, segments, outlet) {\n        var _this = this;\n        var _a = match(segmentGroup, route, segments), matched = _a.matched, consumedSegments = _a.consumedSegments, lastChild = _a.lastChild, positionalParamSegments = _a.positionalParamSegments;\n        if (!matched)\n            return noMatch(segmentGroup);\n        var /** @type {?} */ newTree = this.applyRedirectCommands(consumedSegments, /** @type {?} */ ((route.redirectTo)), /** @type {?} */ (positionalParamSegments));\n        if (/** @type {?} */ ((route.redirectTo)).startsWith('/')) {\n            return absoluteRedirect(newTree);\n        }\n        return __WEBPACK_IMPORTED_MODULE_8_rxjs_operator_mergeMap__[\"mergeMap\"].call(this.lineralizeSegments(route, newTree), function (newSegments) {\n            return _this.expandSegment(ngModule, segmentGroup, routes, newSegments.concat(segments.slice(lastChild)), outlet, false);\n        });\n    };\n    /**\n     * @param {?} ngModule\n     * @param {?} rawSegmentGroup\n     * @param {?} route\n     * @param {?} segments\n     * @return {?}\n     */\n    ApplyRedirects.prototype.matchSegmentAgainstRoute = /**\n     * @param {?} ngModule\n     * @param {?} rawSegmentGroup\n     * @param {?} route\n     * @param {?} segments\n     * @return {?}\n     */\n    function (ngModule, rawSegmentGroup, route, segments) {\n        var _this = this;\n        if (route.path === '**') {\n            if (route.loadChildren) {\n                return __WEBPACK_IMPORTED_MODULE_7_rxjs_operator_map__[\"map\"].call(this.configLoader.load(ngModule.injector, route), function (cfg) {\n                    route._loadedConfig = cfg;\n                    return new UrlSegmentGroup(segments, {});\n                });\n            }\n            return Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_of__[\"of\"])(new UrlSegmentGroup(segments, {}));\n        }\n        var _a = match(rawSegmentGroup, route, segments), matched = _a.matched, consumedSegments = _a.consumedSegments, lastChild = _a.lastChild;\n        if (!matched)\n            return noMatch(rawSegmentGroup);\n        var /** @type {?} */ rawSlicedSegments = segments.slice(lastChild);\n        var /** @type {?} */ childConfig$ = this.getChildConfig(ngModule, route);\n        return __WEBPACK_IMPORTED_MODULE_8_rxjs_operator_mergeMap__[\"mergeMap\"].call(childConfig$, function (routerConfig) {\n            var /** @type {?} */ childModule = routerConfig.module;\n            var /** @type {?} */ childConfig = routerConfig.routes;\n            var _a = split(rawSegmentGroup, consumedSegments, rawSlicedSegments, childConfig), segmentGroup = _a.segmentGroup, slicedSegments = _a.slicedSegments;\n            if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {\n                var /** @type {?} */ expanded$_1 = _this.expandChildren(childModule, childConfig, segmentGroup);\n                return __WEBPACK_IMPORTED_MODULE_7_rxjs_operator_map__[\"map\"].call(expanded$_1, function (children) { return new UrlSegmentGroup(consumedSegments, children); });\n            }\n            if (childConfig.length === 0 && slicedSegments.length === 0) {\n                return Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_of__[\"of\"])(new UrlSegmentGroup(consumedSegments, {}));\n            }\n            var /** @type {?} */ expanded$ = _this.expandSegment(childModule, segmentGroup, childConfig, slicedSegments, PRIMARY_OUTLET, true);\n            return __WEBPACK_IMPORTED_MODULE_7_rxjs_operator_map__[\"map\"].call(expanded$, function (cs) {\n                return new UrlSegmentGroup(consumedSegments.concat(cs.segments), cs.children);\n            });\n        });\n    };\n    /**\n     * @param {?} ngModule\n     * @param {?} route\n     * @return {?}\n     */\n    ApplyRedirects.prototype.getChildConfig = /**\n     * @param {?} ngModule\n     * @param {?} route\n     * @return {?}\n     */\n    function (ngModule, route) {\n        var _this = this;\n        if (route.children) {\n            // The children belong to the same module\n            return Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_of__[\"of\"])(new LoadedRouterConfig(route.children, ngModule));\n        }\n        if (route.loadChildren) {\n            // lazy children belong to the loaded module\n            if (route._loadedConfig !== undefined) {\n                return Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_of__[\"of\"])(route._loadedConfig);\n            }\n            return __WEBPACK_IMPORTED_MODULE_8_rxjs_operator_mergeMap__[\"mergeMap\"].call(runCanLoadGuard(ngModule.injector, route), function (shouldLoad) {\n                if (shouldLoad) {\n                    return __WEBPACK_IMPORTED_MODULE_7_rxjs_operator_map__[\"map\"].call(_this.configLoader.load(ngModule.injector, route), function (cfg) {\n                        route._loadedConfig = cfg;\n                        return cfg;\n                    });\n                }\n                return canLoadFails(route);\n            });\n        }\n        return Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_of__[\"of\"])(new LoadedRouterConfig([], ngModule));\n    };\n    /**\n     * @param {?} route\n     * @param {?} urlTree\n     * @return {?}\n     */\n    ApplyRedirects.prototype.lineralizeSegments = /**\n     * @param {?} route\n     * @param {?} urlTree\n     * @return {?}\n     */\n    function (route, urlTree) {\n        var /** @type {?} */ res = [];\n        var /** @type {?} */ c = urlTree.root;\n        while (true) {\n            res = res.concat(c.segments);\n            if (c.numberOfChildren === 0) {\n                return Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_of__[\"of\"])(res);\n            }\n            if (c.numberOfChildren > 1 || !c.children[PRIMARY_OUTLET]) {\n                return namedOutletsRedirect(/** @type {?} */ ((route.redirectTo)));\n            }\n            c = c.children[PRIMARY_OUTLET];\n        }\n    };\n    /**\n     * @param {?} segments\n     * @param {?} redirectTo\n     * @param {?} posParams\n     * @return {?}\n     */\n    ApplyRedirects.prototype.applyRedirectCommands = /**\n     * @param {?} segments\n     * @param {?} redirectTo\n     * @param {?} posParams\n     * @return {?}\n     */\n    function (segments, redirectTo, posParams) {\n        return this.applyRedirectCreatreUrlTree(redirectTo, this.urlSerializer.parse(redirectTo), segments, posParams);\n    };\n    /**\n     * @param {?} redirectTo\n     * @param {?} urlTree\n     * @param {?} segments\n     * @param {?} posParams\n     * @return {?}\n     */\n    ApplyRedirects.prototype.applyRedirectCreatreUrlTree = /**\n     * @param {?} redirectTo\n     * @param {?} urlTree\n     * @param {?} segments\n     * @param {?} posParams\n     * @return {?}\n     */\n    function (redirectTo, urlTree, segments, posParams) {\n        var /** @type {?} */ newRoot = this.createSegmentGroup(redirectTo, urlTree.root, segments, posParams);\n        return new UrlTree(newRoot, this.createQueryParams(urlTree.queryParams, this.urlTree.queryParams), urlTree.fragment);\n    };\n    /**\n     * @param {?} redirectToParams\n     * @param {?} actualParams\n     * @return {?}\n     */\n    ApplyRedirects.prototype.createQueryParams = /**\n     * @param {?} redirectToParams\n     * @param {?} actualParams\n     * @return {?}\n     */\n    function (redirectToParams, actualParams) {\n        var /** @type {?} */ res = {};\n        forEach(redirectToParams, function (v, k) {\n            var /** @type {?} */ copySourceValue = typeof v === 'string' && v.startsWith(':');\n            if (copySourceValue) {\n                var /** @type {?} */ sourceName = v.substring(1);\n                res[k] = actualParams[sourceName];\n            }\n            else {\n                res[k] = v;\n            }\n        });\n        return res;\n    };\n    /**\n     * @param {?} redirectTo\n     * @param {?} group\n     * @param {?} segments\n     * @param {?} posParams\n     * @return {?}\n     */\n    ApplyRedirects.prototype.createSegmentGroup = /**\n     * @param {?} redirectTo\n     * @param {?} group\n     * @param {?} segments\n     * @param {?} posParams\n     * @return {?}\n     */\n    function (redirectTo, group, segments, posParams) {\n        var _this = this;\n        var /** @type {?} */ updatedSegments = this.createSegments(redirectTo, group.segments, segments, posParams);\n        var /** @type {?} */ children = {};\n        forEach(group.children, function (child, name) {\n            children[name] = _this.createSegmentGroup(redirectTo, child, segments, posParams);\n        });\n        return new UrlSegmentGroup(updatedSegments, children);\n    };\n    /**\n     * @param {?} redirectTo\n     * @param {?} redirectToSegments\n     * @param {?} actualSegments\n     * @param {?} posParams\n     * @return {?}\n     */\n    ApplyRedirects.prototype.createSegments = /**\n     * @param {?} redirectTo\n     * @param {?} redirectToSegments\n     * @param {?} actualSegments\n     * @param {?} posParams\n     * @return {?}\n     */\n    function (redirectTo, redirectToSegments, actualSegments, posParams) {\n        var _this = this;\n        return redirectToSegments.map(function (s) {\n            return s.path.startsWith(':') ? _this.findPosParam(redirectTo, s, posParams) :\n                _this.findOrReturn(s, actualSegments);\n        });\n    };\n    /**\n     * @param {?} redirectTo\n     * @param {?} redirectToUrlSegment\n     * @param {?} posParams\n     * @return {?}\n     */\n    ApplyRedirects.prototype.findPosParam = /**\n     * @param {?} redirectTo\n     * @param {?} redirectToUrlSegment\n     * @param {?} posParams\n     * @return {?}\n     */\n    function (redirectTo, redirectToUrlSegment, posParams) {\n        var /** @type {?} */ pos = posParams[redirectToUrlSegment.path.substring(1)];\n        if (!pos)\n            throw new Error(\"Cannot redirect to '\" + redirectTo + \"'. Cannot find '\" + redirectToUrlSegment.path + \"'.\");\n        return pos;\n    };\n    /**\n     * @param {?} redirectToUrlSegment\n     * @param {?} actualSegments\n     * @return {?}\n     */\n    ApplyRedirects.prototype.findOrReturn = /**\n     * @param {?} redirectToUrlSegment\n     * @param {?} actualSegments\n     * @return {?}\n     */\n    function (redirectToUrlSegment, actualSegments) {\n        var /** @type {?} */ idx = 0;\n        for (var _i = 0, actualSegments_1 = actualSegments; _i < actualSegments_1.length; _i++) {\n            var s = actualSegments_1[_i];\n            if (s.path === redirectToUrlSegment.path) {\n                actualSegments.splice(idx);\n                return s;\n            }\n            idx++;\n        }\n        return redirectToUrlSegment;\n    };\n    return ApplyRedirects;\n}());\n/**\n * @param {?} moduleInjector\n * @param {?} route\n * @return {?}\n */\nfunction runCanLoadGuard(moduleInjector, route) {\n    var /** @type {?} */ canLoad = route.canLoad;\n    if (!canLoad || canLoad.length === 0)\n        return Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_of__[\"of\"])(true);\n    var /** @type {?} */ obs = __WEBPACK_IMPORTED_MODULE_7_rxjs_operator_map__[\"map\"].call(Object(__WEBPACK_IMPORTED_MODULE_10_rxjs_observable_from__[\"from\"])(canLoad), function (injectionToken) {\n        var /** @type {?} */ guard = moduleInjector.get(injectionToken);\n        return wrapIntoObservable(guard.canLoad ? guard.canLoad(route) : guard(route));\n    });\n    return andObservables(obs);\n}\n/**\n * @param {?} segmentGroup\n * @param {?} route\n * @param {?} segments\n * @return {?}\n */\nfunction match(segmentGroup, route, segments) {\n    if (route.path === '') {\n        if ((route.pathMatch === 'full') && (segmentGroup.hasChildren() || segments.length > 0)) {\n            return { matched: false, consumedSegments: [], lastChild: 0, positionalParamSegments: {} };\n        }\n        return { matched: true, consumedSegments: [], lastChild: 0, positionalParamSegments: {} };\n    }\n    var /** @type {?} */ matcher = route.matcher || defaultUrlMatcher;\n    var /** @type {?} */ res = matcher(segments, segmentGroup, route);\n    if (!res) {\n        return {\n            matched: false,\n            consumedSegments: /** @type {?} */ ([]),\n            lastChild: 0,\n            positionalParamSegments: {},\n        };\n    }\n    return {\n        matched: true,\n        consumedSegments: /** @type {?} */ ((res.consumed)),\n        lastChild: /** @type {?} */ ((res.consumed.length)),\n        positionalParamSegments: /** @type {?} */ ((res.posParams)),\n    };\n}\n/**\n * @param {?} segmentGroup\n * @param {?} consumedSegments\n * @param {?} slicedSegments\n * @param {?} config\n * @return {?}\n */\nfunction split(segmentGroup, consumedSegments, slicedSegments, config) {\n    if (slicedSegments.length > 0 &&\n        containsEmptyPathRedirectsWithNamedOutlets(segmentGroup, slicedSegments, config)) {\n        var /** @type {?} */ s = new UrlSegmentGroup(consumedSegments, createChildrenForEmptySegments(config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));\n        return { segmentGroup: mergeTrivialChildren(s), slicedSegments: [] };\n    }\n    if (slicedSegments.length === 0 &&\n        containsEmptyPathRedirects(segmentGroup, slicedSegments, config)) {\n        var /** @type {?} */ s = new UrlSegmentGroup(segmentGroup.segments, addEmptySegmentsToChildrenIfNeeded(segmentGroup, slicedSegments, config, segmentGroup.children));\n        return { segmentGroup: mergeTrivialChildren(s), slicedSegments: slicedSegments };\n    }\n    return { segmentGroup: segmentGroup, slicedSegments: slicedSegments };\n}\n/**\n * @param {?} s\n * @return {?}\n */\nfunction mergeTrivialChildren(s) {\n    if (s.numberOfChildren === 1 && s.children[PRIMARY_OUTLET]) {\n        var /** @type {?} */ c = s.children[PRIMARY_OUTLET];\n        return new UrlSegmentGroup(s.segments.concat(c.segments), c.children);\n    }\n    return s;\n}\n/**\n * @param {?} segmentGroup\n * @param {?} slicedSegments\n * @param {?} routes\n * @param {?} children\n * @return {?}\n */\nfunction addEmptySegmentsToChildrenIfNeeded(segmentGroup, slicedSegments, routes, children) {\n    var /** @type {?} */ res = {};\n    for (var _i = 0, routes_1 = routes; _i < routes_1.length; _i++) {\n        var r = routes_1[_i];\n        if (isEmptyPathRedirect(segmentGroup, slicedSegments, r) && !children[getOutlet(r)]) {\n            res[getOutlet(r)] = new UrlSegmentGroup([], {});\n        }\n    }\n    return Object(__WEBPACK_IMPORTED_MODULE_2_tslib__[\"a\" /* __assign */])({}, children, res);\n}\n/**\n * @param {?} routes\n * @param {?} primarySegmentGroup\n * @return {?}\n */\nfunction createChildrenForEmptySegments(routes, primarySegmentGroup) {\n    var /** @type {?} */ res = {};\n    res[PRIMARY_OUTLET] = primarySegmentGroup;\n    for (var _i = 0, routes_2 = routes; _i < routes_2.length; _i++) {\n        var r = routes_2[_i];\n        if (r.path === '' && getOutlet(r) !== PRIMARY_OUTLET) {\n            res[getOutlet(r)] = new UrlSegmentGroup([], {});\n        }\n    }\n    return res;\n}\n/**\n * @param {?} segmentGroup\n * @param {?} segments\n * @param {?} routes\n * @return {?}\n */\nfunction containsEmptyPathRedirectsWithNamedOutlets(segmentGroup, segments, routes) {\n    return routes.some(function (r) { return isEmptyPathRedirect(segmentGroup, segments, r) && getOutlet(r) !== PRIMARY_OUTLET; });\n}\n/**\n * @param {?} segmentGroup\n * @param {?} segments\n * @param {?} routes\n * @return {?}\n */\nfunction containsEmptyPathRedirects(segmentGroup, segments, routes) {\n    return routes.some(function (r) { return isEmptyPathRedirect(segmentGroup, segments, r); });\n}\n/**\n * @param {?} segmentGroup\n * @param {?} segments\n * @param {?} r\n * @return {?}\n */\nfunction isEmptyPathRedirect(segmentGroup, segments, r) {\n    if ((segmentGroup.hasChildren() || segments.length > 0) && r.pathMatch === 'full') {\n        return false;\n    }\n    return r.path === '' && r.redirectTo !== undefined;\n}\n/**\n * @param {?} route\n * @return {?}\n */\nfunction getOutlet(route) {\n    return route.outlet || PRIMARY_OUTLET;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar Tree = (function () {\n    function Tree(root) {\n        this._root = root;\n    }\n    Object.defineProperty(Tree.prototype, \"root\", {\n        get: /**\n         * @return {?}\n         */\n        function () { return this._root.value; },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @internal\n     */\n    /**\n     * \\@internal\n     * @param {?} t\n     * @return {?}\n     */\n    Tree.prototype.parent = /**\n     * \\@internal\n     * @param {?} t\n     * @return {?}\n     */\n    function (t) {\n        var /** @type {?} */ p = this.pathFromRoot(t);\n        return p.length > 1 ? p[p.length - 2] : null;\n    };\n    /**\n     * @internal\n     */\n    /**\n     * \\@internal\n     * @param {?} t\n     * @return {?}\n     */\n    Tree.prototype.children = /**\n     * \\@internal\n     * @param {?} t\n     * @return {?}\n     */\n    function (t) {\n        var /** @type {?} */ n = findNode(t, this._root);\n        return n ? n.children.map(function (t) { return t.value; }) : [];\n    };\n    /**\n     * @internal\n     */\n    /**\n     * \\@internal\n     * @param {?} t\n     * @return {?}\n     */\n    Tree.prototype.firstChild = /**\n     * \\@internal\n     * @param {?} t\n     * @return {?}\n     */\n    function (t) {\n        var /** @type {?} */ n = findNode(t, this._root);\n        return n && n.children.length > 0 ? n.children[0].value : null;\n    };\n    /**\n     * @internal\n     */\n    /**\n     * \\@internal\n     * @param {?} t\n     * @return {?}\n     */\n    Tree.prototype.siblings = /**\n     * \\@internal\n     * @param {?} t\n     * @return {?}\n     */\n    function (t) {\n        var /** @type {?} */ p = findPath(t, this._root);\n        if (p.length < 2)\n            return [];\n        var /** @type {?} */ c = p[p.length - 2].children.map(function (c) { return c.value; });\n        return c.filter(function (cc) { return cc !== t; });\n    };\n    /**\n     * @internal\n     */\n    /**\n     * \\@internal\n     * @param {?} t\n     * @return {?}\n     */\n    Tree.prototype.pathFromRoot = /**\n     * \\@internal\n     * @param {?} t\n     * @return {?}\n     */\n    function (t) { return findPath(t, this._root).map(function (s) { return s.value; }); };\n    return Tree;\n}());\n/**\n * @template T\n * @param {?} value\n * @param {?} node\n * @return {?}\n */\nfunction findNode(value, node) {\n    if (value === node.value)\n        return node;\n    for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n        var child = _a[_i];\n        var /** @type {?} */ node_1 = findNode(value, child);\n        if (node_1)\n            return node_1;\n    }\n    return null;\n}\n/**\n * @template T\n * @param {?} value\n * @param {?} node\n * @return {?}\n */\nfunction findPath(value, node) {\n    if (value === node.value)\n        return [node];\n    for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n        var child = _a[_i];\n        var /** @type {?} */ path = findPath(value, child);\n        if (path.length) {\n            path.unshift(node);\n            return path;\n        }\n    }\n    return [];\n}\nvar TreeNode = (function () {\n    function TreeNode(value, children) {\n        this.value = value;\n        this.children = children;\n    }\n    /**\n     * @return {?}\n     */\n    TreeNode.prototype.toString = /**\n     * @return {?}\n     */\n    function () { return \"TreeNode(\" + this.value + \")\"; };\n    return TreeNode;\n}());\n/**\n * @template T\n * @param {?} node\n * @return {?}\n */\nfunction nodeChildrenAsMap(node) {\n    var /** @type {?} */ map$$1 = {};\n    if (node) {\n        node.children.forEach(function (child) { return map$$1[child.value.outlet] = child; });\n    }\n    return map$$1;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * \\@whatItDoes Represents the state of the router.\n *\n * \\@howToUse\n *\n * ```\n * \\@Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const state: RouterState = router.routerState;\n *     const root: ActivatedRoute = state.root;\n *     const child = root.firstChild;\n *     const id: Observable<string> = child.params.map(p => p.id);\n *     //...\n *   }\n * }\n * ```\n *\n * \\@description\n * RouterState is a tree of activated routes. Every node in this tree knows about the \"consumed\" URL\n * segments, the extracted parameters, and the resolved data.\n *\n * See {\\@link ActivatedRoute} for more information.\n *\n * \\@stable\n */\nvar RouterState = (function (_super) {\n    Object(__WEBPACK_IMPORTED_MODULE_2_tslib__[\"b\" /* __extends */])(RouterState, _super);\n    /** @internal */\n    function RouterState(root, snapshot) {\n        var _this = _super.call(this, root) || this;\n        _this.snapshot = snapshot;\n        setRouterState(/** @type {?} */ (_this), root);\n        return _this;\n    }\n    /**\n     * @return {?}\n     */\n    RouterState.prototype.toString = /**\n     * @return {?}\n     */\n    function () { return this.snapshot.toString(); };\n    return RouterState;\n}(Tree));\n/**\n * @param {?} urlTree\n * @param {?} rootComponent\n * @return {?}\n */\nfunction createEmptyState(urlTree, rootComponent) {\n    var /** @type {?} */ snapshot = createEmptyStateSnapshot(urlTree, rootComponent);\n    var /** @type {?} */ emptyUrl = new __WEBPACK_IMPORTED_MODULE_3_rxjs_BehaviorSubject__[\"BehaviorSubject\"]([new UrlSegment('', {})]);\n    var /** @type {?} */ emptyParams = new __WEBPACK_IMPORTED_MODULE_3_rxjs_BehaviorSubject__[\"BehaviorSubject\"]({});\n    var /** @type {?} */ emptyData = new __WEBPACK_IMPORTED_MODULE_3_rxjs_BehaviorSubject__[\"BehaviorSubject\"]({});\n    var /** @type {?} */ emptyQueryParams = new __WEBPACK_IMPORTED_MODULE_3_rxjs_BehaviorSubject__[\"BehaviorSubject\"]({});\n    var /** @type {?} */ fragment = new __WEBPACK_IMPORTED_MODULE_3_rxjs_BehaviorSubject__[\"BehaviorSubject\"]('');\n    var /** @type {?} */ activated = new ActivatedRoute(emptyUrl, emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, snapshot.root);\n    activated.snapshot = snapshot.root;\n    return new RouterState(new TreeNode(activated, []), snapshot);\n}\n/**\n * @param {?} urlTree\n * @param {?} rootComponent\n * @return {?}\n */\nfunction createEmptyStateSnapshot(urlTree, rootComponent) {\n    var /** @type {?} */ emptyParams = {};\n    var /** @type {?} */ emptyData = {};\n    var /** @type {?} */ emptyQueryParams = {};\n    var /** @type {?} */ fragment = '';\n    var /** @type {?} */ activated = new ActivatedRouteSnapshot([], emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, null, urlTree.root, -1, {});\n    return new RouterStateSnapshot('', new TreeNode(activated, []));\n}\n/**\n * \\@whatItDoes Contains the information about a route associated with a component loaded in an\n * outlet.\n * An `ActivatedRoute` can also be used to traverse the router state tree.\n *\n * \\@howToUse\n *\n * ```\n * \\@Component({...})\n * class MyComponent {\n *   constructor(route: ActivatedRoute) {\n *     const id: Observable<string> = route.params.map(p => p.id);\n *     const url: Observable<string> = route.url.map(segments => segments.join(''));\n *     // route.data includes both `data` and `resolve`\n *     const user = route.data.map(d => d.user);\n *   }\n * }\n * ```\n *\n * \\@stable\n */\nvar ActivatedRoute = (function () {\n    /** @internal */\n    function ActivatedRoute(url, params, queryParams, fragment, data, outlet, component, futureSnapshot) {\n        this.url = url;\n        this.params = params;\n        this.queryParams = queryParams;\n        this.fragment = fragment;\n        this.data = data;\n        this.outlet = outlet;\n        this.component = component;\n        this._futureSnapshot = futureSnapshot;\n    }\n    Object.defineProperty(ActivatedRoute.prototype, \"routeConfig\", {\n        /** The configuration used to match this route */\n        get: /**\n         * The configuration used to match this route\n         * @return {?}\n         */\n        function () { return this._futureSnapshot.routeConfig; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ActivatedRoute.prototype, \"root\", {\n        /** The root of the router state */\n        get: /**\n         * The root of the router state\n         * @return {?}\n         */\n        function () { return this._routerState.root; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ActivatedRoute.prototype, \"parent\", {\n        /** The parent of this route in the router state tree */\n        get: /**\n         * The parent of this route in the router state tree\n         * @return {?}\n         */\n        function () { return this._routerState.parent(this); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ActivatedRoute.prototype, \"firstChild\", {\n        /** The first child of this route in the router state tree */\n        get: /**\n         * The first child of this route in the router state tree\n         * @return {?}\n         */\n        function () { return this._routerState.firstChild(this); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ActivatedRoute.prototype, \"children\", {\n        /** The children of this route in the router state tree */\n        get: /**\n         * The children of this route in the router state tree\n         * @return {?}\n         */\n        function () { return this._routerState.children(this); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ActivatedRoute.prototype, \"pathFromRoot\", {\n        /** The path from the root of the router state tree to this route */\n        get: /**\n         * The path from the root of the router state tree to this route\n         * @return {?}\n         */\n        function () { return this._routerState.pathFromRoot(this); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ActivatedRoute.prototype, \"paramMap\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            if (!this._paramMap) {\n                this._paramMap = __WEBPACK_IMPORTED_MODULE_7_rxjs_operator_map__[\"map\"].call(this.params, function (p) { return convertToParamMap(p); });\n            }\n            return this._paramMap;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ActivatedRoute.prototype, \"queryParamMap\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            if (!this._queryParamMap) {\n                this._queryParamMap =\n                    __WEBPACK_IMPORTED_MODULE_7_rxjs_operator_map__[\"map\"].call(this.queryParams, function (p) { return convertToParamMap(p); });\n            }\n            return this._queryParamMap;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    ActivatedRoute.prototype.toString = /**\n     * @return {?}\n     */\n    function () {\n        return this.snapshot ? this.snapshot.toString() : \"Future(\" + this._futureSnapshot + \")\";\n    };\n    return ActivatedRoute;\n}());\n/**\n * \\@internal\n * @param {?} route\n * @return {?}\n */\nfunction inheritedParamsDataResolve(route) {\n    var /** @type {?} */ pathToRoot = route.pathFromRoot;\n    var /** @type {?} */ inhertingStartingFrom = pathToRoot.length - 1;\n    while (inhertingStartingFrom >= 1) {\n        var /** @type {?} */ current = pathToRoot[inhertingStartingFrom];\n        var /** @type {?} */ parent_1 = pathToRoot[inhertingStartingFrom - 1];\n        // current route is an empty path => inherits its parent's params and data\n        if (current.routeConfig && current.routeConfig.path === '') {\n            inhertingStartingFrom--;\n            // parent is componentless => current route should inherit its params and data\n        }\n        else if (!parent_1.component) {\n            inhertingStartingFrom--;\n        }\n        else {\n            break;\n        }\n    }\n    return pathToRoot.slice(inhertingStartingFrom).reduce(function (res, curr) {\n        var /** @type {?} */ params = Object(__WEBPACK_IMPORTED_MODULE_2_tslib__[\"a\" /* __assign */])({}, res.params, curr.params);\n        var /** @type {?} */ data = Object(__WEBPACK_IMPORTED_MODULE_2_tslib__[\"a\" /* __assign */])({}, res.data, curr.data);\n        var /** @type {?} */ resolve = Object(__WEBPACK_IMPORTED_MODULE_2_tslib__[\"a\" /* __assign */])({}, res.resolve, curr._resolvedData);\n        return { params: params, data: data, resolve: resolve };\n    }, /** @type {?} */ ({ params: {}, data: {}, resolve: {} }));\n}\n/**\n * \\@whatItDoes Contains the information about a route associated with a component loaded in an\n * outlet\n * at a particular moment in time. ActivatedRouteSnapshot can also be used to traverse the router\n * state tree.\n *\n * \\@howToUse\n *\n * ```\n * \\@Component({templateUrl:'./my-component.html'})\n * class MyComponent {\n *   constructor(route: ActivatedRoute) {\n *     const id: string = route.snapshot.params.id;\n *     const url: string = route.snapshot.url.join('');\n *     const user = route.snapshot.data.user;\n *   }\n * }\n * ```\n *\n * \\@stable\n */\nvar ActivatedRouteSnapshot = (function () {\n    /** @internal */\n    function ActivatedRouteSnapshot(url, params, queryParams, fragment, data, outlet, component, routeConfig, urlSegment, lastPathIndex, resolve) {\n        this.url = url;\n        this.params = params;\n        this.queryParams = queryParams;\n        this.fragment = fragment;\n        this.data = data;\n        this.outlet = outlet;\n        this.component = component;\n        this.routeConfig = routeConfig;\n        this._urlSegment = urlSegment;\n        this._lastPathIndex = lastPathIndex;\n        this._resolve = resolve;\n    }\n    Object.defineProperty(ActivatedRouteSnapshot.prototype, \"root\", {\n        /** The root of the router state */\n        get: /**\n         * The root of the router state\n         * @return {?}\n         */\n        function () { return this._routerState.root; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ActivatedRouteSnapshot.prototype, \"parent\", {\n        /** The parent of this route in the router state tree */\n        get: /**\n         * The parent of this route in the router state tree\n         * @return {?}\n         */\n        function () { return this._routerState.parent(this); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ActivatedRouteSnapshot.prototype, \"firstChild\", {\n        /** The first child of this route in the router state tree */\n        get: /**\n         * The first child of this route in the router state tree\n         * @return {?}\n         */\n        function () { return this._routerState.firstChild(this); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ActivatedRouteSnapshot.prototype, \"children\", {\n        /** The children of this route in the router state tree */\n        get: /**\n         * The children of this route in the router state tree\n         * @return {?}\n         */\n        function () { return this._routerState.children(this); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ActivatedRouteSnapshot.prototype, \"pathFromRoot\", {\n        /** The path from the root of the router state tree to this route */\n        get: /**\n         * The path from the root of the router state tree to this route\n         * @return {?}\n         */\n        function () { return this._routerState.pathFromRoot(this); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ActivatedRouteSnapshot.prototype, \"paramMap\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            if (!this._paramMap) {\n                this._paramMap = convertToParamMap(this.params);\n            }\n            return this._paramMap;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ActivatedRouteSnapshot.prototype, \"queryParamMap\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            if (!this._queryParamMap) {\n                this._queryParamMap = convertToParamMap(this.queryParams);\n            }\n            return this._queryParamMap;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    ActivatedRouteSnapshot.prototype.toString = /**\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ url = this.url.map(function (segment) { return segment.toString(); }).join('/');\n        var /** @type {?} */ matched = this.routeConfig ? this.routeConfig.path : '';\n        return \"Route(url:'\" + url + \"', path:'\" + matched + \"')\";\n    };\n    return ActivatedRouteSnapshot;\n}());\n/**\n * \\@whatItDoes Represents the state of the router at a moment in time.\n *\n * \\@howToUse\n *\n * ```\n * \\@Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const state: RouterState = router.routerState;\n *     const snapshot: RouterStateSnapshot = state.snapshot;\n *     const root: ActivatedRouteSnapshot = snapshot.root;\n *     const child = root.firstChild;\n *     const id: Observable<string> = child.params.map(p => p.id);\n *     //...\n *   }\n * }\n * ```\n *\n * \\@description\n * RouterStateSnapshot is a tree of activated route snapshots. Every node in this tree knows about\n * the \"consumed\" URL segments, the extracted parameters, and the resolved data.\n *\n * \\@stable\n */\nvar RouterStateSnapshot = (function (_super) {\n    Object(__WEBPACK_IMPORTED_MODULE_2_tslib__[\"b\" /* __extends */])(RouterStateSnapshot, _super);\n    /** @internal */\n    function RouterStateSnapshot(url, root) {\n        var _this = _super.call(this, root) || this;\n        _this.url = url;\n        setRouterState(/** @type {?} */ (_this), root);\n        return _this;\n    }\n    /**\n     * @return {?}\n     */\n    RouterStateSnapshot.prototype.toString = /**\n     * @return {?}\n     */\n    function () { return serializeNode(this._root); };\n    return RouterStateSnapshot;\n}(Tree));\n/**\n * @template U, T\n * @param {?} state\n * @param {?} node\n * @return {?}\n */\nfunction setRouterState(state, node) {\n    node.value._routerState = state;\n    node.children.forEach(function (c) { return setRouterState(state, c); });\n}\n/**\n * @param {?} node\n * @return {?}\n */\nfunction serializeNode(node) {\n    var /** @type {?} */ c = node.children.length > 0 ? \" { \" + node.children.map(serializeNode).join(\", \") + \" } \" : '';\n    return \"\" + node.value + c;\n}\n/**\n * The expectation is that the activate route is created with the right set of parameters.\n * So we push new values into the observables only when they are not the initial values.\n * And we detect that by checking if the snapshot field is set.\n * @param {?} route\n * @return {?}\n */\nfunction advanceActivatedRoute(route) {\n    if (route.snapshot) {\n        var /** @type {?} */ currentSnapshot = route.snapshot;\n        var /** @type {?} */ nextSnapshot = route._futureSnapshot;\n        route.snapshot = nextSnapshot;\n        if (!shallowEqual(currentSnapshot.queryParams, nextSnapshot.queryParams)) {\n            (/** @type {?} */ (route.queryParams)).next(nextSnapshot.queryParams);\n        }\n        if (currentSnapshot.fragment !== nextSnapshot.fragment) {\n            (/** @type {?} */ (route.fragment)).next(nextSnapshot.fragment);\n        }\n        if (!shallowEqual(currentSnapshot.params, nextSnapshot.params)) {\n            (/** @type {?} */ (route.params)).next(nextSnapshot.params);\n        }\n        if (!shallowEqualArrays(currentSnapshot.url, nextSnapshot.url)) {\n            (/** @type {?} */ (route.url)).next(nextSnapshot.url);\n        }\n        if (!shallowEqual(currentSnapshot.data, nextSnapshot.data)) {\n            (/** @type {?} */ (route.data)).next(nextSnapshot.data);\n        }\n    }\n    else {\n        route.snapshot = route._futureSnapshot;\n        // this is for resolved data\n        (/** @type {?} */ (route.data)).next(route._futureSnapshot.data);\n    }\n}\n/**\n * @param {?} a\n * @param {?} b\n * @return {?}\n */\nfunction equalParamsAndUrlSegments(a, b) {\n    var /** @type {?} */ equalUrlParams = shallowEqual(a.params, b.params) && equalSegments(a.url, b.url);\n    var /** @type {?} */ parentsMismatch = !a.parent !== !b.parent;\n    return equalUrlParams && !parentsMismatch &&\n        (!a.parent || equalParamsAndUrlSegments(a.parent, /** @type {?} */ ((b.parent))));\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @param {?} routeReuseStrategy\n * @param {?} curr\n * @param {?} prevState\n * @return {?}\n */\nfunction createRouterState(routeReuseStrategy, curr, prevState) {\n    var /** @type {?} */ root = createNode(routeReuseStrategy, curr._root, prevState ? prevState._root : undefined);\n    return new RouterState(root, curr);\n}\n/**\n * @param {?} routeReuseStrategy\n * @param {?} curr\n * @param {?=} prevState\n * @return {?}\n */\nfunction createNode(routeReuseStrategy, curr, prevState) {\n    // reuse an activated route that is currently displayed on the screen\n    if (prevState && routeReuseStrategy.shouldReuseRoute(curr.value, prevState.value.snapshot)) {\n        var /** @type {?} */ value = prevState.value;\n        value._futureSnapshot = curr.value;\n        var /** @type {?} */ children = createOrReuseChildren(routeReuseStrategy, curr, prevState);\n        return new TreeNode(value, children);\n        // retrieve an activated route that is used to be displayed, but is not currently displayed\n    }\n    else if (routeReuseStrategy.retrieve(curr.value)) {\n        var /** @type {?} */ tree = (/** @type {?} */ (routeReuseStrategy.retrieve(curr.value))).route;\n        setFutureSnapshotsOfActivatedRoutes(curr, tree);\n        return tree;\n    }\n    else {\n        var /** @type {?} */ value = createActivatedRoute(curr.value);\n        var /** @type {?} */ children = curr.children.map(function (c) { return createNode(routeReuseStrategy, c); });\n        return new TreeNode(value, children);\n    }\n}\n/**\n * @param {?} curr\n * @param {?} result\n * @return {?}\n */\nfunction setFutureSnapshotsOfActivatedRoutes(curr, result) {\n    if (curr.value.routeConfig !== result.value.routeConfig) {\n        throw new Error('Cannot reattach ActivatedRouteSnapshot created from a different route');\n    }\n    if (curr.children.length !== result.children.length) {\n        throw new Error('Cannot reattach ActivatedRouteSnapshot with a different number of children');\n    }\n    result.value._futureSnapshot = curr.value;\n    for (var /** @type {?} */ i = 0; i < curr.children.length; ++i) {\n        setFutureSnapshotsOfActivatedRoutes(curr.children[i], result.children[i]);\n    }\n}\n/**\n * @param {?} routeReuseStrategy\n * @param {?} curr\n * @param {?} prevState\n * @return {?}\n */\nfunction createOrReuseChildren(routeReuseStrategy, curr, prevState) {\n    return curr.children.map(function (child) {\n        for (var _i = 0, _a = prevState.children; _i < _a.length; _i++) {\n            var p = _a[_i];\n            if (routeReuseStrategy.shouldReuseRoute(p.value.snapshot, child.value)) {\n                return createNode(routeReuseStrategy, child, p);\n            }\n        }\n        return createNode(routeReuseStrategy, child);\n    });\n}\n/**\n * @param {?} c\n * @return {?}\n */\nfunction createActivatedRoute(c) {\n    return new ActivatedRoute(new __WEBPACK_IMPORTED_MODULE_3_rxjs_BehaviorSubject__[\"BehaviorSubject\"](c.url), new __WEBPACK_IMPORTED_MODULE_3_rxjs_BehaviorSubject__[\"BehaviorSubject\"](c.params), new __WEBPACK_IMPORTED_MODULE_3_rxjs_BehaviorSubject__[\"BehaviorSubject\"](c.queryParams), new __WEBPACK_IMPORTED_MODULE_3_rxjs_BehaviorSubject__[\"BehaviorSubject\"](c.fragment), new __WEBPACK_IMPORTED_MODULE_3_rxjs_BehaviorSubject__[\"BehaviorSubject\"](c.data), c.outlet, c.component, c);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @param {?} route\n * @param {?} urlTree\n * @param {?} commands\n * @param {?} queryParams\n * @param {?} fragment\n * @return {?}\n */\nfunction createUrlTree(route, urlTree, commands, queryParams, fragment) {\n    if (commands.length === 0) {\n        return tree(urlTree.root, urlTree.root, urlTree, queryParams, fragment);\n    }\n    var /** @type {?} */ nav = computeNavigation(commands);\n    if (nav.toRoot()) {\n        return tree(urlTree.root, new UrlSegmentGroup([], {}), urlTree, queryParams, fragment);\n    }\n    var /** @type {?} */ startingPosition = findStartingPosition(nav, urlTree, route);\n    var /** @type {?} */ segmentGroup = startingPosition.processChildren ?\n        updateSegmentGroupChildren(startingPosition.segmentGroup, startingPosition.index, nav.commands) :\n        updateSegmentGroup(startingPosition.segmentGroup, startingPosition.index, nav.commands);\n    return tree(startingPosition.segmentGroup, segmentGroup, urlTree, queryParams, fragment);\n}\n/**\n * @param {?} command\n * @return {?}\n */\nfunction isMatrixParams(command) {\n    return typeof command === 'object' && command != null && !command.outlets && !command.segmentPath;\n}\n/**\n * @param {?} oldSegmentGroup\n * @param {?} newSegmentGroup\n * @param {?} urlTree\n * @param {?} queryParams\n * @param {?} fragment\n * @return {?}\n */\nfunction tree(oldSegmentGroup, newSegmentGroup, urlTree, queryParams, fragment) {\n    var /** @type {?} */ qp = {};\n    if (queryParams) {\n        forEach(queryParams, function (value, name) {\n            qp[name] = Array.isArray(value) ? value.map(function (v) { return \"\" + v; }) : \"\" + value;\n        });\n    }\n    if (urlTree.root === oldSegmentGroup) {\n        return new UrlTree(newSegmentGroup, qp, fragment);\n    }\n    return new UrlTree(replaceSegment(urlTree.root, oldSegmentGroup, newSegmentGroup), qp, fragment);\n}\n/**\n * @param {?} current\n * @param {?} oldSegment\n * @param {?} newSegment\n * @return {?}\n */\nfunction replaceSegment(current, oldSegment, newSegment) {\n    var /** @type {?} */ children = {};\n    forEach(current.children, function (c, outletName) {\n        if (c === oldSegment) {\n            children[outletName] = newSegment;\n        }\n        else {\n            children[outletName] = replaceSegment(c, oldSegment, newSegment);\n        }\n    });\n    return new UrlSegmentGroup(current.segments, children);\n}\nvar Navigation = (function () {\n    function Navigation(isAbsolute, numberOfDoubleDots, commands) {\n        this.isAbsolute = isAbsolute;\n        this.numberOfDoubleDots = numberOfDoubleDots;\n        this.commands = commands;\n        if (isAbsolute && commands.length > 0 && isMatrixParams(commands[0])) {\n            throw new Error('Root segment cannot have matrix parameters');\n        }\n        var /** @type {?} */ cmdWithOutlet = commands.find(function (c) { return typeof c === 'object' && c != null && c.outlets; });\n        if (cmdWithOutlet && cmdWithOutlet !== last$1(commands)) {\n            throw new Error('{outlets:{}} has to be the last command');\n        }\n    }\n    /**\n     * @return {?}\n     */\n    Navigation.prototype.toRoot = /**\n     * @return {?}\n     */\n    function () {\n        return this.isAbsolute && this.commands.length === 1 && this.commands[0] == '/';\n    };\n    return Navigation;\n}());\n/**\n * Transforms commands to a normalized `Navigation`\n * @param {?} commands\n * @return {?}\n */\nfunction computeNavigation(commands) {\n    if ((typeof commands[0] === 'string') && commands.length === 1 && commands[0] === '/') {\n        return new Navigation(true, 0, commands);\n    }\n    var /** @type {?} */ numberOfDoubleDots = 0;\n    var /** @type {?} */ isAbsolute = false;\n    var /** @type {?} */ res = commands.reduce(function (res, cmd, cmdIdx) {\n        if (typeof cmd === 'object' && cmd != null) {\n            if (cmd.outlets) {\n                var /** @type {?} */ outlets_1 = {};\n                forEach(cmd.outlets, function (commands, name) {\n                    outlets_1[name] = typeof commands === 'string' ? commands.split('/') : commands;\n                });\n                return res.concat([{ outlets: outlets_1 }]);\n            }\n            if (cmd.segmentPath) {\n                return res.concat([cmd.segmentPath]);\n            }\n        }\n        if (!(typeof cmd === 'string')) {\n            return res.concat([cmd]);\n        }\n        if (cmdIdx === 0) {\n            cmd.split('/').forEach(function (urlPart, partIndex) {\n                if (partIndex == 0 && urlPart === '.') {\n                    // skip './a'\n                }\n                else if (partIndex == 0 && urlPart === '') {\n                    //  '/a'\n                    isAbsolute = true;\n                }\n                else if (urlPart === '..') {\n                    //  '../a'\n                    numberOfDoubleDots++;\n                }\n                else if (urlPart != '') {\n                    res.push(urlPart);\n                }\n            });\n            return res;\n        }\n        return res.concat([cmd]);\n    }, []);\n    return new Navigation(isAbsolute, numberOfDoubleDots, res);\n}\nvar Position = (function () {\n    function Position(segmentGroup, processChildren, index) {\n        this.segmentGroup = segmentGroup;\n        this.processChildren = processChildren;\n        this.index = index;\n    }\n    return Position;\n}());\n/**\n * @param {?} nav\n * @param {?} tree\n * @param {?} route\n * @return {?}\n */\nfunction findStartingPosition(nav, tree, route) {\n    if (nav.isAbsolute) {\n        return new Position(tree.root, true, 0);\n    }\n    if (route.snapshot._lastPathIndex === -1) {\n        return new Position(route.snapshot._urlSegment, true, 0);\n    }\n    var /** @type {?} */ modifier = isMatrixParams(nav.commands[0]) ? 0 : 1;\n    var /** @type {?} */ index = route.snapshot._lastPathIndex + modifier;\n    return createPositionApplyingDoubleDots(route.snapshot._urlSegment, index, nav.numberOfDoubleDots);\n}\n/**\n * @param {?} group\n * @param {?} index\n * @param {?} numberOfDoubleDots\n * @return {?}\n */\nfunction createPositionApplyingDoubleDots(group, index, numberOfDoubleDots) {\n    var /** @type {?} */ g = group;\n    var /** @type {?} */ ci = index;\n    var /** @type {?} */ dd = numberOfDoubleDots;\n    while (dd > ci) {\n        dd -= ci;\n        g = /** @type {?} */ ((g.parent));\n        if (!g) {\n            throw new Error('Invalid number of \\'../\\'');\n        }\n        ci = g.segments.length;\n    }\n    return new Position(g, false, ci - dd);\n}\n/**\n * @param {?} command\n * @return {?}\n */\nfunction getPath(command) {\n    if (typeof command === 'object' && command != null && command.outlets) {\n        return command.outlets[PRIMARY_OUTLET];\n    }\n    return \"\" + command;\n}\n/**\n * @param {?} commands\n * @return {?}\n */\nfunction getOutlets(commands) {\n    if (!(typeof commands[0] === 'object'))\n        return _a = {}, _a[PRIMARY_OUTLET] = commands, _a;\n    if (commands[0].outlets === undefined)\n        return _b = {}, _b[PRIMARY_OUTLET] = commands, _b;\n    return commands[0].outlets;\n    var _a, _b;\n}\n/**\n * @param {?} segmentGroup\n * @param {?} startIndex\n * @param {?} commands\n * @return {?}\n */\nfunction updateSegmentGroup(segmentGroup, startIndex, commands) {\n    if (!segmentGroup) {\n        segmentGroup = new UrlSegmentGroup([], {});\n    }\n    if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n        return updateSegmentGroupChildren(segmentGroup, startIndex, commands);\n    }\n    var /** @type {?} */ m = prefixedWith(segmentGroup, startIndex, commands);\n    var /** @type {?} */ slicedCommands = commands.slice(m.commandIndex);\n    if (m.match && m.pathIndex < segmentGroup.segments.length) {\n        var /** @type {?} */ g = new UrlSegmentGroup(segmentGroup.segments.slice(0, m.pathIndex), {});\n        g.children[PRIMARY_OUTLET] =\n            new UrlSegmentGroup(segmentGroup.segments.slice(m.pathIndex), segmentGroup.children);\n        return updateSegmentGroupChildren(g, 0, slicedCommands);\n    }\n    else if (m.match && slicedCommands.length === 0) {\n        return new UrlSegmentGroup(segmentGroup.segments, {});\n    }\n    else if (m.match && !segmentGroup.hasChildren()) {\n        return createNewSegmentGroup(segmentGroup, startIndex, commands);\n    }\n    else if (m.match) {\n        return updateSegmentGroupChildren(segmentGroup, 0, slicedCommands);\n    }\n    else {\n        return createNewSegmentGroup(segmentGroup, startIndex, commands);\n    }\n}\n/**\n * @param {?} segmentGroup\n * @param {?} startIndex\n * @param {?} commands\n * @return {?}\n */\nfunction updateSegmentGroupChildren(segmentGroup, startIndex, commands) {\n    if (commands.length === 0) {\n        return new UrlSegmentGroup(segmentGroup.segments, {});\n    }\n    else {\n        var /** @type {?} */ outlets_2 = getOutlets(commands);\n        var /** @type {?} */ children_1 = {};\n        forEach(outlets_2, function (commands, outlet) {\n            if (commands !== null) {\n                children_1[outlet] = updateSegmentGroup(segmentGroup.children[outlet], startIndex, commands);\n            }\n        });\n        forEach(segmentGroup.children, function (child, childOutlet) {\n            if (outlets_2[childOutlet] === undefined) {\n                children_1[childOutlet] = child;\n            }\n        });\n        return new UrlSegmentGroup(segmentGroup.segments, children_1);\n    }\n}\n/**\n * @param {?} segmentGroup\n * @param {?} startIndex\n * @param {?} commands\n * @return {?}\n */\nfunction prefixedWith(segmentGroup, startIndex, commands) {\n    var /** @type {?} */ currentCommandIndex = 0;\n    var /** @type {?} */ currentPathIndex = startIndex;\n    var /** @type {?} */ noMatch = { match: false, pathIndex: 0, commandIndex: 0 };\n    while (currentPathIndex < segmentGroup.segments.length) {\n        if (currentCommandIndex >= commands.length)\n            return noMatch;\n        var /** @type {?} */ path = segmentGroup.segments[currentPathIndex];\n        var /** @type {?} */ curr = getPath(commands[currentCommandIndex]);\n        var /** @type {?} */ next = currentCommandIndex < commands.length - 1 ? commands[currentCommandIndex + 1] : null;\n        if (currentPathIndex > 0 && curr === undefined)\n            break;\n        if (curr && next && (typeof next === 'object') && next.outlets === undefined) {\n            if (!compare(curr, next, path))\n                return noMatch;\n            currentCommandIndex += 2;\n        }\n        else {\n            if (!compare(curr, {}, path))\n                return noMatch;\n            currentCommandIndex++;\n        }\n        currentPathIndex++;\n    }\n    return { match: true, pathIndex: currentPathIndex, commandIndex: currentCommandIndex };\n}\n/**\n * @param {?} segmentGroup\n * @param {?} startIndex\n * @param {?} commands\n * @return {?}\n */\nfunction createNewSegmentGroup(segmentGroup, startIndex, commands) {\n    var /** @type {?} */ paths = segmentGroup.segments.slice(0, startIndex);\n    var /** @type {?} */ i = 0;\n    while (i < commands.length) {\n        if (typeof commands[i] === 'object' && commands[i].outlets !== undefined) {\n            var /** @type {?} */ children = createNewSegmentChildren(commands[i].outlets);\n            return new UrlSegmentGroup(paths, children);\n        }\n        // if we start with an object literal, we need to reuse the path part from the segment\n        if (i === 0 && isMatrixParams(commands[0])) {\n            var /** @type {?} */ p = segmentGroup.segments[startIndex];\n            paths.push(new UrlSegment(p.path, commands[0]));\n            i++;\n            continue;\n        }\n        var /** @type {?} */ curr = getPath(commands[i]);\n        var /** @type {?} */ next = (i < commands.length - 1) ? commands[i + 1] : null;\n        if (curr && next && isMatrixParams(next)) {\n            paths.push(new UrlSegment(curr, stringify(next)));\n            i += 2;\n        }\n        else {\n            paths.push(new UrlSegment(curr, {}));\n            i++;\n        }\n    }\n    return new UrlSegmentGroup(paths, {});\n}\n/**\n * @param {?} outlets\n * @return {?}\n */\nfunction createNewSegmentChildren(outlets) {\n    var /** @type {?} */ children = {};\n    forEach(outlets, function (commands, outlet) {\n        if (commands !== null) {\n            children[outlet] = createNewSegmentGroup(new UrlSegmentGroup([], {}), 0, commands);\n        }\n    });\n    return children;\n}\n/**\n * @param {?} params\n * @return {?}\n */\nfunction stringify(params) {\n    var /** @type {?} */ res = {};\n    forEach(params, function (v, k) { return res[k] = \"\" + v; });\n    return res;\n}\n/**\n * @param {?} path\n * @param {?} params\n * @param {?} segment\n * @return {?}\n */\nfunction compare(path, params, segment) {\n    return path == segment.path && shallowEqual(params, segment.parameters);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar CanActivate = (function () {\n    function CanActivate(path) {\n        this.path = path;\n    }\n    Object.defineProperty(CanActivate.prototype, \"route\", {\n        get: /**\n         * @return {?}\n         */\n        function () { return this.path[this.path.length - 1]; },\n        enumerable: true,\n        configurable: true\n    });\n    return CanActivate;\n}());\nvar CanDeactivate = (function () {\n    function CanDeactivate(component, route) {\n        this.component = component;\n        this.route = route;\n    }\n    return CanDeactivate;\n}());\n/**\n * This class bundles the actions involved in preactivation of a route.\n */\nvar PreActivation = (function () {\n    function PreActivation(future, curr, moduleInjector, forwardEvent) {\n        this.future = future;\n        this.curr = curr;\n        this.moduleInjector = moduleInjector;\n        this.forwardEvent = forwardEvent;\n        this.canActivateChecks = [];\n        this.canDeactivateChecks = [];\n    }\n    /**\n     * @param {?} parentContexts\n     * @return {?}\n     */\n    PreActivation.prototype.initialize = /**\n     * @param {?} parentContexts\n     * @return {?}\n     */\n    function (parentContexts) {\n        var /** @type {?} */ futureRoot = this.future._root;\n        var /** @type {?} */ currRoot = this.curr ? this.curr._root : null;\n        this.setupChildRouteGuards(futureRoot, currRoot, parentContexts, [futureRoot.value]);\n    };\n    /**\n     * @return {?}\n     */\n    PreActivation.prototype.checkGuards = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (!this.isDeactivating() && !this.isActivating()) {\n            return Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_of__[\"of\"])(true);\n        }\n        var /** @type {?} */ canDeactivate$ = this.runCanDeactivateChecks();\n        return __WEBPACK_IMPORTED_MODULE_8_rxjs_operator_mergeMap__[\"mergeMap\"].call(canDeactivate$, function (canDeactivate) { return canDeactivate ? _this.runCanActivateChecks() : Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_of__[\"of\"])(false); });\n    };\n    /**\n     * @return {?}\n     */\n    PreActivation.prototype.resolveData = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (!this.isActivating())\n            return Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_of__[\"of\"])(null);\n        var /** @type {?} */ checks$ = Object(__WEBPACK_IMPORTED_MODULE_10_rxjs_observable_from__[\"from\"])(this.canActivateChecks);\n        var /** @type {?} */ runningChecks$ = __WEBPACK_IMPORTED_MODULE_6_rxjs_operator_concatMap__[\"concatMap\"].call(checks$, function (check) { return _this.runResolve(check.route); });\n        return __WEBPACK_IMPORTED_MODULE_19_rxjs_operator_reduce__[\"reduce\"].call(runningChecks$, function (_, __) { return _; });\n    };\n    /**\n     * @return {?}\n     */\n    PreActivation.prototype.isDeactivating = /**\n     * @return {?}\n     */\n    function () { return this.canDeactivateChecks.length !== 0; };\n    /**\n     * @return {?}\n     */\n    PreActivation.prototype.isActivating = /**\n     * @return {?}\n     */\n    function () { return this.canActivateChecks.length !== 0; };\n    /**\n     * Iterates over child routes and calls recursive `setupRouteGuards` to get `this` instance in\n     * proper state to run `checkGuards()` method.\n     * @param {?} futureNode\n     * @param {?} currNode\n     * @param {?} contexts\n     * @param {?} futurePath\n     * @return {?}\n     */\n    PreActivation.prototype.setupChildRouteGuards = /**\n     * Iterates over child routes and calls recursive `setupRouteGuards` to get `this` instance in\n     * proper state to run `checkGuards()` method.\n     * @param {?} futureNode\n     * @param {?} currNode\n     * @param {?} contexts\n     * @param {?} futurePath\n     * @return {?}\n     */\n    function (futureNode, currNode, contexts, futurePath) {\n        var _this = this;\n        var /** @type {?} */ prevChildren = nodeChildrenAsMap(currNode);\n        // Process the children of the future route\n        futureNode.children.forEach(function (c) {\n            _this.setupRouteGuards(c, prevChildren[c.value.outlet], contexts, futurePath.concat([c.value]));\n            delete prevChildren[c.value.outlet];\n        });\n        // Process any children left from the current route (not active for the future route)\n        forEach(prevChildren, function (v, k) {\n            return _this.deactivateRouteAndItsChildren(v, /** @type {?} */ ((contexts)).getContext(k));\n        });\n    };\n    /**\n     * Iterates over child routes and calls recursive `setupRouteGuards` to get `this` instance in\n     * proper state to run `checkGuards()` method.\n     * @param {?} futureNode\n     * @param {?} currNode\n     * @param {?} parentContexts\n     * @param {?} futurePath\n     * @return {?}\n     */\n    PreActivation.prototype.setupRouteGuards = /**\n     * Iterates over child routes and calls recursive `setupRouteGuards` to get `this` instance in\n     * proper state to run `checkGuards()` method.\n     * @param {?} futureNode\n     * @param {?} currNode\n     * @param {?} parentContexts\n     * @param {?} futurePath\n     * @return {?}\n     */\n    function (futureNode, currNode, parentContexts, futurePath) {\n        var /** @type {?} */ future = futureNode.value;\n        var /** @type {?} */ curr = currNode ? currNode.value : null;\n        var /** @type {?} */ context = parentContexts ? parentContexts.getContext(futureNode.value.outlet) : null;\n        // reusing the node\n        if (curr && future.routeConfig === curr.routeConfig) {\n            var /** @type {?} */ shouldRunGuardsAndResolvers = this.shouldRunGuardsAndResolvers(curr, future, /** @type {?} */ ((future.routeConfig)).runGuardsAndResolvers);\n            if (shouldRunGuardsAndResolvers) {\n                this.canActivateChecks.push(new CanActivate(futurePath));\n            }\n            else {\n                // we need to set the data\n                future.data = curr.data;\n                future._resolvedData = curr._resolvedData;\n            }\n            // If we have a component, we need to go through an outlet.\n            if (future.component) {\n                this.setupChildRouteGuards(futureNode, currNode, context ? context.children : null, futurePath);\n                // if we have a componentless route, we recurse but keep the same outlet map.\n            }\n            else {\n                this.setupChildRouteGuards(futureNode, currNode, parentContexts, futurePath);\n            }\n            if (shouldRunGuardsAndResolvers) {\n                var /** @type {?} */ outlet = /** @type {?} */ ((/** @type {?} */ ((context)).outlet));\n                this.canDeactivateChecks.push(new CanDeactivate(outlet.component, curr));\n            }\n        }\n        else {\n            if (curr) {\n                this.deactivateRouteAndItsChildren(currNode, context);\n            }\n            this.canActivateChecks.push(new CanActivate(futurePath));\n            // If we have a component, we need to go through an outlet.\n            if (future.component) {\n                this.setupChildRouteGuards(futureNode, null, context ? context.children : null, futurePath);\n                // if we have a componentless route, we recurse but keep the same outlet map.\n            }\n            else {\n                this.setupChildRouteGuards(futureNode, null, parentContexts, futurePath);\n            }\n        }\n    };\n    /**\n     * @param {?} curr\n     * @param {?} future\n     * @param {?} mode\n     * @return {?}\n     */\n    PreActivation.prototype.shouldRunGuardsAndResolvers = /**\n     * @param {?} curr\n     * @param {?} future\n     * @param {?} mode\n     * @return {?}\n     */\n    function (curr, future, mode) {\n        switch (mode) {\n            case 'always':\n                return true;\n            case 'paramsOrQueryParamsChange':\n                return !equalParamsAndUrlSegments(curr, future) ||\n                    !shallowEqual(curr.queryParams, future.queryParams);\n            case 'paramsChange':\n            default:\n                return !equalParamsAndUrlSegments(curr, future);\n        }\n    };\n    /**\n     * @param {?} route\n     * @param {?} context\n     * @return {?}\n     */\n    PreActivation.prototype.deactivateRouteAndItsChildren = /**\n     * @param {?} route\n     * @param {?} context\n     * @return {?}\n     */\n    function (route, context) {\n        var _this = this;\n        var /** @type {?} */ children = nodeChildrenAsMap(route);\n        var /** @type {?} */ r = route.value;\n        forEach(children, function (node, childName) {\n            if (!r.component) {\n                _this.deactivateRouteAndItsChildren(node, context);\n            }\n            else if (context) {\n                _this.deactivateRouteAndItsChildren(node, context.children.getContext(childName));\n            }\n            else {\n                _this.deactivateRouteAndItsChildren(node, null);\n            }\n        });\n        if (!r.component) {\n            this.canDeactivateChecks.push(new CanDeactivate(null, r));\n        }\n        else if (context && context.outlet && context.outlet.isActivated) {\n            this.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, r));\n        }\n        else {\n            this.canDeactivateChecks.push(new CanDeactivate(null, r));\n        }\n    };\n    /**\n     * @return {?}\n     */\n    PreActivation.prototype.runCanDeactivateChecks = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        var /** @type {?} */ checks$ = Object(__WEBPACK_IMPORTED_MODULE_10_rxjs_observable_from__[\"from\"])(this.canDeactivateChecks);\n        var /** @type {?} */ runningChecks$ = __WEBPACK_IMPORTED_MODULE_8_rxjs_operator_mergeMap__[\"mergeMap\"].call(checks$, function (check) { return _this.runCanDeactivate(check.component, check.route); });\n        return __WEBPACK_IMPORTED_MODULE_16_rxjs_operator_every__[\"every\"].call(runningChecks$, function (result) { return result === true; });\n    };\n    /**\n     * @return {?}\n     */\n    PreActivation.prototype.runCanActivateChecks = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        var /** @type {?} */ checks$ = Object(__WEBPACK_IMPORTED_MODULE_10_rxjs_observable_from__[\"from\"])(this.canActivateChecks);\n        var /** @type {?} */ runningChecks$ = __WEBPACK_IMPORTED_MODULE_6_rxjs_operator_concatMap__[\"concatMap\"].call(checks$, function (check) {\n            return andObservables(Object(__WEBPACK_IMPORTED_MODULE_10_rxjs_observable_from__[\"from\"])([\n                _this.fireChildActivationStart(check.route.parent), _this.fireActivationStart(check.route),\n                _this.runCanActivateChild(check.path), _this.runCanActivate(check.route)\n            ]));\n        });\n        return __WEBPACK_IMPORTED_MODULE_16_rxjs_operator_every__[\"every\"].call(runningChecks$, function (result) { return result === true; });\n        // this.fireChildActivationStart(check.path),\n    };\n    /**\n     * This should fire off `ActivationStart` events for each route being activated at this\n     * level.\n     * In other words, if you're activating `a` and `b` below, `path` will contain the\n     * `ActivatedRouteSnapshot`s for both and we will fire `ActivationStart` for both. Always\n     * return\n     * `true` so checks continue to run.\n     * @param {?} snapshot\n     * @return {?}\n     */\n    PreActivation.prototype.fireActivationStart = /**\n     * This should fire off `ActivationStart` events for each route being activated at this\n     * level.\n     * In other words, if you're activating `a` and `b` below, `path` will contain the\n     * `ActivatedRouteSnapshot`s for both and we will fire `ActivationStart` for both. Always\n     * return\n     * `true` so checks continue to run.\n     * @param {?} snapshot\n     * @return {?}\n     */\n    function (snapshot) {\n        if (snapshot !== null && this.forwardEvent) {\n            this.forwardEvent(new ActivationStart(snapshot));\n        }\n        return Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_of__[\"of\"])(true);\n    };\n    /**\n     * This should fire off `ChildActivationStart` events for each route being activated at this\n     * level.\n     * In other words, if you're activating `a` and `b` below, `path` will contain the\n     * `ActivatedRouteSnapshot`s for both and we will fire `ChildActivationStart` for both. Always\n     * return\n     * `true` so checks continue to run.\n     * @param {?} snapshot\n     * @return {?}\n     */\n    PreActivation.prototype.fireChildActivationStart = /**\n     * This should fire off `ChildActivationStart` events for each route being activated at this\n     * level.\n     * In other words, if you're activating `a` and `b` below, `path` will contain the\n     * `ActivatedRouteSnapshot`s for both and we will fire `ChildActivationStart` for both. Always\n     * return\n     * `true` so checks continue to run.\n     * @param {?} snapshot\n     * @return {?}\n     */\n    function (snapshot) {\n        if (snapshot !== null && this.forwardEvent) {\n            this.forwardEvent(new ChildActivationStart(snapshot));\n        }\n        return Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_of__[\"of\"])(true);\n    };\n    /**\n     * @param {?} future\n     * @return {?}\n     */\n    PreActivation.prototype.runCanActivate = /**\n     * @param {?} future\n     * @return {?}\n     */\n    function (future) {\n        var _this = this;\n        var /** @type {?} */ canActivate = future.routeConfig ? future.routeConfig.canActivate : null;\n        if (!canActivate || canActivate.length === 0)\n            return Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_of__[\"of\"])(true);\n        var /** @type {?} */ obs = __WEBPACK_IMPORTED_MODULE_7_rxjs_operator_map__[\"map\"].call(Object(__WEBPACK_IMPORTED_MODULE_10_rxjs_observable_from__[\"from\"])(canActivate), function (c) {\n            var /** @type {?} */ guard = _this.getToken(c, future);\n            var /** @type {?} */ observable;\n            if (guard.canActivate) {\n                observable = wrapIntoObservable(guard.canActivate(future, _this.future));\n            }\n            else {\n                observable = wrapIntoObservable(guard(future, _this.future));\n            }\n            return __WEBPACK_IMPORTED_MODULE_13_rxjs_operator_first__[\"first\"].call(observable);\n        });\n        return andObservables(obs);\n    };\n    /**\n     * @param {?} path\n     * @return {?}\n     */\n    PreActivation.prototype.runCanActivateChild = /**\n     * @param {?} path\n     * @return {?}\n     */\n    function (path) {\n        var _this = this;\n        var /** @type {?} */ future = path[path.length - 1];\n        var /** @type {?} */ canActivateChildGuards = path.slice(0, path.length - 1)\n            .reverse()\n            .map(function (p) { return _this.extractCanActivateChild(p); })\n            .filter(function (_) { return _ !== null; });\n        return andObservables(__WEBPACK_IMPORTED_MODULE_7_rxjs_operator_map__[\"map\"].call(Object(__WEBPACK_IMPORTED_MODULE_10_rxjs_observable_from__[\"from\"])(canActivateChildGuards), function (d) {\n            var /** @type {?} */ obs = __WEBPACK_IMPORTED_MODULE_7_rxjs_operator_map__[\"map\"].call(Object(__WEBPACK_IMPORTED_MODULE_10_rxjs_observable_from__[\"from\"])(d.guards), function (c) {\n                var /** @type {?} */ guard = _this.getToken(c, d.node);\n                var /** @type {?} */ observable;\n                if (guard.canActivateChild) {\n                    observable = wrapIntoObservable(guard.canActivateChild(future, _this.future));\n                }\n                else {\n                    observable = wrapIntoObservable(guard(future, _this.future));\n                }\n                return __WEBPACK_IMPORTED_MODULE_13_rxjs_operator_first__[\"first\"].call(observable);\n            });\n            return andObservables(obs);\n        }));\n    };\n    /**\n     * @param {?} p\n     * @return {?}\n     */\n    PreActivation.prototype.extractCanActivateChild = /**\n     * @param {?} p\n     * @return {?}\n     */\n    function (p) {\n        var /** @type {?} */ canActivateChild = p.routeConfig ? p.routeConfig.canActivateChild : null;\n        if (!canActivateChild || canActivateChild.length === 0)\n            return null;\n        return { node: p, guards: canActivateChild };\n    };\n    /**\n     * @param {?} component\n     * @param {?} curr\n     * @return {?}\n     */\n    PreActivation.prototype.runCanDeactivate = /**\n     * @param {?} component\n     * @param {?} curr\n     * @return {?}\n     */\n    function (component, curr) {\n        var _this = this;\n        var /** @type {?} */ canDeactivate = curr && curr.routeConfig ? curr.routeConfig.canDeactivate : null;\n        if (!canDeactivate || canDeactivate.length === 0)\n            return Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_of__[\"of\"])(true);\n        var /** @type {?} */ canDeactivate$ = __WEBPACK_IMPORTED_MODULE_8_rxjs_operator_mergeMap__[\"mergeMap\"].call(Object(__WEBPACK_IMPORTED_MODULE_10_rxjs_observable_from__[\"from\"])(canDeactivate), function (c) {\n            var /** @type {?} */ guard = _this.getToken(c, curr);\n            var /** @type {?} */ observable;\n            if (guard.canDeactivate) {\n                observable =\n                    wrapIntoObservable(guard.canDeactivate(component, curr, _this.curr, _this.future));\n            }\n            else {\n                observable = wrapIntoObservable(guard(component, curr, _this.curr, _this.future));\n            }\n            return __WEBPACK_IMPORTED_MODULE_13_rxjs_operator_first__[\"first\"].call(observable);\n        });\n        return __WEBPACK_IMPORTED_MODULE_16_rxjs_operator_every__[\"every\"].call(canDeactivate$, function (result) { return result === true; });\n    };\n    /**\n     * @param {?} future\n     * @return {?}\n     */\n    PreActivation.prototype.runResolve = /**\n     * @param {?} future\n     * @return {?}\n     */\n    function (future) {\n        var /** @type {?} */ resolve = future._resolve;\n        return __WEBPACK_IMPORTED_MODULE_7_rxjs_operator_map__[\"map\"].call(this.resolveNode(resolve, future), function (resolvedData) {\n            future._resolvedData = resolvedData;\n            future.data = Object(__WEBPACK_IMPORTED_MODULE_2_tslib__[\"a\" /* __assign */])({}, future.data, inheritedParamsDataResolve(future).resolve);\n            return null;\n        });\n    };\n    /**\n     * @param {?} resolve\n     * @param {?} future\n     * @return {?}\n     */\n    PreActivation.prototype.resolveNode = /**\n     * @param {?} resolve\n     * @param {?} future\n     * @return {?}\n     */\n    function (resolve, future) {\n        var _this = this;\n        var /** @type {?} */ keys = Object.keys(resolve);\n        if (keys.length === 0) {\n            return Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_of__[\"of\"])({});\n        }\n        if (keys.length === 1) {\n            var /** @type {?} */ key_1 = keys[0];\n            return __WEBPACK_IMPORTED_MODULE_7_rxjs_operator_map__[\"map\"].call(this.getResolver(resolve[key_1], future), function (value) {\n                return _a = {}, _a[key_1] = value, _a;\n                var _a;\n            });\n        }\n        var /** @type {?} */ data = {};\n        var /** @type {?} */ runningResolvers$ = __WEBPACK_IMPORTED_MODULE_8_rxjs_operator_mergeMap__[\"mergeMap\"].call(Object(__WEBPACK_IMPORTED_MODULE_10_rxjs_observable_from__[\"from\"])(keys), function (key) {\n            return __WEBPACK_IMPORTED_MODULE_7_rxjs_operator_map__[\"map\"].call(_this.getResolver(resolve[key], future), function (value) {\n                data[key] = value;\n                return value;\n            });\n        });\n        return __WEBPACK_IMPORTED_MODULE_7_rxjs_operator_map__[\"map\"].call(__WEBPACK_IMPORTED_MODULE_17_rxjs_operator_last__[\"last\"].call(runningResolvers$), function () { return data; });\n    };\n    /**\n     * @param {?} injectionToken\n     * @param {?} future\n     * @return {?}\n     */\n    PreActivation.prototype.getResolver = /**\n     * @param {?} injectionToken\n     * @param {?} future\n     * @return {?}\n     */\n    function (injectionToken, future) {\n        var /** @type {?} */ resolver = this.getToken(injectionToken, future);\n        return resolver.resolve ? wrapIntoObservable(resolver.resolve(future, this.future)) :\n            wrapIntoObservable(resolver(future, this.future));\n    };\n    /**\n     * @param {?} token\n     * @param {?} snapshot\n     * @return {?}\n     */\n    PreActivation.prototype.getToken = /**\n     * @param {?} token\n     * @param {?} snapshot\n     * @return {?}\n     */\n    function (token, snapshot) {\n        var /** @type {?} */ config = closestLoadedConfig(snapshot);\n        var /** @type {?} */ injector = config ? config.module.injector : this.moduleInjector;\n        return injector.get(token);\n    };\n    return PreActivation;\n}());\n/**\n * @param {?} snapshot\n * @return {?}\n */\nfunction closestLoadedConfig(snapshot) {\n    if (!snapshot)\n        return null;\n    for (var /** @type {?} */ s = snapshot.parent; s; s = s.parent) {\n        var /** @type {?} */ route = s.routeConfig;\n        if (route && route._loadedConfig)\n            return route._loadedConfig;\n    }\n    return null;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar NoMatch$1 = (function () {\n    function NoMatch() {\n    }\n    return NoMatch;\n}());\n/**\n * @param {?} rootComponentType\n * @param {?} config\n * @param {?} urlTree\n * @param {?} url\n * @return {?}\n */\nfunction recognize(rootComponentType, config, urlTree, url) {\n    return new Recognizer(rootComponentType, config, urlTree, url).recognize();\n}\nvar Recognizer = (function () {\n    function Recognizer(rootComponentType, config, urlTree, url) {\n        this.rootComponentType = rootComponentType;\n        this.config = config;\n        this.urlTree = urlTree;\n        this.url = url;\n    }\n    /**\n     * @return {?}\n     */\n    Recognizer.prototype.recognize = /**\n     * @return {?}\n     */\n    function () {\n        try {\n            var /** @type {?} */ rootSegmentGroup = split$1(this.urlTree.root, [], [], this.config).segmentGroup;\n            var /** @type {?} */ children = this.processSegmentGroup(this.config, rootSegmentGroup, PRIMARY_OUTLET);\n            var /** @type {?} */ root = new ActivatedRouteSnapshot([], Object.freeze({}), Object.freeze(this.urlTree.queryParams), /** @type {?} */ ((this.urlTree.fragment)), {}, PRIMARY_OUTLET, this.rootComponentType, null, this.urlTree.root, -1, {});\n            var /** @type {?} */ rootNode = new TreeNode(root, children);\n            var /** @type {?} */ routeState = new RouterStateSnapshot(this.url, rootNode);\n            this.inheritParamsAndData(routeState._root);\n            return Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_of__[\"of\"])(routeState);\n        }\n        catch (/** @type {?} */ e) {\n            return new __WEBPACK_IMPORTED_MODULE_9_rxjs_Observable__[\"Observable\"](function (obs) { return obs.error(e); });\n        }\n    };\n    /**\n     * @param {?} routeNode\n     * @return {?}\n     */\n    Recognizer.prototype.inheritParamsAndData = /**\n     * @param {?} routeNode\n     * @return {?}\n     */\n    function (routeNode) {\n        var _this = this;\n        var /** @type {?} */ route = routeNode.value;\n        var /** @type {?} */ i = inheritedParamsDataResolve(route);\n        route.params = Object.freeze(i.params);\n        route.data = Object.freeze(i.data);\n        routeNode.children.forEach(function (n) { return _this.inheritParamsAndData(n); });\n    };\n    /**\n     * @param {?} config\n     * @param {?} segmentGroup\n     * @param {?} outlet\n     * @return {?}\n     */\n    Recognizer.prototype.processSegmentGroup = /**\n     * @param {?} config\n     * @param {?} segmentGroup\n     * @param {?} outlet\n     * @return {?}\n     */\n    function (config, segmentGroup, outlet) {\n        if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n            return this.processChildren(config, segmentGroup);\n        }\n        return this.processSegment(config, segmentGroup, segmentGroup.segments, outlet);\n    };\n    /**\n     * @param {?} config\n     * @param {?} segmentGroup\n     * @return {?}\n     */\n    Recognizer.prototype.processChildren = /**\n     * @param {?} config\n     * @param {?} segmentGroup\n     * @return {?}\n     */\n    function (config, segmentGroup) {\n        var _this = this;\n        var /** @type {?} */ children = mapChildrenIntoArray(segmentGroup, function (child, childOutlet) { return _this.processSegmentGroup(config, child, childOutlet); });\n        checkOutletNameUniqueness(children);\n        sortActivatedRouteSnapshots(children);\n        return children;\n    };\n    /**\n     * @param {?} config\n     * @param {?} segmentGroup\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n    Recognizer.prototype.processSegment = /**\n     * @param {?} config\n     * @param {?} segmentGroup\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n    function (config, segmentGroup, segments, outlet) {\n        for (var _i = 0, config_1 = config; _i < config_1.length; _i++) {\n            var r = config_1[_i];\n            try {\n                return this.processSegmentAgainstRoute(r, segmentGroup, segments, outlet);\n            }\n            catch (/** @type {?} */ e) {\n                if (!(e instanceof NoMatch$1))\n                    throw e;\n            }\n        }\n        if (this.noLeftoversInUrl(segmentGroup, segments, outlet)) {\n            return [];\n        }\n        throw new NoMatch$1();\n    };\n    /**\n     * @param {?} segmentGroup\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n    Recognizer.prototype.noLeftoversInUrl = /**\n     * @param {?} segmentGroup\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n    function (segmentGroup, segments, outlet) {\n        return segments.length === 0 && !segmentGroup.children[outlet];\n    };\n    /**\n     * @param {?} route\n     * @param {?} rawSegment\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n    Recognizer.prototype.processSegmentAgainstRoute = /**\n     * @param {?} route\n     * @param {?} rawSegment\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n    function (route, rawSegment, segments, outlet) {\n        if (route.redirectTo)\n            throw new NoMatch$1();\n        if ((route.outlet || PRIMARY_OUTLET) !== outlet)\n            throw new NoMatch$1();\n        if (route.path === '**') {\n            var /** @type {?} */ params = segments.length > 0 ? /** @type {?} */ ((last$1(segments))).parameters : {};\n            var /** @type {?} */ snapshot_1 = new ActivatedRouteSnapshot(segments, params, Object.freeze(this.urlTree.queryParams), /** @type {?} */ ((this.urlTree.fragment)), getData(route), outlet, /** @type {?} */ ((route.component)), route, getSourceSegmentGroup(rawSegment), getPathIndexShift(rawSegment) + segments.length, getResolve(route));\n            return [new TreeNode(snapshot_1, [])];\n        }\n        var _a = match$1(rawSegment, route, segments), consumedSegments = _a.consumedSegments, parameters = _a.parameters, lastChild = _a.lastChild;\n        var /** @type {?} */ rawSlicedSegments = segments.slice(lastChild);\n        var /** @type {?} */ childConfig = getChildConfig(route);\n        var _b = split$1(rawSegment, consumedSegments, rawSlicedSegments, childConfig), segmentGroup = _b.segmentGroup, slicedSegments = _b.slicedSegments;\n        var /** @type {?} */ snapshot = new ActivatedRouteSnapshot(consumedSegments, parameters, Object.freeze(this.urlTree.queryParams), /** @type {?} */ ((this.urlTree.fragment)), getData(route), outlet, /** @type {?} */ ((route.component)), route, getSourceSegmentGroup(rawSegment), getPathIndexShift(rawSegment) + consumedSegments.length, getResolve(route));\n        if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {\n            var /** @type {?} */ children_1 = this.processChildren(childConfig, segmentGroup);\n            return [new TreeNode(snapshot, children_1)];\n        }\n        if (childConfig.length === 0 && slicedSegments.length === 0) {\n            return [new TreeNode(snapshot, [])];\n        }\n        var /** @type {?} */ children = this.processSegment(childConfig, segmentGroup, slicedSegments, PRIMARY_OUTLET);\n        return [new TreeNode(snapshot, children)];\n    };\n    return Recognizer;\n}());\n/**\n * @param {?} nodes\n * @return {?}\n */\nfunction sortActivatedRouteSnapshots(nodes) {\n    nodes.sort(function (a, b) {\n        if (a.value.outlet === PRIMARY_OUTLET)\n            return -1;\n        if (b.value.outlet === PRIMARY_OUTLET)\n            return 1;\n        return a.value.outlet.localeCompare(b.value.outlet);\n    });\n}\n/**\n * @param {?} route\n * @return {?}\n */\nfunction getChildConfig(route) {\n    if (route.children) {\n        return route.children;\n    }\n    if (route.loadChildren) {\n        return /** @type {?} */ ((route._loadedConfig)).routes;\n    }\n    return [];\n}\n/**\n * @param {?} segmentGroup\n * @param {?} route\n * @param {?} segments\n * @return {?}\n */\nfunction match$1(segmentGroup, route, segments) {\n    if (route.path === '') {\n        if (route.pathMatch === 'full' && (segmentGroup.hasChildren() || segments.length > 0)) {\n            throw new NoMatch$1();\n        }\n        return { consumedSegments: [], lastChild: 0, parameters: {} };\n    }\n    var /** @type {?} */ matcher = route.matcher || defaultUrlMatcher;\n    var /** @type {?} */ res = matcher(segments, segmentGroup, route);\n    if (!res)\n        throw new NoMatch$1();\n    var /** @type {?} */ posParams = {};\n    forEach(/** @type {?} */ ((res.posParams)), function (v, k) { posParams[k] = v.path; });\n    var /** @type {?} */ parameters = res.consumed.length > 0 ? Object(__WEBPACK_IMPORTED_MODULE_2_tslib__[\"a\" /* __assign */])({}, posParams, res.consumed[res.consumed.length - 1].parameters) :\n        posParams;\n    return { consumedSegments: res.consumed, lastChild: res.consumed.length, parameters: parameters };\n}\n/**\n * @param {?} nodes\n * @return {?}\n */\nfunction checkOutletNameUniqueness(nodes) {\n    var /** @type {?} */ names = {};\n    nodes.forEach(function (n) {\n        var /** @type {?} */ routeWithSameOutletName = names[n.value.outlet];\n        if (routeWithSameOutletName) {\n            var /** @type {?} */ p = routeWithSameOutletName.url.map(function (s) { return s.toString(); }).join('/');\n            var /** @type {?} */ c = n.value.url.map(function (s) { return s.toString(); }).join('/');\n            throw new Error(\"Two segments cannot have the same outlet name: '\" + p + \"' and '\" + c + \"'.\");\n        }\n        names[n.value.outlet] = n.value;\n    });\n}\n/**\n * @param {?} segmentGroup\n * @return {?}\n */\nfunction getSourceSegmentGroup(segmentGroup) {\n    var /** @type {?} */ s = segmentGroup;\n    while (s._sourceSegment) {\n        s = s._sourceSegment;\n    }\n    return s;\n}\n/**\n * @param {?} segmentGroup\n * @return {?}\n */\nfunction getPathIndexShift(segmentGroup) {\n    var /** @type {?} */ s = segmentGroup;\n    var /** @type {?} */ res = (s._segmentIndexShift ? s._segmentIndexShift : 0);\n    while (s._sourceSegment) {\n        s = s._sourceSegment;\n        res += (s._segmentIndexShift ? s._segmentIndexShift : 0);\n    }\n    return res - 1;\n}\n/**\n * @param {?} segmentGroup\n * @param {?} consumedSegments\n * @param {?} slicedSegments\n * @param {?} config\n * @return {?}\n */\nfunction split$1(segmentGroup, consumedSegments, slicedSegments, config) {\n    if (slicedSegments.length > 0 &&\n        containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, config)) {\n        var /** @type {?} */ s_1 = new UrlSegmentGroup(consumedSegments, createChildrenForEmptyPaths(segmentGroup, consumedSegments, config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));\n        s_1._sourceSegment = segmentGroup;\n        s_1._segmentIndexShift = consumedSegments.length;\n        return { segmentGroup: s_1, slicedSegments: [] };\n    }\n    if (slicedSegments.length === 0 &&\n        containsEmptyPathMatches(segmentGroup, slicedSegments, config)) {\n        var /** @type {?} */ s_2 = new UrlSegmentGroup(segmentGroup.segments, addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, config, segmentGroup.children));\n        s_2._sourceSegment = segmentGroup;\n        s_2._segmentIndexShift = consumedSegments.length;\n        return { segmentGroup: s_2, slicedSegments: slicedSegments };\n    }\n    var /** @type {?} */ s = new UrlSegmentGroup(segmentGroup.segments, segmentGroup.children);\n    s._sourceSegment = segmentGroup;\n    s._segmentIndexShift = consumedSegments.length;\n    return { segmentGroup: s, slicedSegments: slicedSegments };\n}\n/**\n * @param {?} segmentGroup\n * @param {?} slicedSegments\n * @param {?} routes\n * @param {?} children\n * @return {?}\n */\nfunction addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, routes, children) {\n    var /** @type {?} */ res = {};\n    for (var _i = 0, routes_1 = routes; _i < routes_1.length; _i++) {\n        var r = routes_1[_i];\n        if (emptyPathMatch(segmentGroup, slicedSegments, r) && !children[getOutlet$1(r)]) {\n            var /** @type {?} */ s = new UrlSegmentGroup([], {});\n            s._sourceSegment = segmentGroup;\n            s._segmentIndexShift = segmentGroup.segments.length;\n            res[getOutlet$1(r)] = s;\n        }\n    }\n    return Object(__WEBPACK_IMPORTED_MODULE_2_tslib__[\"a\" /* __assign */])({}, children, res);\n}\n/**\n * @param {?} segmentGroup\n * @param {?} consumedSegments\n * @param {?} routes\n * @param {?} primarySegment\n * @return {?}\n */\nfunction createChildrenForEmptyPaths(segmentGroup, consumedSegments, routes, primarySegment) {\n    var /** @type {?} */ res = {};\n    res[PRIMARY_OUTLET] = primarySegment;\n    primarySegment._sourceSegment = segmentGroup;\n    primarySegment._segmentIndexShift = consumedSegments.length;\n    for (var _i = 0, routes_2 = routes; _i < routes_2.length; _i++) {\n        var r = routes_2[_i];\n        if (r.path === '' && getOutlet$1(r) !== PRIMARY_OUTLET) {\n            var /** @type {?} */ s = new UrlSegmentGroup([], {});\n            s._sourceSegment = segmentGroup;\n            s._segmentIndexShift = consumedSegments.length;\n            res[getOutlet$1(r)] = s;\n        }\n    }\n    return res;\n}\n/**\n * @param {?} segmentGroup\n * @param {?} slicedSegments\n * @param {?} routes\n * @return {?}\n */\nfunction containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, routes) {\n    return routes.some(function (r) { return emptyPathMatch(segmentGroup, slicedSegments, r) && getOutlet$1(r) !== PRIMARY_OUTLET; });\n}\n/**\n * @param {?} segmentGroup\n * @param {?} slicedSegments\n * @param {?} routes\n * @return {?}\n */\nfunction containsEmptyPathMatches(segmentGroup, slicedSegments, routes) {\n    return routes.some(function (r) { return emptyPathMatch(segmentGroup, slicedSegments, r); });\n}\n/**\n * @param {?} segmentGroup\n * @param {?} slicedSegments\n * @param {?} r\n * @return {?}\n */\nfunction emptyPathMatch(segmentGroup, slicedSegments, r) {\n    if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r.pathMatch === 'full') {\n        return false;\n    }\n    return r.path === '' && r.redirectTo === undefined;\n}\n/**\n * @param {?} route\n * @return {?}\n */\nfunction getOutlet$1(route) {\n    return route.outlet || PRIMARY_OUTLET;\n}\n/**\n * @param {?} route\n * @return {?}\n */\nfunction getData(route) {\n    return route.data || {};\n}\n/**\n * @param {?} route\n * @return {?}\n */\nfunction getResolve(route) {\n    return route.resolve || {};\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * \\@whatItDoes Provides a way to customize when activated routes get reused.\n *\n * \\@experimental\n * @abstract\n */\nvar RouteReuseStrategy = (function () {\n    function RouteReuseStrategy() {\n    }\n    return RouteReuseStrategy;\n}());\n/**\n * Does not detach any subtrees. Reuses routes as long as their route config is the same.\n */\nvar DefaultRouteReuseStrategy = (function () {\n    function DefaultRouteReuseStrategy() {\n    }\n    /**\n     * @param {?} route\n     * @return {?}\n     */\n    DefaultRouteReuseStrategy.prototype.shouldDetach = /**\n     * @param {?} route\n     * @return {?}\n     */\n    function (route) { return false; };\n    /**\n     * @param {?} route\n     * @param {?} detachedTree\n     * @return {?}\n     */\n    DefaultRouteReuseStrategy.prototype.store = /**\n     * @param {?} route\n     * @param {?} detachedTree\n     * @return {?}\n     */\n    function (route, detachedTree) { };\n    /**\n     * @param {?} route\n     * @return {?}\n     */\n    DefaultRouteReuseStrategy.prototype.shouldAttach = /**\n     * @param {?} route\n     * @return {?}\n     */\n    function (route) { return false; };\n    /**\n     * @param {?} route\n     * @return {?}\n     */\n    DefaultRouteReuseStrategy.prototype.retrieve = /**\n     * @param {?} route\n     * @return {?}\n     */\n    function (route) { return null; };\n    /**\n     * @param {?} future\n     * @param {?} curr\n     * @return {?}\n     */\n    DefaultRouteReuseStrategy.prototype.shouldReuseRoute = /**\n     * @param {?} future\n     * @param {?} curr\n     * @return {?}\n     */\n    function (future, curr) {\n        return future.routeConfig === curr.routeConfig;\n    };\n    return DefaultRouteReuseStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * \\@docsNotRequired\n * \\@experimental\n */\nvar ROUTES = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"InjectionToken\"]('ROUTES');\nvar RouterConfigLoader = (function () {\n    function RouterConfigLoader(loader, compiler, onLoadStartListener, onLoadEndListener) {\n        this.loader = loader;\n        this.compiler = compiler;\n        this.onLoadStartListener = onLoadStartListener;\n        this.onLoadEndListener = onLoadEndListener;\n    }\n    /**\n     * @param {?} parentInjector\n     * @param {?} route\n     * @return {?}\n     */\n    RouterConfigLoader.prototype.load = /**\n     * @param {?} parentInjector\n     * @param {?} route\n     * @return {?}\n     */\n    function (parentInjector, route) {\n        var _this = this;\n        if (this.onLoadStartListener) {\n            this.onLoadStartListener(route);\n        }\n        var /** @type {?} */ moduleFactory$ = this.loadModuleFactory(/** @type {?} */ ((route.loadChildren)));\n        return __WEBPACK_IMPORTED_MODULE_7_rxjs_operator_map__[\"map\"].call(moduleFactory$, function (factory) {\n            if (_this.onLoadEndListener) {\n                _this.onLoadEndListener(route);\n            }\n            var /** @type {?} */ module = factory.create(parentInjector);\n            return new LoadedRouterConfig(flatten(module.injector.get(ROUTES)), module);\n        });\n    };\n    /**\n     * @param {?} loadChildren\n     * @return {?}\n     */\n    RouterConfigLoader.prototype.loadModuleFactory = /**\n     * @param {?} loadChildren\n     * @return {?}\n     */\n    function (loadChildren) {\n        var _this = this;\n        if (typeof loadChildren === 'string') {\n            return Object(__WEBPACK_IMPORTED_MODULE_15_rxjs_observable_fromPromise__[\"fromPromise\"])(this.loader.load(loadChildren));\n        }\n        else {\n            return __WEBPACK_IMPORTED_MODULE_8_rxjs_operator_mergeMap__[\"mergeMap\"].call(wrapIntoObservable(loadChildren()), function (t) {\n                if (t instanceof __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModuleFactory\"]) {\n                    return Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_of__[\"of\"])(t);\n                }\n                else {\n                    return Object(__WEBPACK_IMPORTED_MODULE_15_rxjs_observable_fromPromise__[\"fromPromise\"])(_this.compiler.compileModuleAsync(t));\n                }\n            });\n        }\n    };\n    return RouterConfigLoader;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * \\@whatItDoes Provides a way to migrate AngularJS applications to Angular.\n *\n * \\@experimental\n * @abstract\n */\nvar UrlHandlingStrategy = (function () {\n    function UrlHandlingStrategy() {\n    }\n    return UrlHandlingStrategy;\n}());\n/**\n * \\@experimental\n */\nvar DefaultUrlHandlingStrategy = (function () {\n    function DefaultUrlHandlingStrategy() {\n    }\n    /**\n     * @param {?} url\n     * @return {?}\n     */\n    DefaultUrlHandlingStrategy.prototype.shouldProcessUrl = /**\n     * @param {?} url\n     * @return {?}\n     */\n    function (url) { return true; };\n    /**\n     * @param {?} url\n     * @return {?}\n     */\n    DefaultUrlHandlingStrategy.prototype.extract = /**\n     * @param {?} url\n     * @return {?}\n     */\n    function (url) { return url; };\n    /**\n     * @param {?} newUrlPart\n     * @param {?} wholeUrl\n     * @return {?}\n     */\n    DefaultUrlHandlingStrategy.prototype.merge = /**\n     * @param {?} newUrlPart\n     * @param {?} wholeUrl\n     * @return {?}\n     */\n    function (newUrlPart, wholeUrl) { return newUrlPart; };\n    return DefaultUrlHandlingStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * \\@whatItDoes Represents the extra options used during navigation.\n *\n * \\@stable\n * @record\n */\n\n/**\n * @param {?} error\n * @return {?}\n */\nfunction defaultErrorHandler(error) {\n    throw error;\n}\n/**\n * \\@internal\n * @param {?} snapshot\n * @return {?}\n */\nfunction defaultRouterHook(snapshot) {\n    return /** @type {?} */ (Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_of__[\"of\"])(null));\n}\n/**\n * \\@whatItDoes Provides the navigation and url manipulation capabilities.\n *\n * See {\\@link Routes} for more details and examples.\n *\n * \\@ngModule RouterModule\n *\n * \\@stable\n */\nvar Router = (function () {\n    /**\n     * Creates the router service.\n     */\n    // TODO: vsavkin make internal after the final is out.\n    function Router(rootComponentType, urlSerializer, rootContexts, location, injector, loader, compiler, config) {\n        var _this = this;\n        this.rootComponentType = rootComponentType;\n        this.urlSerializer = urlSerializer;\n        this.rootContexts = rootContexts;\n        this.location = location;\n        this.config = config;\n        this.navigations = new __WEBPACK_IMPORTED_MODULE_3_rxjs_BehaviorSubject__[\"BehaviorSubject\"](/** @type {?} */ ((null)));\n        this.navigationId = 0;\n        this.events = new __WEBPACK_IMPORTED_MODULE_4_rxjs_Subject__[\"Subject\"]();\n        /**\n         * Error handler that is invoked when a navigation errors.\n         *\n         * See {\\@link ErrorHandler} for more information.\n         */\n        this.errorHandler = defaultErrorHandler;\n        /**\n         * Indicates if at least one navigation happened.\n         */\n        this.navigated = false;\n        /**\n         * Used by RouterModule. This allows us to\n         * pause the navigation either before preactivation or after it.\n         * \\@internal\n         */\n        this.hooks = {\n            beforePreactivation: defaultRouterHook,\n            afterPreactivation: defaultRouterHook\n        };\n        /**\n         * Extracts and merges URLs. Used for AngularJS to Angular migrations.\n         */\n        this.urlHandlingStrategy = new DefaultUrlHandlingStrategy();\n        this.routeReuseStrategy = new DefaultRouteReuseStrategy();\n        var /** @type {?} */ onLoadStart = function (r) { return _this.triggerEvent(new RouteConfigLoadStart(r)); };\n        var /** @type {?} */ onLoadEnd = function (r) { return _this.triggerEvent(new RouteConfigLoadEnd(r)); };\n        this.ngModule = injector.get(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModuleRef\"]);\n        this.resetConfig(config);\n        this.currentUrlTree = createEmptyUrlTree();\n        this.rawUrlTree = this.currentUrlTree;\n        this.configLoader = new RouterConfigLoader(loader, compiler, onLoadStart, onLoadEnd);\n        this.routerState = createEmptyState(this.currentUrlTree, this.rootComponentType);\n        this.processNavigations();\n    }\n    /**\n     * @internal\n     * TODO: this should be removed once the constructor of the router made internal\n     */\n    /**\n     * \\@internal\n     * TODO: this should be removed once the constructor of the router made internal\n     * @param {?} rootComponentType\n     * @return {?}\n     */\n    Router.prototype.resetRootComponentType = /**\n     * \\@internal\n     * TODO: this should be removed once the constructor of the router made internal\n     * @param {?} rootComponentType\n     * @return {?}\n     */\n    function (rootComponentType) {\n        this.rootComponentType = rootComponentType;\n        // TODO: vsavkin router 4.0 should make the root component set to null\n        // this will simplify the lifecycle of the router.\n        this.routerState.root.component = this.rootComponentType;\n    };\n    /**\n     * Sets up the location change listener and performs the initial navigation.\n     */\n    /**\n     * Sets up the location change listener and performs the initial navigation.\n     * @return {?}\n     */\n    Router.prototype.initialNavigation = /**\n     * Sets up the location change listener and performs the initial navigation.\n     * @return {?}\n     */\n    function () {\n        this.setUpLocationChangeListener();\n        if (this.navigationId === 0) {\n            this.navigateByUrl(this.location.path(true), { replaceUrl: true });\n        }\n    };\n    /**\n     * Sets up the location change listener.\n     */\n    /**\n     * Sets up the location change listener.\n     * @return {?}\n     */\n    Router.prototype.setUpLocationChangeListener = /**\n     * Sets up the location change listener.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        // Zone.current.wrap is needed because of the issue with RxJS scheduler,\n        // which does not work properly with zone.js in IE and Safari\n        if (!this.locationSubscription) {\n            this.locationSubscription = /** @type {?} */ (this.location.subscribe(Zone.current.wrap(function (change) {\n                var /** @type {?} */ rawUrlTree = _this.urlSerializer.parse(change['url']);\n                var /** @type {?} */ source = change['type'] === 'popstate' ? 'popstate' : 'hashchange';\n                setTimeout(function () { _this.scheduleNavigation(rawUrlTree, source, { replaceUrl: true }); }, 0);\n            })));\n        }\n    };\n    Object.defineProperty(Router.prototype, \"url\", {\n        /** The current url */\n        get: /**\n         * The current url\n         * @return {?}\n         */\n        function () { return this.serializeUrl(this.currentUrlTree); },\n        enumerable: true,\n        configurable: true\n    });\n    /** @internal */\n    /**\n     * \\@internal\n     * @param {?} e\n     * @return {?}\n     */\n    Router.prototype.triggerEvent = /**\n     * \\@internal\n     * @param {?} e\n     * @return {?}\n     */\n    function (e) { (/** @type {?} */ (this.events)).next(e); };\n    /**\n     * Resets the configuration used for navigation and generating links.\n     *\n     * ### Usage\n     *\n     * ```\n     * router.resetConfig([\n     *  { path: 'team/:id', component: TeamCmp, children: [\n     *    { path: 'simple', component: SimpleCmp },\n     *    { path: 'user/:name', component: UserCmp }\n     *  ]}\n     * ]);\n     * ```\n     */\n    /**\n     * Resets the configuration used for navigation and generating links.\n     *\n     * ### Usage\n     *\n     * ```\n     * router.resetConfig([\n     *  { path: 'team/:id', component: TeamCmp, children: [\n     *    { path: 'simple', component: SimpleCmp },\n     *    { path: 'user/:name', component: UserCmp }\n     *  ]}\n     * ]);\n     * ```\n     * @param {?} config\n     * @return {?}\n     */\n    Router.prototype.resetConfig = /**\n     * Resets the configuration used for navigation and generating links.\n     *\n     * ### Usage\n     *\n     * ```\n     * router.resetConfig([\n     *  { path: 'team/:id', component: TeamCmp, children: [\n     *    { path: 'simple', component: SimpleCmp },\n     *    { path: 'user/:name', component: UserCmp }\n     *  ]}\n     * ]);\n     * ```\n     * @param {?} config\n     * @return {?}\n     */\n    function (config) {\n        validateConfig(config);\n        this.config = config;\n        this.navigated = false;\n    };\n    /** @docsNotRequired */\n    /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    Router.prototype.ngOnDestroy = /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    function () { this.dispose(); };\n    /** Disposes of the router */\n    /**\n     * Disposes of the router\n     * @return {?}\n     */\n    Router.prototype.dispose = /**\n     * Disposes of the router\n     * @return {?}\n     */\n    function () {\n        if (this.locationSubscription) {\n            this.locationSubscription.unsubscribe();\n            this.locationSubscription = /** @type {?} */ ((null));\n        }\n    };\n    /**\n     * Applies an array of commands to the current url tree and creates a new url tree.\n     *\n     * When given an activate route, applies the given commands starting from the route.\n     * When not given a route, applies the given command starting from the root.\n     *\n     * ### Usage\n     *\n     * ```\n     * // create /team/33/user/11\n     * router.createUrlTree(['/team', 33, 'user', 11]);\n     *\n     * // create /team/33;expand=true/user/11\n     * router.createUrlTree(['/team', 33, {expand: true}, 'user', 11]);\n     *\n     * // you can collapse static segments like this (this works only with the first passed-in value):\n     * router.createUrlTree(['/team/33/user', userId]);\n     *\n     * // If the first segment can contain slashes, and you do not want the router to split it, you\n     * // can do the following:\n     *\n     * router.createUrlTree([{segmentPath: '/one/two'}]);\n     *\n     * // create /team/33/(user/11//right:chat)\n     * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: 'chat'}}]);\n     *\n     * // remove the right secondary node\n     * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: null}}]);\n     *\n     * // assuming the current url is `/team/33/user/11` and the route points to `user/11`\n     *\n     * // navigate to /team/33/user/11/details\n     * router.createUrlTree(['details'], {relativeTo: route});\n     *\n     * // navigate to /team/33/user/22\n     * router.createUrlTree(['../22'], {relativeTo: route});\n     *\n     * // navigate to /team/44/user/22\n     * router.createUrlTree(['../../team/44/user/22'], {relativeTo: route});\n     * ```\n     */\n    /**\n     * Applies an array of commands to the current url tree and creates a new url tree.\n     *\n     * When given an activate route, applies the given commands starting from the route.\n     * When not given a route, applies the given command starting from the root.\n     *\n     * ### Usage\n     *\n     * ```\n     * // create /team/33/user/11\n     * router.createUrlTree(['/team', 33, 'user', 11]);\n     *\n     * // create /team/33;expand=true/user/11\n     * router.createUrlTree(['/team', 33, {expand: true}, 'user', 11]);\n     *\n     * // you can collapse static segments like this (this works only with the first passed-in value):\n     * router.createUrlTree(['/team/33/user', userId]);\n     *\n     * // If the first segment can contain slashes, and you do not want the router to split it, you\n     * // can do the following:\n     *\n     * router.createUrlTree([{segmentPath: '/one/two'}]);\n     *\n     * // create /team/33/(user/11//right:chat)\n     * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: 'chat'}}]);\n     *\n     * // remove the right secondary node\n     * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: null}}]);\n     *\n     * // assuming the current url is `/team/33/user/11` and the route points to `user/11`\n     *\n     * // navigate to /team/33/user/11/details\n     * router.createUrlTree(['details'], {relativeTo: route});\n     *\n     * // navigate to /team/33/user/22\n     * router.createUrlTree(['../22'], {relativeTo: route});\n     *\n     * // navigate to /team/44/user/22\n     * router.createUrlTree(['../../team/44/user/22'], {relativeTo: route});\n     * ```\n     * @param {?} commands\n     * @param {?=} navigationExtras\n     * @return {?}\n     */\n    Router.prototype.createUrlTree = /**\n     * Applies an array of commands to the current url tree and creates a new url tree.\n     *\n     * When given an activate route, applies the given commands starting from the route.\n     * When not given a route, applies the given command starting from the root.\n     *\n     * ### Usage\n     *\n     * ```\n     * // create /team/33/user/11\n     * router.createUrlTree(['/team', 33, 'user', 11]);\n     *\n     * // create /team/33;expand=true/user/11\n     * router.createUrlTree(['/team', 33, {expand: true}, 'user', 11]);\n     *\n     * // you can collapse static segments like this (this works only with the first passed-in value):\n     * router.createUrlTree(['/team/33/user', userId]);\n     *\n     * // If the first segment can contain slashes, and you do not want the router to split it, you\n     * // can do the following:\n     *\n     * router.createUrlTree([{segmentPath: '/one/two'}]);\n     *\n     * // create /team/33/(user/11//right:chat)\n     * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: 'chat'}}]);\n     *\n     * // remove the right secondary node\n     * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: null}}]);\n     *\n     * // assuming the current url is `/team/33/user/11` and the route points to `user/11`\n     *\n     * // navigate to /team/33/user/11/details\n     * router.createUrlTree(['details'], {relativeTo: route});\n     *\n     * // navigate to /team/33/user/22\n     * router.createUrlTree(['../22'], {relativeTo: route});\n     *\n     * // navigate to /team/44/user/22\n     * router.createUrlTree(['../../team/44/user/22'], {relativeTo: route});\n     * ```\n     * @param {?} commands\n     * @param {?=} navigationExtras\n     * @return {?}\n     */\n    function (commands, navigationExtras) {\n        if (navigationExtras === void 0) { navigationExtras = {}; }\n        var relativeTo = navigationExtras.relativeTo, queryParams = navigationExtras.queryParams, fragment = navigationExtras.fragment, preserveQueryParams = navigationExtras.preserveQueryParams, queryParamsHandling = navigationExtras.queryParamsHandling, preserveFragment = navigationExtras.preserveFragment;\n        if (Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"isDevMode\"])() && preserveQueryParams && /** @type {?} */ (console) && /** @type {?} */ (console.warn)) {\n            console.warn('preserveQueryParams is deprecated, use queryParamsHandling instead.');\n        }\n        var /** @type {?} */ a = relativeTo || this.routerState.root;\n        var /** @type {?} */ f = preserveFragment ? this.currentUrlTree.fragment : fragment;\n        var /** @type {?} */ q = null;\n        if (queryParamsHandling) {\n            switch (queryParamsHandling) {\n                case 'merge':\n                    q = Object(__WEBPACK_IMPORTED_MODULE_2_tslib__[\"a\" /* __assign */])({}, this.currentUrlTree.queryParams, queryParams);\n                    break;\n                case 'preserve':\n                    q = this.currentUrlTree.queryParams;\n                    break;\n                default:\n                    q = queryParams || null;\n            }\n        }\n        else {\n            q = preserveQueryParams ? this.currentUrlTree.queryParams : queryParams || null;\n        }\n        return createUrlTree(a, this.currentUrlTree, commands, /** @type {?} */ ((q)), /** @type {?} */ ((f)));\n    };\n    /**\n     * Navigate based on the provided url. This navigation is always absolute.\n     *\n     * Returns a promise that:\n     * - resolves to 'true' when navigation succeeds,\n     * - resolves to 'false' when navigation fails,\n     * - is rejected when an error happens.\n     *\n     * ### Usage\n     *\n     * ```\n     * router.navigateByUrl(\"/team/33/user/11\");\n     *\n     * // Navigate without updating the URL\n     * router.navigateByUrl(\"/team/33/user/11\", { skipLocationChange: true });\n     * ```\n     *\n     * In opposite to `navigate`, `navigateByUrl` takes a whole URL\n     * and does not apply any delta to the current one.\n     */\n    /**\n     * Navigate based on the provided url. This navigation is always absolute.\n     *\n     * Returns a promise that:\n     * - resolves to 'true' when navigation succeeds,\n     * - resolves to 'false' when navigation fails,\n     * - is rejected when an error happens.\n     *\n     * ### Usage\n     *\n     * ```\n     * router.navigateByUrl(\"/team/33/user/11\");\n     *\n     * // Navigate without updating the URL\n     * router.navigateByUrl(\"/team/33/user/11\", { skipLocationChange: true });\n     * ```\n     *\n     * In opposite to `navigate`, `navigateByUrl` takes a whole URL\n     * and does not apply any delta to the current one.\n     * @param {?} url\n     * @param {?=} extras\n     * @return {?}\n     */\n    Router.prototype.navigateByUrl = /**\n     * Navigate based on the provided url. This navigation is always absolute.\n     *\n     * Returns a promise that:\n     * - resolves to 'true' when navigation succeeds,\n     * - resolves to 'false' when navigation fails,\n     * - is rejected when an error happens.\n     *\n     * ### Usage\n     *\n     * ```\n     * router.navigateByUrl(\"/team/33/user/11\");\n     *\n     * // Navigate without updating the URL\n     * router.navigateByUrl(\"/team/33/user/11\", { skipLocationChange: true });\n     * ```\n     *\n     * In opposite to `navigate`, `navigateByUrl` takes a whole URL\n     * and does not apply any delta to the current one.\n     * @param {?} url\n     * @param {?=} extras\n     * @return {?}\n     */\n    function (url, extras) {\n        if (extras === void 0) { extras = { skipLocationChange: false }; }\n        var /** @type {?} */ urlTree = url instanceof UrlTree ? url : this.parseUrl(url);\n        var /** @type {?} */ mergedTree = this.urlHandlingStrategy.merge(urlTree, this.rawUrlTree);\n        return this.scheduleNavigation(mergedTree, 'imperative', extras);\n    };\n    /**\n     * Navigate based on the provided array of commands and a starting point.\n     * If no starting route is provided, the navigation is absolute.\n     *\n     * Returns a promise that:\n     * - resolves to 'true' when navigation succeeds,\n     * - resolves to 'false' when navigation fails,\n     * - is rejected when an error happens.\n     *\n     * ### Usage\n     *\n     * ```\n     * router.navigate(['team', 33, 'user', 11], {relativeTo: route});\n     *\n     * // Navigate without updating the URL\n     * router.navigate(['team', 33, 'user', 11], {relativeTo: route, skipLocationChange: true});\n     * ```\n     *\n     * In opposite to `navigateByUrl`, `navigate` always takes a delta that is applied to the current\n     * URL.\n     */\n    /**\n     * Navigate based on the provided array of commands and a starting point.\n     * If no starting route is provided, the navigation is absolute.\n     *\n     * Returns a promise that:\n     * - resolves to 'true' when navigation succeeds,\n     * - resolves to 'false' when navigation fails,\n     * - is rejected when an error happens.\n     *\n     * ### Usage\n     *\n     * ```\n     * router.navigate(['team', 33, 'user', 11], {relativeTo: route});\n     *\n     * // Navigate without updating the URL\n     * router.navigate(['team', 33, 'user', 11], {relativeTo: route, skipLocationChange: true});\n     * ```\n     *\n     * In opposite to `navigateByUrl`, `navigate` always takes a delta that is applied to the current\n     * URL.\n     * @param {?} commands\n     * @param {?=} extras\n     * @return {?}\n     */\n    Router.prototype.navigate = /**\n     * Navigate based on the provided array of commands and a starting point.\n     * If no starting route is provided, the navigation is absolute.\n     *\n     * Returns a promise that:\n     * - resolves to 'true' when navigation succeeds,\n     * - resolves to 'false' when navigation fails,\n     * - is rejected when an error happens.\n     *\n     * ### Usage\n     *\n     * ```\n     * router.navigate(['team', 33, 'user', 11], {relativeTo: route});\n     *\n     * // Navigate without updating the URL\n     * router.navigate(['team', 33, 'user', 11], {relativeTo: route, skipLocationChange: true});\n     * ```\n     *\n     * In opposite to `navigateByUrl`, `navigate` always takes a delta that is applied to the current\n     * URL.\n     * @param {?} commands\n     * @param {?=} extras\n     * @return {?}\n     */\n    function (commands, extras) {\n        if (extras === void 0) { extras = { skipLocationChange: false }; }\n        validateCommands(commands);\n        if (typeof extras.queryParams === 'object' && extras.queryParams !== null) {\n            extras.queryParams = this.removeEmptyProps(extras.queryParams);\n        }\n        return this.navigateByUrl(this.createUrlTree(commands, extras), extras);\n    };\n    /** Serializes a {@link UrlTree} into a string */\n    /**\n     * Serializes a {\\@link UrlTree} into a string\n     * @param {?} url\n     * @return {?}\n     */\n    Router.prototype.serializeUrl = /**\n     * Serializes a {\\@link UrlTree} into a string\n     * @param {?} url\n     * @return {?}\n     */\n    function (url) { return this.urlSerializer.serialize(url); };\n    /** Parses a string into a {@link UrlTree} */\n    /**\n     * Parses a string into a {\\@link UrlTree}\n     * @param {?} url\n     * @return {?}\n     */\n    Router.prototype.parseUrl = /**\n     * Parses a string into a {\\@link UrlTree}\n     * @param {?} url\n     * @return {?}\n     */\n    function (url) { return this.urlSerializer.parse(url); };\n    /** Returns whether the url is activated */\n    /**\n     * Returns whether the url is activated\n     * @param {?} url\n     * @param {?} exact\n     * @return {?}\n     */\n    Router.prototype.isActive = /**\n     * Returns whether the url is activated\n     * @param {?} url\n     * @param {?} exact\n     * @return {?}\n     */\n    function (url, exact) {\n        if (url instanceof UrlTree) {\n            return containsTree(this.currentUrlTree, url, exact);\n        }\n        var /** @type {?} */ urlTree = this.urlSerializer.parse(url);\n        return containsTree(this.currentUrlTree, urlTree, exact);\n    };\n    /**\n     * @param {?} params\n     * @return {?}\n     */\n    Router.prototype.removeEmptyProps = /**\n     * @param {?} params\n     * @return {?}\n     */\n    function (params) {\n        return Object.keys(params).reduce(function (result, key) {\n            var /** @type {?} */ value = params[key];\n            if (value !== null && value !== undefined) {\n                result[key] = value;\n            }\n            return result;\n        }, {});\n    };\n    /**\n     * @return {?}\n     */\n    Router.prototype.processNavigations = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        __WEBPACK_IMPORTED_MODULE_6_rxjs_operator_concatMap__[\"concatMap\"]\n            .call(this.navigations, function (nav) {\n            if (nav) {\n                _this.executeScheduledNavigation(nav);\n                // a failed navigation should not stop the router from processing\n                // further navigations => the catch\n                return nav.promise.catch(function () { });\n            }\n            else {\n                return /** @type {?} */ (Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_of__[\"of\"])(null));\n            }\n        })\n            .subscribe(function () { });\n    };\n    /**\n     * @param {?} rawUrl\n     * @param {?} source\n     * @param {?} extras\n     * @return {?}\n     */\n    Router.prototype.scheduleNavigation = /**\n     * @param {?} rawUrl\n     * @param {?} source\n     * @param {?} extras\n     * @return {?}\n     */\n    function (rawUrl, source, extras) {\n        var /** @type {?} */ lastNavigation = this.navigations.value;\n        // If the user triggers a navigation imperatively (e.g., by using navigateByUrl),\n        // and that navigation results in 'replaceState' that leads to the same URL,\n        // we should skip those.\n        if (lastNavigation && source !== 'imperative' && lastNavigation.source === 'imperative' &&\n            lastNavigation.rawUrl.toString() === rawUrl.toString()) {\n            return Promise.resolve(true); // return value is not used\n        }\n        // Because of a bug in IE and Edge, the location class fires two events (popstate and\n        // hashchange) every single time. The second one should be ignored. Otherwise, the URL will\n        // flicker.\n        if (lastNavigation && source == 'hashchange' && lastNavigation.source === 'popstate' &&\n            lastNavigation.rawUrl.toString() === rawUrl.toString()) {\n            return Promise.resolve(true); // return value is not used\n        }\n        var /** @type {?} */ resolve = null;\n        var /** @type {?} */ reject = null;\n        var /** @type {?} */ promise = new Promise(function (res, rej) {\n            resolve = res;\n            reject = rej;\n        });\n        var /** @type {?} */ id = ++this.navigationId;\n        this.navigations.next({ id: id, source: source, rawUrl: rawUrl, extras: extras, resolve: resolve, reject: reject, promise: promise });\n        // Make sure that the error is propagated even though `processNavigations` catch\n        // handler does not rethrow\n        return promise.catch(function (e) { return Promise.reject(e); });\n    };\n    /**\n     * @param {?} __0\n     * @return {?}\n     */\n    Router.prototype.executeScheduledNavigation = /**\n     * @param {?} __0\n     * @return {?}\n     */\n    function (_a) {\n        var _this = this;\n        var id = _a.id, rawUrl = _a.rawUrl, extras = _a.extras, resolve = _a.resolve, reject = _a.reject;\n        var /** @type {?} */ url = this.urlHandlingStrategy.extract(rawUrl);\n        var /** @type {?} */ urlTransition = !this.navigated || url.toString() !== this.currentUrlTree.toString();\n        if (urlTransition && this.urlHandlingStrategy.shouldProcessUrl(rawUrl)) {\n            (/** @type {?} */ (this.events)).next(new NavigationStart(id, this.serializeUrl(url)));\n            Promise.resolve()\n                .then(function (_) {\n                return _this.runNavigate(url, rawUrl, !!extras.skipLocationChange, !!extras.replaceUrl, id, null);\n            })\n                .then(resolve, reject);\n            // we cannot process the current URL, but we could process the previous one =>\n            // we need to do some cleanup\n        }\n        else if (urlTransition && this.rawUrlTree &&\n            this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)) {\n            (/** @type {?} */ (this.events)).next(new NavigationStart(id, this.serializeUrl(url)));\n            Promise.resolve()\n                .then(function (_) {\n                return _this.runNavigate(url, rawUrl, false, false, id, createEmptyState(url, _this.rootComponentType).snapshot);\n            })\n                .then(resolve, reject);\n        }\n        else {\n            this.rawUrlTree = rawUrl;\n            resolve(null);\n        }\n    };\n    /**\n     * @param {?} url\n     * @param {?} rawUrl\n     * @param {?} shouldPreventPushState\n     * @param {?} shouldReplaceUrl\n     * @param {?} id\n     * @param {?} precreatedState\n     * @return {?}\n     */\n    Router.prototype.runNavigate = /**\n     * @param {?} url\n     * @param {?} rawUrl\n     * @param {?} shouldPreventPushState\n     * @param {?} shouldReplaceUrl\n     * @param {?} id\n     * @param {?} precreatedState\n     * @return {?}\n     */\n    function (url, rawUrl, shouldPreventPushState, shouldReplaceUrl, id, precreatedState) {\n        var _this = this;\n        if (id !== this.navigationId) {\n            this.location.go(this.urlSerializer.serialize(this.currentUrlTree));\n            (/** @type {?} */ (this.events))\n                .next(new NavigationCancel(id, this.serializeUrl(url), \"Navigation ID \" + id + \" is not equal to the current navigation id \" + this.navigationId));\n            return Promise.resolve(false);\n        }\n        return new Promise(function (resolvePromise, rejectPromise) {\n            // create an observable of the url and route state snapshot\n            // this operation do not result in any side effects\n            var /** @type {?} */ urlAndSnapshot$;\n            if (!precreatedState) {\n                var /** @type {?} */ moduleInjector = _this.ngModule.injector;\n                var /** @type {?} */ redirectsApplied$ = applyRedirects(moduleInjector, _this.configLoader, _this.urlSerializer, url, _this.config);\n                urlAndSnapshot$ = __WEBPACK_IMPORTED_MODULE_8_rxjs_operator_mergeMap__[\"mergeMap\"].call(redirectsApplied$, function (appliedUrl) {\n                    return __WEBPACK_IMPORTED_MODULE_7_rxjs_operator_map__[\"map\"].call(recognize(_this.rootComponentType, _this.config, appliedUrl, _this.serializeUrl(appliedUrl)), function (snapshot) {\n                        (/** @type {?} */ (_this.events))\n                            .next(new RoutesRecognized(id, _this.serializeUrl(url), _this.serializeUrl(appliedUrl), snapshot));\n                        return { appliedUrl: appliedUrl, snapshot: snapshot };\n                    });\n                });\n            }\n            else {\n                urlAndSnapshot$ = Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_of__[\"of\"])({ appliedUrl: url, snapshot: precreatedState });\n            }\n            var /** @type {?} */ beforePreactivationDone$ = __WEBPACK_IMPORTED_MODULE_8_rxjs_operator_mergeMap__[\"mergeMap\"].call(urlAndSnapshot$, function (p) {\n                return __WEBPACK_IMPORTED_MODULE_7_rxjs_operator_map__[\"map\"].call(_this.hooks.beforePreactivation(p.snapshot), function () { return p; });\n            });\n            // run preactivation: guards and data resolvers\n            var /** @type {?} */ preActivation;\n            var /** @type {?} */ preactivationSetup$ = __WEBPACK_IMPORTED_MODULE_7_rxjs_operator_map__[\"map\"].call(beforePreactivationDone$, function (_a) {\n                var appliedUrl = _a.appliedUrl, snapshot = _a.snapshot;\n                var /** @type {?} */ moduleInjector = _this.ngModule.injector;\n                preActivation = new PreActivation(snapshot, _this.routerState.snapshot, moduleInjector, function (evt) { return _this.triggerEvent(evt); });\n                preActivation.initialize(_this.rootContexts);\n                return { appliedUrl: appliedUrl, snapshot: snapshot };\n            });\n            var /** @type {?} */ preactivationCheckGuards$ = __WEBPACK_IMPORTED_MODULE_8_rxjs_operator_mergeMap__[\"mergeMap\"].call(preactivationSetup$, function (_a) {\n                var appliedUrl = _a.appliedUrl, snapshot = _a.snapshot;\n                if (_this.navigationId !== id)\n                    return Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_of__[\"of\"])(false);\n                _this.triggerEvent(new GuardsCheckStart(id, _this.serializeUrl(url), appliedUrl, snapshot));\n                return __WEBPACK_IMPORTED_MODULE_7_rxjs_operator_map__[\"map\"].call(preActivation.checkGuards(), function (shouldActivate) {\n                    _this.triggerEvent(new GuardsCheckEnd(id, _this.serializeUrl(url), appliedUrl, snapshot, shouldActivate));\n                    return { appliedUrl: appliedUrl, snapshot: snapshot, shouldActivate: shouldActivate };\n                });\n            });\n            var /** @type {?} */ preactivationResolveData$ = __WEBPACK_IMPORTED_MODULE_8_rxjs_operator_mergeMap__[\"mergeMap\"].call(preactivationCheckGuards$, function (p) {\n                if (_this.navigationId !== id)\n                    return Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_of__[\"of\"])(false);\n                if (p.shouldActivate && preActivation.isActivating()) {\n                    _this.triggerEvent(new ResolveStart(id, _this.serializeUrl(url), p.appliedUrl, p.snapshot));\n                    return __WEBPACK_IMPORTED_MODULE_7_rxjs_operator_map__[\"map\"].call(preActivation.resolveData(), function () {\n                        _this.triggerEvent(new ResolveEnd(id, _this.serializeUrl(url), p.appliedUrl, p.snapshot));\n                        return p;\n                    });\n                }\n                else {\n                    return Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_of__[\"of\"])(p);\n                }\n            });\n            var /** @type {?} */ preactivationDone$ = __WEBPACK_IMPORTED_MODULE_8_rxjs_operator_mergeMap__[\"mergeMap\"].call(preactivationResolveData$, function (p) {\n                return __WEBPACK_IMPORTED_MODULE_7_rxjs_operator_map__[\"map\"].call(_this.hooks.afterPreactivation(p.snapshot), function () { return p; });\n            });\n            // create router state\n            // this operation has side effects => route state is being affected\n            var /** @type {?} */ routerState$ = __WEBPACK_IMPORTED_MODULE_7_rxjs_operator_map__[\"map\"].call(preactivationDone$, function (_a) {\n                var appliedUrl = _a.appliedUrl, snapshot = _a.snapshot, shouldActivate = _a.shouldActivate;\n                if (shouldActivate) {\n                    var /** @type {?} */ state = createRouterState(_this.routeReuseStrategy, snapshot, _this.routerState);\n                    return { appliedUrl: appliedUrl, state: state, shouldActivate: shouldActivate };\n                }\n                else {\n                    return { appliedUrl: appliedUrl, state: null, shouldActivate: shouldActivate };\n                }\n            });\n            // applied the new router state\n            // this operation has side effects\n            var /** @type {?} */ navigationIsSuccessful;\n            var /** @type {?} */ storedState = _this.routerState;\n            var /** @type {?} */ storedUrl = _this.currentUrlTree;\n            routerState$\n                .forEach(function (_a) {\n                var appliedUrl = _a.appliedUrl, state = _a.state, shouldActivate = _a.shouldActivate;\n                if (!shouldActivate || id !== _this.navigationId) {\n                    navigationIsSuccessful = false;\n                    return;\n                }\n                _this.currentUrlTree = appliedUrl;\n                _this.rawUrlTree = _this.urlHandlingStrategy.merge(_this.currentUrlTree, rawUrl);\n                (/** @type {?} */ (_this)).routerState = state;\n                if (!shouldPreventPushState) {\n                    var /** @type {?} */ path = _this.urlSerializer.serialize(_this.rawUrlTree);\n                    if (_this.location.isCurrentPathEqualTo(path) || shouldReplaceUrl) {\n                        _this.location.replaceState(path);\n                    }\n                    else {\n                        _this.location.go(path);\n                    }\n                }\n                new ActivateRoutes(_this.routeReuseStrategy, state, storedState, function (evt) { return _this.triggerEvent(evt); })\n                    .activate(_this.rootContexts);\n                navigationIsSuccessful = true;\n            })\n                .then(function () {\n                if (navigationIsSuccessful) {\n                    _this.navigated = true;\n                    (/** @type {?} */ (_this.events))\n                        .next(new NavigationEnd(id, _this.serializeUrl(url), _this.serializeUrl(_this.currentUrlTree)));\n                    resolvePromise(true);\n                }\n                else {\n                    _this.resetUrlToCurrentUrlTree();\n                    (/** @type {?} */ (_this.events))\n                        .next(new NavigationCancel(id, _this.serializeUrl(url), ''));\n                    resolvePromise(false);\n                }\n            }, function (e) {\n                if (isNavigationCancelingError(e)) {\n                    _this.resetUrlToCurrentUrlTree();\n                    _this.navigated = true;\n                    (/** @type {?} */ (_this.events))\n                        .next(new NavigationCancel(id, _this.serializeUrl(url), e.message));\n                    resolvePromise(false);\n                }\n                else {\n                    (/** @type {?} */ (_this.events))\n                        .next(new NavigationError(id, _this.serializeUrl(url), e));\n                    try {\n                        resolvePromise(_this.errorHandler(e));\n                    }\n                    catch (/** @type {?} */ ee) {\n                        rejectPromise(ee);\n                    }\n                }\n                (/** @type {?} */ (_this)).routerState = storedState;\n                _this.currentUrlTree = storedUrl;\n                _this.rawUrlTree = _this.urlHandlingStrategy.merge(_this.currentUrlTree, rawUrl);\n                _this.location.replaceState(_this.serializeUrl(_this.rawUrlTree));\n            });\n        });\n    };\n    /**\n     * @return {?}\n     */\n    Router.prototype.resetUrlToCurrentUrlTree = /**\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ path = this.urlSerializer.serialize(this.rawUrlTree);\n        this.location.replaceState(path);\n    };\n    return Router;\n}());\nvar ActivateRoutes = (function () {\n    function ActivateRoutes(routeReuseStrategy, futureState, currState, forwardEvent) {\n        this.routeReuseStrategy = routeReuseStrategy;\n        this.futureState = futureState;\n        this.currState = currState;\n        this.forwardEvent = forwardEvent;\n    }\n    /**\n     * @param {?} parentContexts\n     * @return {?}\n     */\n    ActivateRoutes.prototype.activate = /**\n     * @param {?} parentContexts\n     * @return {?}\n     */\n    function (parentContexts) {\n        var /** @type {?} */ futureRoot = this.futureState._root;\n        var /** @type {?} */ currRoot = this.currState ? this.currState._root : null;\n        this.deactivateChildRoutes(futureRoot, currRoot, parentContexts);\n        advanceActivatedRoute(this.futureState.root);\n        this.activateChildRoutes(futureRoot, currRoot, parentContexts);\n    };\n    /**\n     * @param {?} futureNode\n     * @param {?} currNode\n     * @param {?} contexts\n     * @return {?}\n     */\n    ActivateRoutes.prototype.deactivateChildRoutes = /**\n     * @param {?} futureNode\n     * @param {?} currNode\n     * @param {?} contexts\n     * @return {?}\n     */\n    function (futureNode, currNode, contexts) {\n        var _this = this;\n        var /** @type {?} */ children = nodeChildrenAsMap(currNode);\n        // Recurse on the routes active in the future state to de-activate deeper children\n        futureNode.children.forEach(function (futureChild) {\n            var /** @type {?} */ childOutletName = futureChild.value.outlet;\n            _this.deactivateRoutes(futureChild, children[childOutletName], contexts);\n            delete children[childOutletName];\n        });\n        // De-activate the routes that will not be re-used\n        forEach(children, function (v, childName) {\n            _this.deactivateRouteAndItsChildren(v, contexts);\n        });\n    };\n    /**\n     * @param {?} futureNode\n     * @param {?} currNode\n     * @param {?} parentContext\n     * @return {?}\n     */\n    ActivateRoutes.prototype.deactivateRoutes = /**\n     * @param {?} futureNode\n     * @param {?} currNode\n     * @param {?} parentContext\n     * @return {?}\n     */\n    function (futureNode, currNode, parentContext) {\n        var /** @type {?} */ future = futureNode.value;\n        var /** @type {?} */ curr = currNode ? currNode.value : null;\n        if (future === curr) {\n            // Reusing the node, check to see if the children need to be de-activated\n            if (future.component) {\n                // If we have a normal route, we need to go through an outlet.\n                var /** @type {?} */ context = parentContext.getContext(future.outlet);\n                if (context) {\n                    this.deactivateChildRoutes(futureNode, currNode, context.children);\n                }\n            }\n            else {\n                // if we have a componentless route, we recurse but keep the same outlet map.\n                this.deactivateChildRoutes(futureNode, currNode, parentContext);\n            }\n        }\n        else {\n            if (curr) {\n                // Deactivate the current route which will not be re-used\n                this.deactivateRouteAndItsChildren(currNode, parentContext);\n            }\n        }\n    };\n    /**\n     * @param {?} route\n     * @param {?} parentContexts\n     * @return {?}\n     */\n    ActivateRoutes.prototype.deactivateRouteAndItsChildren = /**\n     * @param {?} route\n     * @param {?} parentContexts\n     * @return {?}\n     */\n    function (route, parentContexts) {\n        if (this.routeReuseStrategy.shouldDetach(route.value.snapshot)) {\n            this.detachAndStoreRouteSubtree(route, parentContexts);\n        }\n        else {\n            this.deactivateRouteAndOutlet(route, parentContexts);\n        }\n    };\n    /**\n     * @param {?} route\n     * @param {?} parentContexts\n     * @return {?}\n     */\n    ActivateRoutes.prototype.detachAndStoreRouteSubtree = /**\n     * @param {?} route\n     * @param {?} parentContexts\n     * @return {?}\n     */\n    function (route, parentContexts) {\n        var /** @type {?} */ context = parentContexts.getContext(route.value.outlet);\n        if (context && context.outlet) {\n            var /** @type {?} */ componentRef = context.outlet.detach();\n            var /** @type {?} */ contexts = context.children.onOutletDeactivated();\n            this.routeReuseStrategy.store(route.value.snapshot, { componentRef: componentRef, route: route, contexts: contexts });\n        }\n    };\n    /**\n     * @param {?} route\n     * @param {?} parentContexts\n     * @return {?}\n     */\n    ActivateRoutes.prototype.deactivateRouteAndOutlet = /**\n     * @param {?} route\n     * @param {?} parentContexts\n     * @return {?}\n     */\n    function (route, parentContexts) {\n        var _this = this;\n        var /** @type {?} */ context = parentContexts.getContext(route.value.outlet);\n        if (context) {\n            var /** @type {?} */ children = nodeChildrenAsMap(route);\n            var /** @type {?} */ contexts_1 = route.value.component ? context.children : parentContexts;\n            forEach(children, function (v, k) { return _this.deactivateRouteAndItsChildren(v, contexts_1); });\n            if (context.outlet) {\n                // Destroy the component\n                context.outlet.deactivate();\n                // Destroy the contexts for all the outlets that were in the component\n                context.children.onOutletDeactivated();\n            }\n        }\n    };\n    /**\n     * @param {?} futureNode\n     * @param {?} currNode\n     * @param {?} contexts\n     * @return {?}\n     */\n    ActivateRoutes.prototype.activateChildRoutes = /**\n     * @param {?} futureNode\n     * @param {?} currNode\n     * @param {?} contexts\n     * @return {?}\n     */\n    function (futureNode, currNode, contexts) {\n        var _this = this;\n        var /** @type {?} */ children = nodeChildrenAsMap(currNode);\n        futureNode.children.forEach(function (c) {\n            _this.activateRoutes(c, children[c.value.outlet], contexts);\n            _this.forwardEvent(new ActivationEnd(c.value.snapshot));\n        });\n        if (futureNode.children.length) {\n            this.forwardEvent(new ChildActivationEnd(futureNode.value.snapshot));\n        }\n    };\n    /**\n     * @param {?} futureNode\n     * @param {?} currNode\n     * @param {?} parentContexts\n     * @return {?}\n     */\n    ActivateRoutes.prototype.activateRoutes = /**\n     * @param {?} futureNode\n     * @param {?} currNode\n     * @param {?} parentContexts\n     * @return {?}\n     */\n    function (futureNode, currNode, parentContexts) {\n        var /** @type {?} */ future = futureNode.value;\n        var /** @type {?} */ curr = currNode ? currNode.value : null;\n        advanceActivatedRoute(future);\n        // reusing the node\n        if (future === curr) {\n            if (future.component) {\n                // If we have a normal route, we need to go through an outlet.\n                var /** @type {?} */ context = parentContexts.getOrCreateContext(future.outlet);\n                this.activateChildRoutes(futureNode, currNode, context.children);\n            }\n            else {\n                // if we have a componentless route, we recurse but keep the same outlet map.\n                this.activateChildRoutes(futureNode, currNode, parentContexts);\n            }\n        }\n        else {\n            if (future.component) {\n                // if we have a normal route, we need to place the component into the outlet and recurse.\n                var /** @type {?} */ context = parentContexts.getOrCreateContext(future.outlet);\n                if (this.routeReuseStrategy.shouldAttach(future.snapshot)) {\n                    var /** @type {?} */ stored = (/** @type {?} */ (this.routeReuseStrategy.retrieve(future.snapshot)));\n                    this.routeReuseStrategy.store(future.snapshot, null);\n                    context.children.onOutletReAttached(stored.contexts);\n                    context.attachRef = stored.componentRef;\n                    context.route = stored.route.value;\n                    if (context.outlet) {\n                        // Attach right away when the outlet has already been instantiated\n                        // Otherwise attach from `RouterOutlet.ngOnInit` when it is instantiated\n                        context.outlet.attach(stored.componentRef, stored.route.value);\n                    }\n                    advanceActivatedRouteNodeAndItsChildren(stored.route);\n                }\n                else {\n                    var /** @type {?} */ config = parentLoadedConfig(future.snapshot);\n                    var /** @type {?} */ cmpFactoryResolver = config ? config.module.componentFactoryResolver : null;\n                    context.route = future;\n                    context.resolver = cmpFactoryResolver;\n                    if (context.outlet) {\n                        // Activate the outlet when it has already been instantiated\n                        // Otherwise it will get activated from its `ngOnInit` when instantiated\n                        context.outlet.activateWith(future, cmpFactoryResolver);\n                    }\n                    this.activateChildRoutes(futureNode, null, context.children);\n                }\n            }\n            else {\n                // if we have a componentless route, we recurse but keep the same outlet map.\n                this.activateChildRoutes(futureNode, null, parentContexts);\n            }\n        }\n    };\n    return ActivateRoutes;\n}());\n/**\n * @param {?} node\n * @return {?}\n */\nfunction advanceActivatedRouteNodeAndItsChildren(node) {\n    advanceActivatedRoute(node.value);\n    node.children.forEach(advanceActivatedRouteNodeAndItsChildren);\n}\n/**\n * @param {?} snapshot\n * @return {?}\n */\nfunction parentLoadedConfig(snapshot) {\n    for (var /** @type {?} */ s = snapshot.parent; s; s = s.parent) {\n        var /** @type {?} */ route = s.routeConfig;\n        if (route && route._loadedConfig)\n            return route._loadedConfig;\n        if (route && route.component)\n            return null;\n    }\n    return null;\n}\n/**\n * @param {?} commands\n * @return {?}\n */\nfunction validateCommands(commands) {\n    for (var /** @type {?} */ i = 0; i < commands.length; i++) {\n        var /** @type {?} */ cmd = commands[i];\n        if (cmd == null) {\n            throw new Error(\"The requested path contains \" + cmd + \" segment at index \" + i);\n        }\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * \\@whatItDoes Lets you link to specific parts of your app.\n *\n * \\@howToUse\n *\n * Consider the following route configuration:\n * `[{ path: 'user/:name', component: UserCmp }]`\n *\n * When linking to this `user/:name` route, you can write:\n * `<a routerLink='/user/bob'>link to user component</a>`\n *\n * \\@description\n *\n * The RouterLink directives let you link to specific parts of your app.\n *\n * When the link is static, you can use the directive as follows:\n * `<a routerLink=\"/user/bob\">link to user component</a>`\n *\n * If you use dynamic values to generate the link, you can pass an array of path\n * segments, followed by the params for each segment.\n *\n * For instance `['/team', teamId, 'user', userName, {details: true}]`\n * means that we want to generate a link to `/team/11/user/bob;details=true`.\n *\n * Multiple static segments can be merged into one\n * (e.g., `['/team/11/user', userName, {details: true}]`).\n *\n * The first segment name can be prepended with `/`, `./`, or `../`:\n * * If the first segment begins with `/`, the router will look up the route from the root of the\n *   app.\n * * If the first segment begins with `./`, or doesn't begin with a slash, the router will\n *   instead look in the children of the current activated route.\n * * And if the first segment begins with `../`, the router will go up one level.\n *\n * You can set query params and fragment as follows:\n *\n * ```\n * <a [routerLink]=\"['/user/bob']\" [queryParams]=\"{debug: true}\" fragment=\"education\">\n *   link to user component\n * </a>\n * ```\n * RouterLink will use these to generate this link: `/user/bob#education?debug=true`.\n *\n * (Deprecated in v4.0.0 use `queryParamsHandling` instead) You can also tell the\n * directive to preserve the current query params and fragment:\n *\n * ```\n * <a [routerLink]=\"['/user/bob']\" preserveQueryParams preserveFragment>\n *   link to user component\n * </a>\n * ```\n *\n * You can tell the directive to how to handle queryParams, available options are:\n *  - `'merge'`: merge the queryParams into the current queryParams\n *  - `'preserve'`: preserve the current queryParams\n *  - default/`''`: use the queryParams only\n *\n * Same options for {\\@link NavigationExtras#queryParamsHandling\n * NavigationExtras#queryParamsHandling}.\n *\n * ```\n * <a [routerLink]=\"['/user/bob']\" [queryParams]=\"{debug: true}\" queryParamsHandling=\"merge\">\n *   link to user component\n * </a>\n * ```\n *\n * The router link directive always treats the provided input as a delta to the current url.\n *\n * For instance, if the current url is `/user/(box//aux:team)`.\n *\n * Then the following link `<a [routerLink]=\"['/user/jim']\">Jim</a>` will generate the link\n * `/user/(jim//aux:team)`.\n *\n * See {\\@link Router#createUrlTree createUrlTree} for more information.\n *\n * \\@ngModule RouterModule\n *\n * \\@stable\n */\nvar RouterLink = (function () {\n    function RouterLink(router, route, tabIndex, renderer, el) {\n        this.router = router;\n        this.route = route;\n        this.commands = [];\n        if (tabIndex == null) {\n            renderer.setAttribute(el.nativeElement, 'tabindex', '0');\n        }\n    }\n    Object.defineProperty(RouterLink.prototype, \"routerLink\", {\n        set: /**\n         * @param {?} commands\n         * @return {?}\n         */\n        function (commands) {\n            if (commands != null) {\n                this.commands = Array.isArray(commands) ? commands : [commands];\n            }\n            else {\n                this.commands = [];\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(RouterLink.prototype, \"preserveQueryParams\", {\n        set: /**\n         * @deprecated 4.0.0 use `queryParamsHandling` instead.\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            if (Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"isDevMode\"])() && /** @type {?} */ (console) && /** @type {?} */ (console.warn)) {\n                console.warn('preserveQueryParams is deprecated!, use queryParamsHandling instead.');\n            }\n            this.preserve = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    RouterLink.prototype.onClick = /**\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ extras = {\n            skipLocationChange: attrBoolValue(this.skipLocationChange),\n            replaceUrl: attrBoolValue(this.replaceUrl),\n        };\n        this.router.navigateByUrl(this.urlTree, extras);\n        return true;\n    };\n    Object.defineProperty(RouterLink.prototype, \"urlTree\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            return this.router.createUrlTree(this.commands, {\n                relativeTo: this.route,\n                queryParams: this.queryParams,\n                fragment: this.fragment,\n                preserveQueryParams: attrBoolValue(this.preserve),\n                queryParamsHandling: this.queryParamsHandling,\n                preserveFragment: attrBoolValue(this.preserveFragment),\n            });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    RouterLink.decorators = [\n        { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{ selector: ':not(a)[routerLink]' },] },\n    ];\n    /** @nocollapse */\n    RouterLink.ctorParameters = function () { return [\n        { type: Router, },\n        { type: ActivatedRoute, },\n        { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Attribute\"], args: ['tabindex',] },] },\n        { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\n        { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\n    ]; };\n    RouterLink.propDecorators = {\n        \"queryParams\": [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\n        \"fragment\": [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\n        \"queryParamsHandling\": [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\n        \"preserveFragment\": [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\n        \"skipLocationChange\": [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\n        \"replaceUrl\": [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\n        \"routerLink\": [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\n        \"preserveQueryParams\": [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\n        \"onClick\": [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"HostListener\"], args: ['click',] },],\n    };\n    return RouterLink;\n}());\n/**\n * \\@whatItDoes Lets you link to specific parts of your app.\n *\n * See {\\@link RouterLink} for more information.\n *\n * \\@ngModule RouterModule\n *\n * \\@stable\n */\nvar RouterLinkWithHref = (function () {\n    function RouterLinkWithHref(router, route, locationStrategy) {\n        var _this = this;\n        this.router = router;\n        this.route = route;\n        this.locationStrategy = locationStrategy;\n        this.commands = [];\n        this.subscription = router.events.subscribe(function (s) {\n            if (s instanceof NavigationEnd) {\n                _this.updateTargetUrlAndHref();\n            }\n        });\n    }\n    Object.defineProperty(RouterLinkWithHref.prototype, \"routerLink\", {\n        set: /**\n         * @param {?} commands\n         * @return {?}\n         */\n        function (commands) {\n            if (commands != null) {\n                this.commands = Array.isArray(commands) ? commands : [commands];\n            }\n            else {\n                this.commands = [];\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(RouterLinkWithHref.prototype, \"preserveQueryParams\", {\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            if (Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"isDevMode\"])() && /** @type {?} */ (console) && /** @type {?} */ (console.warn)) {\n                console.warn('preserveQueryParams is deprecated, use queryParamsHandling instead.');\n            }\n            this.preserve = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    RouterLinkWithHref.prototype.ngOnChanges = /**\n     * @param {?} changes\n     * @return {?}\n     */\n    function (changes) { this.updateTargetUrlAndHref(); };\n    /**\n     * @return {?}\n     */\n    RouterLinkWithHref.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () { this.subscription.unsubscribe(); };\n    /**\n     * @param {?} button\n     * @param {?} ctrlKey\n     * @param {?} metaKey\n     * @param {?} shiftKey\n     * @return {?}\n     */\n    RouterLinkWithHref.prototype.onClick = /**\n     * @param {?} button\n     * @param {?} ctrlKey\n     * @param {?} metaKey\n     * @param {?} shiftKey\n     * @return {?}\n     */\n    function (button, ctrlKey, metaKey, shiftKey) {\n        if (button !== 0 || ctrlKey || metaKey || shiftKey) {\n            return true;\n        }\n        if (typeof this.target === 'string' && this.target != '_self') {\n            return true;\n        }\n        var /** @type {?} */ extras = {\n            skipLocationChange: attrBoolValue(this.skipLocationChange),\n            replaceUrl: attrBoolValue(this.replaceUrl),\n        };\n        this.router.navigateByUrl(this.urlTree, extras);\n        return false;\n    };\n    /**\n     * @return {?}\n     */\n    RouterLinkWithHref.prototype.updateTargetUrlAndHref = /**\n     * @return {?}\n     */\n    function () {\n        this.href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.urlTree));\n    };\n    Object.defineProperty(RouterLinkWithHref.prototype, \"urlTree\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            return this.router.createUrlTree(this.commands, {\n                relativeTo: this.route,\n                queryParams: this.queryParams,\n                fragment: this.fragment,\n                preserveQueryParams: attrBoolValue(this.preserve),\n                queryParamsHandling: this.queryParamsHandling,\n                preserveFragment: attrBoolValue(this.preserveFragment),\n            });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    RouterLinkWithHref.decorators = [\n        { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{ selector: 'a[routerLink]' },] },\n    ];\n    /** @nocollapse */\n    RouterLinkWithHref.ctorParameters = function () { return [\n        { type: Router, },\n        { type: ActivatedRoute, },\n        { type: __WEBPACK_IMPORTED_MODULE_0__angular_common__[\"LocationStrategy\"], },\n    ]; };\n    RouterLinkWithHref.propDecorators = {\n        \"target\": [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"HostBinding\"], args: ['attr.target',] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\n        \"queryParams\": [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\n        \"fragment\": [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\n        \"queryParamsHandling\": [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\n        \"preserveFragment\": [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\n        \"skipLocationChange\": [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\n        \"replaceUrl\": [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\n        \"href\": [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"HostBinding\"] },],\n        \"routerLink\": [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\n        \"preserveQueryParams\": [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\n        \"onClick\": [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"HostListener\"], args: ['click', ['$event.button', '$event.ctrlKey', '$event.metaKey', '$event.shiftKey'],] },],\n    };\n    return RouterLinkWithHref;\n}());\n/**\n * @param {?} s\n * @return {?}\n */\nfunction attrBoolValue(s) {\n    return s === '' || !!s;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * \\@whatItDoes Lets you add a CSS class to an element when the link's route becomes active.\n *\n * \\@howToUse\n *\n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\">Bob</a>\n * ```\n *\n * \\@description\n *\n * The RouterLinkActive directive lets you add a CSS class to an element when the link's route\n * becomes active.\n *\n * Consider the following example:\n *\n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\">Bob</a>\n * ```\n *\n * When the url is either '/user' or '/user/bob', the active-link class will\n * be added to the `a` tag. If the url changes, the class will be removed.\n *\n * You can set more than one class, as follows:\n *\n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive=\"class1 class2\">Bob</a>\n * <a routerLink=\"/user/bob\" [routerLinkActive]=\"['class1', 'class2']\">Bob</a>\n * ```\n *\n * You can configure RouterLinkActive by passing `exact: true`. This will add the classes\n * only when the url matches the link exactly.\n *\n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\" [routerLinkActiveOptions]=\"{exact:\n * true}\">Bob</a>\n * ```\n *\n * You can assign the RouterLinkActive instance to a template variable and directly check\n * the `isActive` status.\n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive #rla=\"routerLinkActive\">\n *   Bob {{ rla.isActive ? '(already open)' : ''}}\n * </a>\n * ```\n *\n * Finally, you can apply the RouterLinkActive directive to an ancestor of a RouterLink.\n *\n * ```\n * <div routerLinkActive=\"active-link\" [routerLinkActiveOptions]=\"{exact: true}\">\n *   <a routerLink=\"/user/jim\">Jim</a>\n *   <a routerLink=\"/user/bob\">Bob</a>\n * </div>\n * ```\n *\n * This will set the active-link class on the div tag if the url is either '/user/jim' or\n * '/user/bob'.\n *\n * \\@ngModule RouterModule\n *\n * \\@stable\n */\nvar RouterLinkActive = (function () {\n    function RouterLinkActive(router, element, renderer, cdr) {\n        var _this = this;\n        this.router = router;\n        this.element = element;\n        this.renderer = renderer;\n        this.cdr = cdr;\n        this.classes = [];\n        this.isActive = false;\n        this.routerLinkActiveOptions = { exact: false };\n        this.subscription = router.events.subscribe(function (s) {\n            if (s instanceof NavigationEnd) {\n                _this.update();\n            }\n        });\n    }\n    /**\n     * @return {?}\n     */\n    RouterLinkActive.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this.links.changes.subscribe(function (_) { return _this.update(); });\n        this.linksWithHrefs.changes.subscribe(function (_) { return _this.update(); });\n        this.update();\n    };\n    Object.defineProperty(RouterLinkActive.prototype, \"routerLinkActive\", {\n        set: /**\n         * @param {?} data\n         * @return {?}\n         */\n        function (data) {\n            var /** @type {?} */ classes = Array.isArray(data) ? data : data.split(' ');\n            this.classes = classes.filter(function (c) { return !!c; });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    RouterLinkActive.prototype.ngOnChanges = /**\n     * @param {?} changes\n     * @return {?}\n     */\n    function (changes) { this.update(); };\n    /**\n     * @return {?}\n     */\n    RouterLinkActive.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () { this.subscription.unsubscribe(); };\n    /**\n     * @return {?}\n     */\n    RouterLinkActive.prototype.update = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (!this.links || !this.linksWithHrefs || !this.router.navigated)\n            return;\n        Promise.resolve().then(function () {\n            var /** @type {?} */ hasActiveLinks = _this.hasActiveLinks();\n            if (_this.isActive !== hasActiveLinks) {\n                (/** @type {?} */ (_this)).isActive = hasActiveLinks;\n                _this.classes.forEach(function (c) {\n                    if (hasActiveLinks) {\n                        _this.renderer.addClass(_this.element.nativeElement, c);\n                    }\n                    else {\n                        _this.renderer.removeClass(_this.element.nativeElement, c);\n                    }\n                });\n            }\n        });\n    };\n    /**\n     * @param {?} router\n     * @return {?}\n     */\n    RouterLinkActive.prototype.isLinkActive = /**\n     * @param {?} router\n     * @return {?}\n     */\n    function (router) {\n        var _this = this;\n        return function (link) {\n            return router.isActive(link.urlTree, _this.routerLinkActiveOptions.exact);\n        };\n    };\n    /**\n     * @return {?}\n     */\n    RouterLinkActive.prototype.hasActiveLinks = /**\n     * @return {?}\n     */\n    function () {\n        return this.links.some(this.isLinkActive(this.router)) ||\n            this.linksWithHrefs.some(this.isLinkActive(this.router));\n    };\n    RouterLinkActive.decorators = [\n        { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\n                    selector: '[routerLinkActive]',\n                    exportAs: 'routerLinkActive',\n                },] },\n    ];\n    /** @nocollapse */\n    RouterLinkActive.ctorParameters = function () { return [\n        { type: Router, },\n        { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\n        { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\n        { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectorRef\"], },\n    ]; };\n    RouterLinkActive.propDecorators = {\n        \"links\": [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ContentChildren\"], args: [RouterLink, { descendants: true },] },],\n        \"linksWithHrefs\": [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ContentChildren\"], args: [RouterLinkWithHref, { descendants: true },] },],\n        \"routerLinkActiveOptions\": [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\n        \"routerLinkActive\": [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\n    };\n    return RouterLinkActive;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Store contextual information about a {\\@link RouterOutlet}\n *\n * \\@stable\n */\nvar OutletContext = (function () {\n    function OutletContext() {\n        this.outlet = null;\n        this.route = null;\n        this.resolver = null;\n        this.children = new ChildrenOutletContexts();\n        this.attachRef = null;\n    }\n    return OutletContext;\n}());\n/**\n * Store contextual information about the children (= nested) {\\@link RouterOutlet}\n *\n * \\@stable\n */\nvar ChildrenOutletContexts = (function () {\n    function ChildrenOutletContexts() {\n        this.contexts = new Map();\n    }\n    /** Called when a `RouterOutlet` directive is instantiated */\n    /**\n     * Called when a `RouterOutlet` directive is instantiated\n     * @param {?} childName\n     * @param {?} outlet\n     * @return {?}\n     */\n    ChildrenOutletContexts.prototype.onChildOutletCreated = /**\n     * Called when a `RouterOutlet` directive is instantiated\n     * @param {?} childName\n     * @param {?} outlet\n     * @return {?}\n     */\n    function (childName, outlet) {\n        var /** @type {?} */ context = this.getOrCreateContext(childName);\n        context.outlet = outlet;\n        this.contexts.set(childName, context);\n    };\n    /**\n     * Called when a `RouterOutlet` directive is destroyed.\n     * We need to keep the context as the outlet could be destroyed inside a NgIf and might be\n     * re-created later.\n     */\n    /**\n     * Called when a `RouterOutlet` directive is destroyed.\n     * We need to keep the context as the outlet could be destroyed inside a NgIf and might be\n     * re-created later.\n     * @param {?} childName\n     * @return {?}\n     */\n    ChildrenOutletContexts.prototype.onChildOutletDestroyed = /**\n     * Called when a `RouterOutlet` directive is destroyed.\n     * We need to keep the context as the outlet could be destroyed inside a NgIf and might be\n     * re-created later.\n     * @param {?} childName\n     * @return {?}\n     */\n    function (childName) {\n        var /** @type {?} */ context = this.getContext(childName);\n        if (context) {\n            context.outlet = null;\n        }\n    };\n    /**\n     * Called when the corresponding route is deactivated during navigation.\n     * Because the component get destroyed, all children outlet are destroyed.\n     */\n    /**\n     * Called when the corresponding route is deactivated during navigation.\n     * Because the component get destroyed, all children outlet are destroyed.\n     * @return {?}\n     */\n    ChildrenOutletContexts.prototype.onOutletDeactivated = /**\n     * Called when the corresponding route is deactivated during navigation.\n     * Because the component get destroyed, all children outlet are destroyed.\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ contexts = this.contexts;\n        this.contexts = new Map();\n        return contexts;\n    };\n    /**\n     * @param {?} contexts\n     * @return {?}\n     */\n    ChildrenOutletContexts.prototype.onOutletReAttached = /**\n     * @param {?} contexts\n     * @return {?}\n     */\n    function (contexts) { this.contexts = contexts; };\n    /**\n     * @param {?} childName\n     * @return {?}\n     */\n    ChildrenOutletContexts.prototype.getOrCreateContext = /**\n     * @param {?} childName\n     * @return {?}\n     */\n    function (childName) {\n        var /** @type {?} */ context = this.getContext(childName);\n        if (!context) {\n            context = new OutletContext();\n            this.contexts.set(childName, context);\n        }\n        return context;\n    };\n    /**\n     * @param {?} childName\n     * @return {?}\n     */\n    ChildrenOutletContexts.prototype.getContext = /**\n     * @param {?} childName\n     * @return {?}\n     */\n    function (childName) { return this.contexts.get(childName) || null; };\n    return ChildrenOutletContexts;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * \\@whatItDoes Acts as a placeholder that Angular dynamically fills based on the current router\n * state.\n *\n * \\@howToUse\n *\n * ```\n * <router-outlet></router-outlet>\n * <router-outlet name='left'></router-outlet>\n * <router-outlet name='right'></router-outlet>\n * ```\n *\n * A router outlet will emit an activate event any time a new component is being instantiated,\n * and a deactivate event when it is being destroyed.\n *\n * ```\n * <router-outlet\n *   (activate)='onActivate($event)'\n *   (deactivate)='onDeactivate($event)'></router-outlet>\n * ```\n * \\@ngModule RouterModule\n *\n * \\@stable\n */\nvar RouterOutlet = (function () {\n    function RouterOutlet(parentContexts, location, resolver, name, changeDetector) {\n        this.parentContexts = parentContexts;\n        this.location = location;\n        this.resolver = resolver;\n        this.changeDetector = changeDetector;\n        this.activated = null;\n        this._activatedRoute = null;\n        this.activateEvents = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\n        this.deactivateEvents = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\n        this.name = name || PRIMARY_OUTLET;\n        parentContexts.onChildOutletCreated(this.name, this);\n    }\n    /**\n     * @return {?}\n     */\n    RouterOutlet.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () { this.parentContexts.onChildOutletDestroyed(this.name); };\n    /**\n     * @return {?}\n     */\n    RouterOutlet.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n        if (!this.activated) {\n            // If the outlet was not instantiated at the time the route got activated we need to populate\n            // the outlet when it is initialized (ie inside a NgIf)\n            var /** @type {?} */ context = this.parentContexts.getContext(this.name);\n            if (context && context.route) {\n                if (context.attachRef) {\n                    // `attachRef` is populated when there is an existing component to mount\n                    this.attach(context.attachRef, context.route);\n                }\n                else {\n                    // otherwise the component defined in the configuration is created\n                    this.activateWith(context.route, context.resolver || null);\n                }\n            }\n        }\n    };\n    Object.defineProperty(RouterOutlet.prototype, \"isActivated\", {\n        get: /**\n         * @return {?}\n         */\n        function () { return !!this.activated; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(RouterOutlet.prototype, \"component\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            if (!this.activated)\n                throw new Error('Outlet is not activated');\n            return this.activated.instance;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(RouterOutlet.prototype, \"activatedRoute\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            if (!this.activated)\n                throw new Error('Outlet is not activated');\n            return /** @type {?} */ (this._activatedRoute);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(RouterOutlet.prototype, \"activatedRouteData\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            if (this._activatedRoute) {\n                return this._activatedRoute.snapshot.data;\n            }\n            return {};\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Called when the `RouteReuseStrategy` instructs to detach the subtree\n     */\n    /**\n     * Called when the `RouteReuseStrategy` instructs to detach the subtree\n     * @return {?}\n     */\n    RouterOutlet.prototype.detach = /**\n     * Called when the `RouteReuseStrategy` instructs to detach the subtree\n     * @return {?}\n     */\n    function () {\n        if (!this.activated)\n            throw new Error('Outlet is not activated');\n        this.location.detach();\n        var /** @type {?} */ cmp = this.activated;\n        this.activated = null;\n        this._activatedRoute = null;\n        return cmp;\n    };\n    /**\n     * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree\n     */\n    /**\n     * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree\n     * @param {?} ref\n     * @param {?} activatedRoute\n     * @return {?}\n     */\n    RouterOutlet.prototype.attach = /**\n     * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree\n     * @param {?} ref\n     * @param {?} activatedRoute\n     * @return {?}\n     */\n    function (ref, activatedRoute) {\n        this.activated = ref;\n        this._activatedRoute = activatedRoute;\n        this.location.insert(ref.hostView);\n    };\n    /**\n     * @return {?}\n     */\n    RouterOutlet.prototype.deactivate = /**\n     * @return {?}\n     */\n    function () {\n        if (this.activated) {\n            var /** @type {?} */ c = this.component;\n            this.activated.destroy();\n            this.activated = null;\n            this._activatedRoute = null;\n            this.deactivateEvents.emit(c);\n        }\n    };\n    /**\n     * @param {?} activatedRoute\n     * @param {?} resolver\n     * @return {?}\n     */\n    RouterOutlet.prototype.activateWith = /**\n     * @param {?} activatedRoute\n     * @param {?} resolver\n     * @return {?}\n     */\n    function (activatedRoute, resolver) {\n        if (this.isActivated) {\n            throw new Error('Cannot activate an already activated outlet');\n        }\n        this._activatedRoute = activatedRoute;\n        var /** @type {?} */ snapshot = activatedRoute._futureSnapshot;\n        var /** @type {?} */ component = /** @type {?} */ (/** @type {?} */ ((snapshot.routeConfig)).component);\n        resolver = resolver || this.resolver;\n        var /** @type {?} */ factory = resolver.resolveComponentFactory(component);\n        var /** @type {?} */ childContexts = this.parentContexts.getOrCreateContext(this.name).children;\n        var /** @type {?} */ injector = new OutletInjector(activatedRoute, childContexts, this.location.injector);\n        this.activated = this.location.createComponent(factory, this.location.length, injector);\n        // Calling `markForCheck` to make sure we will run the change detection when the\n        // `RouterOutlet` is inside a `ChangeDetectionStrategy.OnPush` component.\n        this.changeDetector.markForCheck();\n        this.activateEvents.emit(this.activated.instance);\n    };\n    RouterOutlet.decorators = [\n        { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{ selector: 'router-outlet', exportAs: 'outlet' },] },\n    ];\n    /** @nocollapse */\n    RouterOutlet.ctorParameters = function () { return [\n        { type: ChildrenOutletContexts, },\n        { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewContainerRef\"], },\n        { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ComponentFactoryResolver\"], },\n        { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Attribute\"], args: ['name',] },] },\n        { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectorRef\"], },\n    ]; };\n    RouterOutlet.propDecorators = {\n        \"activateEvents\": [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"], args: ['activate',] },],\n        \"deactivateEvents\": [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"], args: ['deactivate',] },],\n    };\n    return RouterOutlet;\n}());\nvar OutletInjector = (function () {\n    function OutletInjector(route, childContexts, parent) {\n        this.route = route;\n        this.childContexts = childContexts;\n        this.parent = parent;\n    }\n    /**\n     * @param {?} token\n     * @param {?=} notFoundValue\n     * @return {?}\n     */\n    OutletInjector.prototype.get = /**\n     * @param {?} token\n     * @param {?=} notFoundValue\n     * @return {?}\n     */\n    function (token, notFoundValue) {\n        if (token === ActivatedRoute) {\n            return this.route;\n        }\n        if (token === ChildrenOutletContexts) {\n            return this.childContexts;\n        }\n        return this.parent.get(token, notFoundValue);\n    };\n    return OutletInjector;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n*@license\n*Copyright Google Inc. All Rights Reserved.\n*\n*Use of this source code is governed by an MIT-style license that can be\n*found in the LICENSE file at https://angular.io/license\n*/\n/**\n * \\@whatItDoes Provides a preloading strategy.\n *\n * \\@experimental\n * @abstract\n */\nvar PreloadingStrategy = (function () {\n    function PreloadingStrategy() {\n    }\n    return PreloadingStrategy;\n}());\n/**\n * \\@whatItDoes Provides a preloading strategy that preloads all modules as quickly as possible.\n *\n * \\@howToUse\n *\n * ```\n * RouteModule.forRoot(ROUTES, {preloadingStrategy: PreloadAllModules})\n * ```\n *\n * \\@experimental\n */\nvar PreloadAllModules = (function () {\n    function PreloadAllModules() {\n    }\n    /**\n     * @param {?} route\n     * @param {?} fn\n     * @return {?}\n     */\n    PreloadAllModules.prototype.preload = /**\n     * @param {?} route\n     * @param {?} fn\n     * @return {?}\n     */\n    function (route, fn) {\n        return __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_catch__[\"_catch\"].call(fn(), function () { return Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_of__[\"of\"])(null); });\n    };\n    return PreloadAllModules;\n}());\n/**\n * \\@whatItDoes Provides a preloading strategy that does not preload any modules.\n *\n * \\@description\n *\n * This strategy is enabled by default.\n *\n * \\@experimental\n */\nvar NoPreloading = (function () {\n    function NoPreloading() {\n    }\n    /**\n     * @param {?} route\n     * @param {?} fn\n     * @return {?}\n     */\n    NoPreloading.prototype.preload = /**\n     * @param {?} route\n     * @param {?} fn\n     * @return {?}\n     */\n    function (route, fn) { return Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_of__[\"of\"])(null); };\n    return NoPreloading;\n}());\n/**\n * The preloader optimistically loads all router configurations to\n * make navigations into lazily-loaded sections of the application faster.\n *\n * The preloader runs in the background. When the router bootstraps, the preloader\n * starts listening to all navigation events. After every such event, the preloader\n * will check if any configurations can be loaded lazily.\n *\n * If a route is protected by `canLoad` guards, the preloaded will not load it.\n *\n * \\@stable\n */\nvar RouterPreloader = (function () {\n    function RouterPreloader(router, moduleLoader, compiler, injector, preloadingStrategy) {\n        this.router = router;\n        this.injector = injector;\n        this.preloadingStrategy = preloadingStrategy;\n        var /** @type {?} */ onStartLoad = function (r) { return router.triggerEvent(new RouteConfigLoadStart(r)); };\n        var /** @type {?} */ onEndLoad = function (r) { return router.triggerEvent(new RouteConfigLoadEnd(r)); };\n        this.loader = new RouterConfigLoader(moduleLoader, compiler, onStartLoad, onEndLoad);\n    }\n    /**\n     * @return {?}\n     */\n    RouterPreloader.prototype.setUpPreloading = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        var /** @type {?} */ navigations$ = __WEBPACK_IMPORTED_MODULE_21_rxjs_operator_filter__[\"filter\"].call(this.router.events, function (e) { return e instanceof NavigationEnd; });\n        this.subscription = __WEBPACK_IMPORTED_MODULE_6_rxjs_operator_concatMap__[\"concatMap\"].call(navigations$, function () { return _this.preload(); }).subscribe(function () { });\n    };\n    /**\n     * @return {?}\n     */\n    RouterPreloader.prototype.preload = /**\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ ngModule = this.injector.get(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModuleRef\"]);\n        return this.processRoutes(ngModule, this.router.config);\n    };\n    // TODO(jasonaden): This class relies on code external to the class to call setUpPreloading. If\n    // this hasn't been done, ngOnDestroy will fail as this.subscription will be undefined. This\n    // should be refactored.\n    /**\n     * @return {?}\n     */\n    RouterPreloader.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () { this.subscription.unsubscribe(); };\n    /**\n     * @param {?} ngModule\n     * @param {?} routes\n     * @return {?}\n     */\n    RouterPreloader.prototype.processRoutes = /**\n     * @param {?} ngModule\n     * @param {?} routes\n     * @return {?}\n     */\n    function (ngModule, routes) {\n        var /** @type {?} */ res = [];\n        for (var _i = 0, routes_1 = routes; _i < routes_1.length; _i++) {\n            var route = routes_1[_i];\n            // we already have the config loaded, just recurse\n            if (route.loadChildren && !route.canLoad && route._loadedConfig) {\n                var /** @type {?} */ childConfig = route._loadedConfig;\n                res.push(this.processRoutes(childConfig.module, childConfig.routes));\n                // no config loaded, fetch the config\n            }\n            else if (route.loadChildren && !route.canLoad) {\n                res.push(this.preloadConfig(ngModule, route));\n                // recurse into children\n            }\n            else if (route.children) {\n                res.push(this.processRoutes(ngModule, route.children));\n            }\n        }\n        return __WEBPACK_IMPORTED_MODULE_18_rxjs_operator_mergeAll__[\"mergeAll\"].call(Object(__WEBPACK_IMPORTED_MODULE_10_rxjs_observable_from__[\"from\"])(res));\n    };\n    /**\n     * @param {?} ngModule\n     * @param {?} route\n     * @return {?}\n     */\n    RouterPreloader.prototype.preloadConfig = /**\n     * @param {?} ngModule\n     * @param {?} route\n     * @return {?}\n     */\n    function (ngModule, route) {\n        var _this = this;\n        return this.preloadingStrategy.preload(route, function () {\n            var /** @type {?} */ loaded$ = _this.loader.load(ngModule.injector, route);\n            return __WEBPACK_IMPORTED_MODULE_8_rxjs_operator_mergeMap__[\"mergeMap\"].call(loaded$, function (config) {\n                route._loadedConfig = config;\n                return _this.processRoutes(config.module, config.routes);\n            });\n        });\n    };\n    RouterPreloader.decorators = [\n        { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injectable\"] },\n    ];\n    /** @nocollapse */\n    RouterPreloader.ctorParameters = function () { return [\n        { type: Router, },\n        { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModuleFactoryLoader\"], },\n        { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Compiler\"], },\n        { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injector\"], },\n        { type: PreloadingStrategy, },\n    ]; };\n    return RouterPreloader;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * \\@whatItDoes Contains a list of directives\n * \\@stable\n */\nvar ROUTER_DIRECTIVES = [RouterOutlet, RouterLink, RouterLinkWithHref, RouterLinkActive];\n/**\n * \\@whatItDoes Is used in DI to configure the router.\n * \\@stable\n */\nvar ROUTER_CONFIGURATION = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"InjectionToken\"]('ROUTER_CONFIGURATION');\n/**\n * \\@docsNotRequired\n */\nvar ROUTER_FORROOT_GUARD = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"InjectionToken\"]('ROUTER_FORROOT_GUARD');\nvar ROUTER_PROVIDERS = [\n    __WEBPACK_IMPORTED_MODULE_0__angular_common__[\"Location\"],\n    { provide: UrlSerializer, useClass: DefaultUrlSerializer },\n    {\n        provide: Router,\n        useFactory: setupRouter,\n        deps: [\n            __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ApplicationRef\"], UrlSerializer, ChildrenOutletContexts, __WEBPACK_IMPORTED_MODULE_0__angular_common__[\"Location\"], __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injector\"],\n            __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModuleFactoryLoader\"], __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Compiler\"], ROUTES, ROUTER_CONFIGURATION,\n            [UrlHandlingStrategy, new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"]()], [RouteReuseStrategy, new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"]()]\n        ]\n    },\n    ChildrenOutletContexts,\n    { provide: ActivatedRoute, useFactory: rootRoute, deps: [Router] },\n    { provide: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModuleFactoryLoader\"], useClass: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"SystemJsNgModuleLoader\"] },\n    RouterPreloader,\n    NoPreloading,\n    PreloadAllModules,\n    { provide: ROUTER_CONFIGURATION, useValue: { enableTracing: false } },\n];\n/**\n * @return {?}\n */\nfunction routerNgProbeToken() {\n    return new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgProbeToken\"]('Router', Router);\n}\n/**\n * \\@whatItDoes Adds router directives and providers.\n *\n * \\@howToUse\n *\n * RouterModule can be imported multiple times: once per lazily-loaded bundle.\n * Since the router deals with a global shared resource--location, we cannot have\n * more than one router service active.\n *\n * That is why there are two ways to create the module: `RouterModule.forRoot` and\n * `RouterModule.forChild`.\n *\n * * `forRoot` creates a module that contains all the directives, the given routes, and the router\n *   service itself.\n * * `forChild` creates a module that contains all the directives and the given routes, but does not\n *   include the router service.\n *\n * When registered at the root, the module should be used as follows\n *\n * ```\n * \\@NgModule({\n *   imports: [RouterModule.forRoot(ROUTES)]\n * })\n * class MyNgModule {}\n * ```\n *\n * For submodules and lazy loaded submodules the module should be used as follows:\n *\n * ```\n * \\@NgModule({\n *   imports: [RouterModule.forChild(ROUTES)]\n * })\n * class MyNgModule {}\n * ```\n *\n * \\@description\n *\n * Managing state transitions is one of the hardest parts of building applications. This is\n * especially true on the web, where you also need to ensure that the state is reflected in the URL.\n * In addition, we often want to split applications into multiple bundles and load them on demand.\n * Doing this transparently is not trivial.\n *\n * The Angular router solves these problems. Using the router, you can declaratively specify\n * application states, manage state transitions while taking care of the URL, and load bundles on\n * demand.\n *\n * [Read this developer guide](https://angular.io/docs/ts/latest/guide/router.html) to get an\n * overview of how the router should be used.\n *\n * \\@stable\n */\nvar RouterModule = (function () {\n    // Note: We are injecting the Router so it gets created eagerly...\n    function RouterModule(guard, router) {\n    }\n    /**\n     * Creates a module with all the router providers and directives. It also optionally sets up an\n     * application listener to perform an initial navigation.\n     *\n     * Options:\n     * * `enableTracing` makes the router log all its internal events to the console.\n     * * `useHash` enables the location strategy that uses the URL fragment instead of the history\n     * API.\n     * * `initialNavigation` disables the initial navigation.\n     * * `errorHandler` provides a custom error handler.\n     */\n    /**\n     * Creates a module with all the router providers and directives. It also optionally sets up an\n     * application listener to perform an initial navigation.\n     *\n     * Options:\n     * * `enableTracing` makes the router log all its internal events to the console.\n     * * `useHash` enables the location strategy that uses the URL fragment instead of the history\n     * API.\n     * * `initialNavigation` disables the initial navigation.\n     * * `errorHandler` provides a custom error handler.\n     * @param {?} routes\n     * @param {?=} config\n     * @return {?}\n     */\n    RouterModule.forRoot = /**\n     * Creates a module with all the router providers and directives. It also optionally sets up an\n     * application listener to perform an initial navigation.\n     *\n     * Options:\n     * * `enableTracing` makes the router log all its internal events to the console.\n     * * `useHash` enables the location strategy that uses the URL fragment instead of the history\n     * API.\n     * * `initialNavigation` disables the initial navigation.\n     * * `errorHandler` provides a custom error handler.\n     * @param {?} routes\n     * @param {?=} config\n     * @return {?}\n     */\n    function (routes, config) {\n        return {\n            ngModule: RouterModule,\n            providers: [\n                ROUTER_PROVIDERS,\n                provideRoutes(routes),\n                {\n                    provide: ROUTER_FORROOT_GUARD,\n                    useFactory: provideForRootGuard,\n                    deps: [[Router, new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"](), new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"SkipSelf\"]()]]\n                },\n                { provide: ROUTER_CONFIGURATION, useValue: config ? config : {} },\n                {\n                    provide: __WEBPACK_IMPORTED_MODULE_0__angular_common__[\"LocationStrategy\"],\n                    useFactory: provideLocationStrategy,\n                    deps: [\n                        __WEBPACK_IMPORTED_MODULE_0__angular_common__[\"PlatformLocation\"], [new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"](__WEBPACK_IMPORTED_MODULE_0__angular_common__[\"APP_BASE_HREF\"]), new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"]()], ROUTER_CONFIGURATION\n                    ]\n                },\n                {\n                    provide: PreloadingStrategy,\n                    useExisting: config && config.preloadingStrategy ? config.preloadingStrategy :\n                        NoPreloading\n                },\n                { provide: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgProbeToken\"], multi: true, useFactory: routerNgProbeToken },\n                provideRouterInitializer(),\n            ],\n        };\n    };\n    /**\n     * Creates a module with all the router directives and a provider registering routes.\n     */\n    /**\n     * Creates a module with all the router directives and a provider registering routes.\n     * @param {?} routes\n     * @return {?}\n     */\n    RouterModule.forChild = /**\n     * Creates a module with all the router directives and a provider registering routes.\n     * @param {?} routes\n     * @return {?}\n     */\n    function (routes) {\n        return { ngModule: RouterModule, providers: [provideRoutes(routes)] };\n    };\n    RouterModule.decorators = [\n        { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{ declarations: ROUTER_DIRECTIVES, exports: ROUTER_DIRECTIVES },] },\n    ];\n    /** @nocollapse */\n    RouterModule.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"], args: [ROUTER_FORROOT_GUARD,] },] },\n        { type: Router, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\n    ]; };\n    return RouterModule;\n}());\n/**\n * @param {?} platformLocationStrategy\n * @param {?} baseHref\n * @param {?=} options\n * @return {?}\n */\nfunction provideLocationStrategy(platformLocationStrategy, baseHref, options) {\n    if (options === void 0) { options = {}; }\n    return options.useHash ? new __WEBPACK_IMPORTED_MODULE_0__angular_common__[\"HashLocationStrategy\"](platformLocationStrategy, baseHref) :\n        new __WEBPACK_IMPORTED_MODULE_0__angular_common__[\"PathLocationStrategy\"](platformLocationStrategy, baseHref);\n}\n/**\n * @param {?} router\n * @return {?}\n */\nfunction provideForRootGuard(router) {\n    if (router) {\n        throw new Error(\"RouterModule.forRoot() called twice. Lazy loaded modules should use RouterModule.forChild() instead.\");\n    }\n    return 'guarded';\n}\n/**\n * \\@whatItDoes Registers routes.\n *\n * \\@howToUse\n *\n * ```\n * \\@NgModule({\n *   imports: [RouterModule.forChild(ROUTES)],\n *   providers: [provideRoutes(EXTRA_ROUTES)]\n * })\n * class MyNgModule {}\n * ```\n *\n * \\@stable\n * @param {?} routes\n * @return {?}\n */\nfunction provideRoutes(routes) {\n    return [\n        { provide: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ANALYZE_FOR_ENTRY_COMPONENTS\"], multi: true, useValue: routes },\n        { provide: ROUTES, multi: true, useValue: routes },\n    ];\n}\n/**\n * \\@whatItDoes Represents options to configure the router.\n *\n * \\@stable\n * @record\n */\n\n/**\n * @param {?} ref\n * @param {?} urlSerializer\n * @param {?} contexts\n * @param {?} location\n * @param {?} injector\n * @param {?} loader\n * @param {?} compiler\n * @param {?} config\n * @param {?=} opts\n * @param {?=} urlHandlingStrategy\n * @param {?=} routeReuseStrategy\n * @return {?}\n */\nfunction setupRouter(ref, urlSerializer, contexts, location, injector, loader, compiler, config, opts, urlHandlingStrategy, routeReuseStrategy) {\n    if (opts === void 0) { opts = {}; }\n    var /** @type {?} */ router = new Router(null, urlSerializer, contexts, location, injector, loader, compiler, flatten(config));\n    if (urlHandlingStrategy) {\n        router.urlHandlingStrategy = urlHandlingStrategy;\n    }\n    if (routeReuseStrategy) {\n        router.routeReuseStrategy = routeReuseStrategy;\n    }\n    if (opts.errorHandler) {\n        router.errorHandler = opts.errorHandler;\n    }\n    if (opts.enableTracing) {\n        var /** @type {?} */ dom_1 = Object(__WEBPACK_IMPORTED_MODULE_20__angular_platform_browser__[\"getDOM\"])();\n        router.events.subscribe(function (e) {\n            dom_1.logGroup(\"Router Event: \" + ((/** @type {?} */ (e.constructor))).name);\n            dom_1.log(e.toString());\n            dom_1.log(e);\n            dom_1.logGroupEnd();\n        });\n    }\n    return router;\n}\n/**\n * @param {?} router\n * @return {?}\n */\nfunction rootRoute(router) {\n    return router.routerState.root;\n}\n/**\n * To initialize the router properly we need to do in two steps:\n *\n * We need to start the navigation in a APP_INITIALIZER to block the bootstrap if\n * a resolver or a guards executes asynchronously. Second, we need to actually run\n * activation in a BOOTSTRAP_LISTENER. We utilize the afterPreactivation\n * hook provided by the router to do that.\n *\n * The router navigation starts, reaches the point when preactivation is done, and then\n * pauses. It waits for the hook to be resolved. We then resolve it only in a bootstrap listener.\n */\nvar RouterInitializer = (function () {\n    function RouterInitializer(injector) {\n        this.injector = injector;\n        this.initNavigation = false;\n        this.resultOfPreactivationDone = new __WEBPACK_IMPORTED_MODULE_4_rxjs_Subject__[\"Subject\"]();\n    }\n    /**\n     * @return {?}\n     */\n    RouterInitializer.prototype.appInitializer = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        var /** @type {?} */ p = this.injector.get(__WEBPACK_IMPORTED_MODULE_0__angular_common__[\"LOCATION_INITIALIZED\"], Promise.resolve(null));\n        return p.then(function () {\n            var /** @type {?} */ resolve = /** @type {?} */ ((null));\n            var /** @type {?} */ res = new Promise(function (r) { return resolve = r; });\n            var /** @type {?} */ router = _this.injector.get(Router);\n            var /** @type {?} */ opts = _this.injector.get(ROUTER_CONFIGURATION);\n            if (_this.isLegacyDisabled(opts) || _this.isLegacyEnabled(opts)) {\n                resolve(true);\n            }\n            else if (opts.initialNavigation === 'disabled') {\n                router.setUpLocationChangeListener();\n                resolve(true);\n            }\n            else if (opts.initialNavigation === 'enabled') {\n                router.hooks.afterPreactivation = function () {\n                    // only the initial navigation should be delayed\n                    if (!_this.initNavigation) {\n                        _this.initNavigation = true;\n                        resolve(true);\n                        return _this.resultOfPreactivationDone;\n                        // subsequent navigations should not be delayed\n                    }\n                    else {\n                        return /** @type {?} */ (Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_of__[\"of\"])(null));\n                    }\n                };\n                router.initialNavigation();\n            }\n            else {\n                throw new Error(\"Invalid initialNavigation options: '\" + opts.initialNavigation + \"'\");\n            }\n            return res;\n        });\n    };\n    /**\n     * @param {?} bootstrappedComponentRef\n     * @return {?}\n     */\n    RouterInitializer.prototype.bootstrapListener = /**\n     * @param {?} bootstrappedComponentRef\n     * @return {?}\n     */\n    function (bootstrappedComponentRef) {\n        var /** @type {?} */ opts = this.injector.get(ROUTER_CONFIGURATION);\n        var /** @type {?} */ preloader = this.injector.get(RouterPreloader);\n        var /** @type {?} */ router = this.injector.get(Router);\n        var /** @type {?} */ ref = this.injector.get(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ApplicationRef\"]);\n        if (bootstrappedComponentRef !== ref.components[0]) {\n            return;\n        }\n        if (this.isLegacyEnabled(opts)) {\n            router.initialNavigation();\n        }\n        else if (this.isLegacyDisabled(opts)) {\n            router.setUpLocationChangeListener();\n        }\n        preloader.setUpPreloading();\n        router.resetRootComponentType(ref.componentTypes[0]);\n        this.resultOfPreactivationDone.next(/** @type {?} */ ((null)));\n        this.resultOfPreactivationDone.complete();\n    };\n    /**\n     * @param {?} opts\n     * @return {?}\n     */\n    RouterInitializer.prototype.isLegacyEnabled = /**\n     * @param {?} opts\n     * @return {?}\n     */\n    function (opts) {\n        return opts.initialNavigation === 'legacy_enabled' || opts.initialNavigation === true ||\n            opts.initialNavigation === undefined;\n    };\n    /**\n     * @param {?} opts\n     * @return {?}\n     */\n    RouterInitializer.prototype.isLegacyDisabled = /**\n     * @param {?} opts\n     * @return {?}\n     */\n    function (opts) {\n        return opts.initialNavigation === 'legacy_disabled' || opts.initialNavigation === false;\n    };\n    RouterInitializer.decorators = [\n        { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injectable\"] },\n    ];\n    /** @nocollapse */\n    RouterInitializer.ctorParameters = function () { return [\n        { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injector\"], },\n    ]; };\n    return RouterInitializer;\n}());\n/**\n * @param {?} r\n * @return {?}\n */\nfunction getAppInitializer(r) {\n    return r.appInitializer.bind(r);\n}\n/**\n * @param {?} r\n * @return {?}\n */\nfunction getBootstrapListener(r) {\n    return r.bootstrapListener.bind(r);\n}\n/**\n * A token for the router initializer that will be called after the app is bootstrapped.\n *\n * \\@experimental\n */\nvar ROUTER_INITIALIZER = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"InjectionToken\"]('Router Initializer');\n/**\n * @return {?}\n */\nfunction provideRouterInitializer() {\n    return [\n        RouterInitializer,\n        {\n            provide: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"APP_INITIALIZER\"],\n            multi: true,\n            useFactory: getAppInitializer,\n            deps: [RouterInitializer]\n        },\n        { provide: ROUTER_INITIALIZER, useFactory: getBootstrapListener, deps: [RouterInitializer] },\n        { provide: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"APP_BOOTSTRAP_LISTENER\"], multi: true, useExisting: ROUTER_INITIALIZER },\n    ];\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @module\n * @description\n * Entry point for all public APIs of the common package.\n */\n/**\n * \\@stable\n */\nvar VERSION = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Version\"]('5.0.1');\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @module\n * @description\n * Entry point for all public APIs of this package.\n */\n\n// This file only reexports content of the `src` folder. Keep it that way.\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=router.js.map\n\n\n/***/ }),\n/* 43 */,\n/* 44 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar ArrayObservable_1 = __webpack_require__(14);\nexports.of = ArrayObservable_1.ArrayObservable.of;\n//# sourceMappingURL=of.js.map\n\n/***/ }),\n/* 45 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar concatMap_1 = __webpack_require__(75);\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, in a serialized fashion waiting for each one to complete before\n * merging the next.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link concatAll}.</span>\n *\n * <img src=\"./img/concatMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each new inner Observable is\n * concatenated with the previous inner Observable.\n *\n * __Warning:__ if source values arrive endlessly and faster than their\n * corresponding inner Observables can complete, it will result in memory issues\n * as inner Observables amass in an unbounded buffer waiting for their turn to\n * be subscribed to.\n *\n * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set\n * to `1`.\n *\n * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.concatMap(ev => Rx.Observable.interval(1000).take(4));\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n *\n * @see {@link concat}\n * @see {@link concatAll}\n * @see {@link concatMapTo}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and taking values from each projected inner\n * Observable sequentially.\n * @method concatMap\n * @owner Observable\n */\nfunction concatMap(project, resultSelector) {\n    return concatMap_1.concatMap(project, resultSelector)(this);\n}\nexports.concatMap = concatMap;\n//# sourceMappingURL=concatMap.js.map\n\n/***/ }),\n/* 46 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar filter_1 = __webpack_require__(100);\n/* tslint:enable:max-line-length */\n/**\n * Filter items emitted by the source Observable by only emitting those that\n * satisfy a specified predicate.\n *\n * <span class=\"informal\">Like\n * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n * it only emits a value from the source if it passes a criterion function.</span>\n *\n * <img src=\"./img/filter.png\" width=\"100%\">\n *\n * Similar to the well-known `Array.prototype.filter` method, this operator\n * takes values from the source Observable, passes them through a `predicate`\n * function and only emits those values that yielded `true`.\n *\n * @example <caption>Emit only click events whose target was a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');\n * clicksOnDivs.subscribe(x => console.log(x));\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n * @see {@link ignoreElements}\n * @see {@link partition}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted, if `false` the value is not passed to the output\n * Observable. The `index` parameter is the number `i` for the i-th source\n * emission that has happened since the subscription, starting from the number\n * `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable} An Observable of values from the source that were\n * allowed by the `predicate` function.\n * @method filter\n * @owner Observable\n */\nfunction filter(predicate, thisArg) {\n    return filter_1.filter(predicate, thisArg)(this);\n}\nexports.filter = filter;\n//# sourceMappingURL=filter.js.map\n\n/***/ }),\n/* 47 */,\n/* 48 */,\n/* 49 */,\n/* 50 */,\n/* 51 */,\n/* 52 */,\n/* 53 */,\n/* 54 */,\n/* 55 */,\n/* 56 */,\n/* 57 */,\n/* 58 */,\n/* 59 */,\n/* 60 */,\n/* 61 */,\n/* 62 */,\n/* 63 */,\n/* 64 */,\n/* 65 */,\n/* 66 */,\n/* 67 */,\n/* 68 */,\n/* 69 */,\n/* 70 */,\n/* 71 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(process) {\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar platform_browser_dynamic_1 = __webpack_require__(36);\r\nvar core_1 = __webpack_require__(2);\r\nvar root_module_1 = __webpack_require__(72);\r\nif (process.env.NODE_ENV === 'production') {\r\n    core_1.enableProdMode();\r\n}\r\nplatform_browser_dynamic_1.platformBrowserDynamic().bootstrapModule(root_module_1.RootModule);\r\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22)))\n\n/***/ }),\n/* 72 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar core_1 = __webpack_require__(2);\r\nvar platform_browser_1 = __webpack_require__(5);\r\nvar root_routing_module_1 = __webpack_require__(73);\r\nvar root_component_1 = __webpack_require__(104);\r\nvar home_component_1 = __webpack_require__(39);\r\nvar page_not_found_component_1 = __webpack_require__(40);\r\nvar RootModule = /** @class */ (function () {\r\n    function RootModule() {\r\n    }\r\n    RootModule = __decorate([\r\n        core_1.NgModule({\r\n            imports: [\r\n                platform_browser_1.BrowserModule,\r\n                root_routing_module_1.RootRoutingModule\r\n            ],\r\n            declarations: [\r\n                root_component_1.RootComponent,\r\n                home_component_1.HomeComponent,\r\n                page_not_found_component_1.PageNotFoundComponent\r\n            ],\r\n            bootstrap: [root_component_1.RootComponent]\r\n        })\r\n    ], RootModule);\r\n    return RootModule;\r\n}());\r\nexports.RootModule = RootModule;\r\n\n\n/***/ }),\n/* 73 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar core_1 = __webpack_require__(2);\r\nvar router_1 = __webpack_require__(42);\r\nvar home_component_1 = __webpack_require__(39);\r\nvar page_not_found_component_1 = __webpack_require__(40);\r\nvar appRoutes = [\r\n    { path: '', redirectTo: 'home', pathMatch: 'full' },\r\n    { path: 'home', component: home_component_1.HomeComponent },\r\n    {\r\n        path: 'employees',\r\n        loadChildren: function () { return new Promise(function (resolve) { __webpack_require__.e/* require.ensure */(0).then((function (require) { resolve(__webpack_require__(107)['EmployeesModule']); }).bind(null, __webpack_require__)).catch(__webpack_require__.oe); }); }\r\n    },\r\n    { path: '**', component: page_not_found_component_1.PageNotFoundComponent }\r\n];\r\nvar RootRoutingModule = /** @class */ (function () {\r\n    function RootRoutingModule() {\r\n    }\r\n    RootRoutingModule = __decorate([\r\n        core_1.NgModule({\r\n            imports: [\r\n                router_1.RouterModule.forRoot(appRoutes\r\n                //,{ enableTracing: true } // <-- debugging purposes only\r\n                )\r\n            ],\r\n            exports: [\r\n                router_1.RouterModule\r\n            ]\r\n        })\r\n    ], RootRoutingModule);\r\n    return RootRoutingModule;\r\n}());\r\nexports.RootRoutingModule = RootRoutingModule;\r\n\n\n/***/ }),\n/* 74 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = __webpack_require__(7);\nvar ObjectUnsubscribedError_1 = __webpack_require__(33);\n/**\n * @class BehaviorSubject<T>\n */\nvar BehaviorSubject = (function (_super) {\n    __extends(BehaviorSubject, _super);\n    function BehaviorSubject(_value) {\n        _super.call(this);\n        this._value = _value;\n    }\n    Object.defineProperty(BehaviorSubject.prototype, \"value\", {\n        get: function () {\n            return this.getValue();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    BehaviorSubject.prototype._subscribe = function (subscriber) {\n        var subscription = _super.prototype._subscribe.call(this, subscriber);\n        if (subscription && !subscription.closed) {\n            subscriber.next(this._value);\n        }\n        return subscription;\n    };\n    BehaviorSubject.prototype.getValue = function () {\n        if (this.hasError) {\n            throw this.thrownError;\n        }\n        else if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        else {\n            return this._value;\n        }\n    };\n    BehaviorSubject.prototype.next = function (value) {\n        _super.prototype.next.call(this, this._value = value);\n    };\n    return BehaviorSubject;\n}(Subject_1.Subject));\nexports.BehaviorSubject = BehaviorSubject;\n//# sourceMappingURL=BehaviorSubject.js.map\n\n/***/ }),\n/* 75 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar mergeMap_1 = __webpack_require__(16);\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, in a serialized fashion waiting for each one to complete before\n * merging the next.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link concatAll}.</span>\n *\n * <img src=\"./img/concatMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each new inner Observable is\n * concatenated with the previous inner Observable.\n *\n * __Warning:__ if source values arrive endlessly and faster than their\n * corresponding inner Observables can complete, it will result in memory issues\n * as inner Observables amass in an unbounded buffer waiting for their turn to\n * be subscribed to.\n *\n * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set\n * to `1`.\n *\n * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.concatMap(ev => Rx.Observable.interval(1000).take(4));\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n *\n * @see {@link concat}\n * @see {@link concatAll}\n * @see {@link concatMapTo}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and taking values from each projected inner\n * Observable sequentially.\n * @method concatMap\n * @owner Observable\n */\nfunction concatMap(project, resultSelector) {\n    return mergeMap_1.mergeMap(project, resultSelector, 1);\n}\nexports.concatMap = concatMap;\n//# sourceMappingURL=concatMap.js.map\n\n/***/ }),\n/* 76 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar mergeMap_1 = __webpack_require__(16);\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link mergeAll}.</span>\n *\n * <img src=\"./img/mergeMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger.\n *\n * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>\n * var letters = Rx.Observable.of('a', 'b', 'c');\n * var result = letters.mergeMap(x =>\n *   Rx.Observable.interval(1000).map(i => x+i)\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // a0\n * // b0\n * // c0\n * // a1\n * // b1\n * // c1\n * // continues to list a,b,c with respective ascending integers\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and merging the results of the Observables obtained\n * from this transformation.\n * @method mergeMap\n * @owner Observable\n */\nfunction mergeMap(project, resultSelector, concurrent) {\n    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n    return mergeMap_1.mergeMap(project, resultSelector, concurrent)(this);\n}\nexports.mergeMap = mergeMap;\n//# sourceMappingURL=mergeMap.js.map\n\n/***/ }),\n/* 77 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar FromObservable_1 = __webpack_require__(78);\nexports.from = FromObservable_1.FromObservable.create;\n//# sourceMappingURL=from.js.map\n\n/***/ }),\n/* 78 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isArray_1 = __webpack_require__(11);\nvar isArrayLike_1 = __webpack_require__(31);\nvar isPromise_1 = __webpack_require__(32);\nvar PromiseObservable_1 = __webpack_require__(38);\nvar IteratorObservable_1 = __webpack_require__(79);\nvar ArrayObservable_1 = __webpack_require__(14);\nvar ArrayLikeObservable_1 = __webpack_require__(80);\nvar iterator_1 = __webpack_require__(18);\nvar Observable_1 = __webpack_require__(0);\nvar observeOn_1 = __webpack_require__(81);\nvar observable_1 = __webpack_require__(13);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar FromObservable = (function (_super) {\n    __extends(FromObservable, _super);\n    function FromObservable(ish, scheduler) {\n        _super.call(this, null);\n        this.ish = ish;\n        this.scheduler = scheduler;\n    }\n    /**\n     * Creates an Observable from an Array, an array-like object, a Promise, an\n     * iterable object, or an Observable-like object.\n     *\n     * <span class=\"informal\">Converts almost anything to an Observable.</span>\n     *\n     * <img src=\"./img/from.png\" width=\"100%\">\n     *\n     * Convert various other objects and data types into Observables. `from`\n     * converts a Promise or an array-like or an\n     * [iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable)\n     * object into an Observable that emits the items in that promise or array or\n     * iterable. A String, in this context, is treated as an array of characters.\n     * Observable-like objects (contains a function named with the ES2015 Symbol\n     * for Observable) can also be converted through this operator.\n     *\n     * @example <caption>Converts an array to an Observable</caption>\n     * var array = [10, 20, 30];\n     * var result = Rx.Observable.from(array);\n     * result.subscribe(x => console.log(x));\n     *\n     * // Results in the following:\n     * // 10 20 30\n     *\n     * @example <caption>Convert an infinite iterable (from a generator) to an Observable</caption>\n     * function* generateDoubles(seed) {\n     *   var i = seed;\n     *   while (true) {\n     *     yield i;\n     *     i = 2 * i; // double it\n     *   }\n     * }\n     *\n     * var iterator = generateDoubles(3);\n     * var result = Rx.Observable.from(iterator).take(10);\n     * result.subscribe(x => console.log(x));\n     *\n     * // Results in the following:\n     * // 3 6 12 24 48 96 192 384 768 1536\n     *\n     * @see {@link create}\n     * @see {@link fromEvent}\n     * @see {@link fromEventPattern}\n     * @see {@link fromPromise}\n     *\n     * @param {ObservableInput<T>} ish A subscribable object, a Promise, an\n     * Observable-like, an Array, an iterable or an array-like object to be\n     * converted.\n     * @param {Scheduler} [scheduler] The scheduler on which to schedule the\n     * emissions of values.\n     * @return {Observable<T>} The Observable whose values are originally from the\n     * input object that was converted.\n     * @static true\n     * @name from\n     * @owner Observable\n     */\n    FromObservable.create = function (ish, scheduler) {\n        if (ish != null) {\n            if (typeof ish[observable_1.observable] === 'function') {\n                if (ish instanceof Observable_1.Observable && !scheduler) {\n                    return ish;\n                }\n                return new FromObservable(ish, scheduler);\n            }\n            else if (isArray_1.isArray(ish)) {\n                return new ArrayObservable_1.ArrayObservable(ish, scheduler);\n            }\n            else if (isPromise_1.isPromise(ish)) {\n                return new PromiseObservable_1.PromiseObservable(ish, scheduler);\n            }\n            else if (typeof ish[iterator_1.iterator] === 'function' || typeof ish === 'string') {\n                return new IteratorObservable_1.IteratorObservable(ish, scheduler);\n            }\n            else if (isArrayLike_1.isArrayLike(ish)) {\n                return new ArrayLikeObservable_1.ArrayLikeObservable(ish, scheduler);\n            }\n        }\n        throw new TypeError((ish !== null && typeof ish || ish) + ' is not observable');\n    };\n    FromObservable.prototype._subscribe = function (subscriber) {\n        var ish = this.ish;\n        var scheduler = this.scheduler;\n        if (scheduler == null) {\n            return ish[observable_1.observable]().subscribe(subscriber);\n        }\n        else {\n            return ish[observable_1.observable]().subscribe(new observeOn_1.ObserveOnSubscriber(subscriber, scheduler, 0));\n        }\n    };\n    return FromObservable;\n}(Observable_1.Observable));\nexports.FromObservable = FromObservable;\n//# sourceMappingURL=FromObservable.js.map\n\n/***/ }),\n/* 79 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar root_1 = __webpack_require__(4);\nvar Observable_1 = __webpack_require__(0);\nvar iterator_1 = __webpack_require__(18);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar IteratorObservable = (function (_super) {\n    __extends(IteratorObservable, _super);\n    function IteratorObservable(iterator, scheduler) {\n        _super.call(this);\n        this.scheduler = scheduler;\n        if (iterator == null) {\n            throw new Error('iterator cannot be null.');\n        }\n        this.iterator = getIterator(iterator);\n    }\n    IteratorObservable.create = function (iterator, scheduler) {\n        return new IteratorObservable(iterator, scheduler);\n    };\n    IteratorObservable.dispatch = function (state) {\n        var index = state.index, hasError = state.hasError, iterator = state.iterator, subscriber = state.subscriber;\n        if (hasError) {\n            subscriber.error(state.error);\n            return;\n        }\n        var result = iterator.next();\n        if (result.done) {\n            subscriber.complete();\n            return;\n        }\n        subscriber.next(result.value);\n        state.index = index + 1;\n        if (subscriber.closed) {\n            if (typeof iterator.return === 'function') {\n                iterator.return();\n            }\n            return;\n        }\n        this.schedule(state);\n    };\n    IteratorObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var _a = this, iterator = _a.iterator, scheduler = _a.scheduler;\n        if (scheduler) {\n            return scheduler.schedule(IteratorObservable.dispatch, 0, {\n                index: index, iterator: iterator, subscriber: subscriber\n            });\n        }\n        else {\n            do {\n                var result = iterator.next();\n                if (result.done) {\n                    subscriber.complete();\n                    break;\n                }\n                else {\n                    subscriber.next(result.value);\n                }\n                if (subscriber.closed) {\n                    if (typeof iterator.return === 'function') {\n                        iterator.return();\n                    }\n                    break;\n                }\n            } while (true);\n        }\n    };\n    return IteratorObservable;\n}(Observable_1.Observable));\nexports.IteratorObservable = IteratorObservable;\nvar StringIterator = (function () {\n    function StringIterator(str, idx, len) {\n        if (idx === void 0) { idx = 0; }\n        if (len === void 0) { len = str.length; }\n        this.str = str;\n        this.idx = idx;\n        this.len = len;\n    }\n    StringIterator.prototype[iterator_1.iterator] = function () { return (this); };\n    StringIterator.prototype.next = function () {\n        return this.idx < this.len ? {\n            done: false,\n            value: this.str.charAt(this.idx++)\n        } : {\n            done: true,\n            value: undefined\n        };\n    };\n    return StringIterator;\n}());\nvar ArrayIterator = (function () {\n    function ArrayIterator(arr, idx, len) {\n        if (idx === void 0) { idx = 0; }\n        if (len === void 0) { len = toLength(arr); }\n        this.arr = arr;\n        this.idx = idx;\n        this.len = len;\n    }\n    ArrayIterator.prototype[iterator_1.iterator] = function () { return this; };\n    ArrayIterator.prototype.next = function () {\n        return this.idx < this.len ? {\n            done: false,\n            value: this.arr[this.idx++]\n        } : {\n            done: true,\n            value: undefined\n        };\n    };\n    return ArrayIterator;\n}());\nfunction getIterator(obj) {\n    var i = obj[iterator_1.iterator];\n    if (!i && typeof obj === 'string') {\n        return new StringIterator(obj);\n    }\n    if (!i && obj.length !== undefined) {\n        return new ArrayIterator(obj);\n    }\n    if (!i) {\n        throw new TypeError('object is not iterable');\n    }\n    return obj[iterator_1.iterator]();\n}\nvar maxSafeInteger = Math.pow(2, 53) - 1;\nfunction toLength(o) {\n    var len = +o.length;\n    if (isNaN(len)) {\n        return 0;\n    }\n    if (len === 0 || !numberIsFinite(len)) {\n        return len;\n    }\n    len = sign(len) * Math.floor(Math.abs(len));\n    if (len <= 0) {\n        return 0;\n    }\n    if (len > maxSafeInteger) {\n        return maxSafeInteger;\n    }\n    return len;\n}\nfunction numberIsFinite(value) {\n    return typeof value === 'number' && root_1.root.isFinite(value);\n}\nfunction sign(value) {\n    var valueAsNumber = +value;\n    if (valueAsNumber === 0) {\n        return valueAsNumber;\n    }\n    if (isNaN(valueAsNumber)) {\n        return valueAsNumber;\n    }\n    return valueAsNumber < 0 ? -1 : 1;\n}\n//# sourceMappingURL=IteratorObservable.js.map\n\n/***/ }),\n/* 80 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(0);\nvar ScalarObservable_1 = __webpack_require__(29);\nvar EmptyObservable_1 = __webpack_require__(10);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar ArrayLikeObservable = (function (_super) {\n    __extends(ArrayLikeObservable, _super);\n    function ArrayLikeObservable(arrayLike, scheduler) {\n        _super.call(this);\n        this.arrayLike = arrayLike;\n        this.scheduler = scheduler;\n        if (!scheduler && arrayLike.length === 1) {\n            this._isScalar = true;\n            this.value = arrayLike[0];\n        }\n    }\n    ArrayLikeObservable.create = function (arrayLike, scheduler) {\n        var length = arrayLike.length;\n        if (length === 0) {\n            return new EmptyObservable_1.EmptyObservable();\n        }\n        else if (length === 1) {\n            return new ScalarObservable_1.ScalarObservable(arrayLike[0], scheduler);\n        }\n        else {\n            return new ArrayLikeObservable(arrayLike, scheduler);\n        }\n    };\n    ArrayLikeObservable.dispatch = function (state) {\n        var arrayLike = state.arrayLike, index = state.index, length = state.length, subscriber = state.subscriber;\n        if (subscriber.closed) {\n            return;\n        }\n        if (index >= length) {\n            subscriber.complete();\n            return;\n        }\n        subscriber.next(arrayLike[index]);\n        state.index = index + 1;\n        this.schedule(state);\n    };\n    ArrayLikeObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var _a = this, arrayLike = _a.arrayLike, scheduler = _a.scheduler;\n        var length = arrayLike.length;\n        if (scheduler) {\n            return scheduler.schedule(ArrayLikeObservable.dispatch, 0, {\n                arrayLike: arrayLike, index: index, length: length, subscriber: subscriber\n            });\n        }\n        else {\n            for (var i = 0; i < length && !subscriber.closed; i++) {\n                subscriber.next(arrayLike[i]);\n            }\n            subscriber.complete();\n        }\n    };\n    return ArrayLikeObservable;\n}(Observable_1.Observable));\nexports.ArrayLikeObservable = ArrayLikeObservable;\n//# sourceMappingURL=ArrayLikeObservable.js.map\n\n/***/ }),\n/* 81 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(1);\nvar Notification_1 = __webpack_require__(82);\n/**\n *\n * Re-emits all notifications from source Observable with specified scheduler.\n *\n * <span class=\"informal\">Ensure a specific scheduler is used, from outside of an Observable.</span>\n *\n * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule\n * notifications emitted by the source Observable. It might be useful, if you do not have control over\n * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.\n *\n * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,\n * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal\n * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits\n * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.\n * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split\n * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source\n * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a\n * little bit more, to ensure that they are emitted at expected moments.\n *\n * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications\n * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`\n * will delay all notifications - including error notifications - while `delay` will pass through error\n * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator\n * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used\n * for notification emissions in general.\n *\n * @example <caption>Ensure values in subscribe are called just before browser repaint.</caption>\n * const intervals = Rx.Observable.interval(10); // Intervals are scheduled\n *                                               // with async scheduler by default...\n *\n * intervals\n * .observeOn(Rx.Scheduler.animationFrame)       // ...but we will observe on animationFrame\n * .subscribe(val => {                           // scheduler to ensure smooth animation.\n *   someDiv.style.height = val + 'px';\n * });\n *\n * @see {@link delay}\n *\n * @param {IScheduler} scheduler Scheduler that will be used to reschedule notifications from source Observable.\n * @param {number} [delay] Number of milliseconds that states with what delay every notification should be rescheduled.\n * @return {Observable<T>} Observable that emits the same notifications as the source Observable,\n * but with provided scheduler.\n *\n * @method observeOn\n * @owner Observable\n */\nfunction observeOn(scheduler, delay) {\n    if (delay === void 0) { delay = 0; }\n    return function observeOnOperatorFunction(source) {\n        return source.lift(new ObserveOnOperator(scheduler, delay));\n    };\n}\nexports.observeOn = observeOn;\nvar ObserveOnOperator = (function () {\n    function ObserveOnOperator(scheduler, delay) {\n        if (delay === void 0) { delay = 0; }\n        this.scheduler = scheduler;\n        this.delay = delay;\n    }\n    ObserveOnOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));\n    };\n    return ObserveOnOperator;\n}());\nexports.ObserveOnOperator = ObserveOnOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ObserveOnSubscriber = (function (_super) {\n    __extends(ObserveOnSubscriber, _super);\n    function ObserveOnSubscriber(destination, scheduler, delay) {\n        if (delay === void 0) { delay = 0; }\n        _super.call(this, destination);\n        this.scheduler = scheduler;\n        this.delay = delay;\n    }\n    ObserveOnSubscriber.dispatch = function (arg) {\n        var notification = arg.notification, destination = arg.destination;\n        notification.observe(destination);\n        this.unsubscribe();\n    };\n    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {\n        this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));\n    };\n    ObserveOnSubscriber.prototype._next = function (value) {\n        this.scheduleMessage(Notification_1.Notification.createNext(value));\n    };\n    ObserveOnSubscriber.prototype._error = function (err) {\n        this.scheduleMessage(Notification_1.Notification.createError(err));\n    };\n    ObserveOnSubscriber.prototype._complete = function () {\n        this.scheduleMessage(Notification_1.Notification.createComplete());\n    };\n    return ObserveOnSubscriber;\n}(Subscriber_1.Subscriber));\nexports.ObserveOnSubscriber = ObserveOnSubscriber;\nvar ObserveOnMessage = (function () {\n    function ObserveOnMessage(notification, destination) {\n        this.notification = notification;\n        this.destination = destination;\n    }\n    return ObserveOnMessage;\n}());\nexports.ObserveOnMessage = ObserveOnMessage;\n//# sourceMappingURL=observeOn.js.map\n\n/***/ }),\n/* 82 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\n/**\n * Represents a push-based event or value that an {@link Observable} can emit.\n * This class is particularly useful for operators that manage notifications,\n * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and\n * others. Besides wrapping the actual delivered value, it also annotates it\n * with metadata of, for instance, what type of push message it is (`next`,\n * `error`, or `complete`).\n *\n * @see {@link materialize}\n * @see {@link dematerialize}\n * @see {@link observeOn}\n *\n * @class Notification<T>\n */\nvar Notification = (function () {\n    function Notification(kind, value, error) {\n        this.kind = kind;\n        this.value = value;\n        this.error = error;\n        this.hasValue = kind === 'N';\n    }\n    /**\n     * Delivers to the given `observer` the value wrapped by this Notification.\n     * @param {Observer} observer\n     * @return\n     */\n    Notification.prototype.observe = function (observer) {\n        switch (this.kind) {\n            case 'N':\n                return observer.next && observer.next(this.value);\n            case 'E':\n                return observer.error && observer.error(this.error);\n            case 'C':\n                return observer.complete && observer.complete();\n        }\n    };\n    /**\n     * Given some {@link Observer} callbacks, deliver the value represented by the\n     * current Notification to the correctly corresponding callback.\n     * @param {function(value: T): void} next An Observer `next` callback.\n     * @param {function(err: any): void} [error] An Observer `error` callback.\n     * @param {function(): void} [complete] An Observer `complete` callback.\n     * @return {any}\n     */\n    Notification.prototype.do = function (next, error, complete) {\n        var kind = this.kind;\n        switch (kind) {\n            case 'N':\n                return next && next(this.value);\n            case 'E':\n                return error && error(this.error);\n            case 'C':\n                return complete && complete();\n        }\n    };\n    /**\n     * Takes an Observer or its individual callback functions, and calls `observe`\n     * or `do` methods accordingly.\n     * @param {Observer|function(value: T): void} nextOrObserver An Observer or\n     * the `next` callback.\n     * @param {function(err: any): void} [error] An Observer `error` callback.\n     * @param {function(): void} [complete] An Observer `complete` callback.\n     * @return {any}\n     */\n    Notification.prototype.accept = function (nextOrObserver, error, complete) {\n        if (nextOrObserver && typeof nextOrObserver.next === 'function') {\n            return this.observe(nextOrObserver);\n        }\n        else {\n            return this.do(nextOrObserver, error, complete);\n        }\n    };\n    /**\n     * Returns a simple Observable that just delivers the notification represented\n     * by this Notification instance.\n     * @return {any}\n     */\n    Notification.prototype.toObservable = function () {\n        var kind = this.kind;\n        switch (kind) {\n            case 'N':\n                return Observable_1.Observable.of(this.value);\n            case 'E':\n                return Observable_1.Observable.throw(this.error);\n            case 'C':\n                return Observable_1.Observable.empty();\n        }\n        throw new Error('unexpected notification kind value');\n    };\n    /**\n     * A shortcut to create a Notification instance of the type `next` from a\n     * given value.\n     * @param {T} value The `next` value.\n     * @return {Notification<T>} The \"next\" Notification representing the\n     * argument.\n     */\n    Notification.createNext = function (value) {\n        if (typeof value !== 'undefined') {\n            return new Notification('N', value);\n        }\n        return Notification.undefinedValueNotification;\n    };\n    /**\n     * A shortcut to create a Notification instance of the type `error` from a\n     * given error.\n     * @param {any} [err] The `error` error.\n     * @return {Notification<T>} The \"error\" Notification representing the\n     * argument.\n     */\n    Notification.createError = function (err) {\n        return new Notification('E', undefined, err);\n    };\n    /**\n     * A shortcut to create a Notification instance of the type `complete`.\n     * @return {Notification<any>} The valueless \"complete\" Notification.\n     */\n    Notification.createComplete = function () {\n        return Notification.completeNotification;\n    };\n    Notification.completeNotification = new Notification('C');\n    Notification.undefinedValueNotification = new Notification('N', undefined);\n    return Notification;\n}());\nexports.Notification = Notification;\n//# sourceMappingURL=Notification.js.map\n\n/***/ }),\n/* 83 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar catchError_1 = __webpack_require__(84);\n/**\n * Catches errors on the observable to be handled by returning a new observable or throwing an error.\n *\n * <img src=\"./img/catch.png\" width=\"100%\">\n *\n * @example <caption>Continues with a different Observable when there's an error</caption>\n *\n * Observable.of(1, 2, 3, 4, 5)\n *   .map(n => {\n * \t   if (n == 4) {\n * \t     throw 'four!';\n *     }\n *\t   return n;\n *   })\n *   .catch(err => Observable.of('I', 'II', 'III', 'IV', 'V'))\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, I, II, III, IV, V\n *\n * @example <caption>Retries the caught source Observable again in case of error, similar to retry() operator</caption>\n *\n * Observable.of(1, 2, 3, 4, 5)\n *   .map(n => {\n * \t   if (n === 4) {\n * \t     throw 'four!';\n *     }\n * \t   return n;\n *   })\n *   .catch((err, caught) => caught)\n *   .take(30)\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, 1, 2, 3, ...\n *\n * @example <caption>Throws a new error when the source Observable throws an error</caption>\n *\n * Observable.of(1, 2, 3, 4, 5)\n *   .map(n => {\n *     if (n == 4) {\n *       throw 'four!';\n *     }\n *     return n;\n *   })\n *   .catch(err => {\n *     throw 'error in source. Details: ' + err;\n *   })\n *   .subscribe(\n *     x => console.log(x),\n *     err => console.log(err)\n *   );\n *   // 1, 2, 3, error in source. Details: four!\n *\n * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which\n *  is the source observable, in case you'd like to \"retry\" that observable by returning it again. Whatever observable\n *  is returned by the `selector` will be used to continue the observable chain.\n * @return {Observable} An observable that originates from either the source or the observable returned by the\n *  catch `selector` function.\n * @method catch\n * @name catch\n * @owner Observable\n */\nfunction _catch(selector) {\n    return catchError_1.catchError(selector)(this);\n}\nexports._catch = _catch;\n//# sourceMappingURL=catch.js.map\n\n/***/ }),\n/* 84 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(19);\nvar subscribeToResult_1 = __webpack_require__(17);\n/**\n * Catches errors on the observable to be handled by returning a new observable or throwing an error.\n *\n * <img src=\"./img/catch.png\" width=\"100%\">\n *\n * @example <caption>Continues with a different Observable when there's an error</caption>\n *\n * Observable.of(1, 2, 3, 4, 5)\n *   .map(n => {\n * \t   if (n == 4) {\n * \t     throw 'four!';\n *     }\n *\t   return n;\n *   })\n *   .catch(err => Observable.of('I', 'II', 'III', 'IV', 'V'))\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, I, II, III, IV, V\n *\n * @example <caption>Retries the caught source Observable again in case of error, similar to retry() operator</caption>\n *\n * Observable.of(1, 2, 3, 4, 5)\n *   .map(n => {\n * \t   if (n === 4) {\n * \t     throw 'four!';\n *     }\n * \t   return n;\n *   })\n *   .catch((err, caught) => caught)\n *   .take(30)\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, 1, 2, 3, ...\n *\n * @example <caption>Throws a new error when the source Observable throws an error</caption>\n *\n * Observable.of(1, 2, 3, 4, 5)\n *   .map(n => {\n *     if (n == 4) {\n *       throw 'four!';\n *     }\n *     return n;\n *   })\n *   .catch(err => {\n *     throw 'error in source. Details: ' + err;\n *   })\n *   .subscribe(\n *     x => console.log(x),\n *     err => console.log(err)\n *   );\n *   // 1, 2, 3, error in source. Details: four!\n *\n * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which\n *  is the source observable, in case you'd like to \"retry\" that observable by returning it again. Whatever observable\n *  is returned by the `selector` will be used to continue the observable chain.\n * @return {Observable} An observable that originates from either the source or the observable returned by the\n *  catch `selector` function.\n * @name catchError\n */\nfunction catchError(selector) {\n    return function catchErrorOperatorFunction(source) {\n        var operator = new CatchOperator(selector);\n        var caught = source.lift(operator);\n        return (operator.caught = caught);\n    };\n}\nexports.catchError = catchError;\nvar CatchOperator = (function () {\n    function CatchOperator(selector) {\n        this.selector = selector;\n    }\n    CatchOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));\n    };\n    return CatchOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar CatchSubscriber = (function (_super) {\n    __extends(CatchSubscriber, _super);\n    function CatchSubscriber(destination, selector, caught) {\n        _super.call(this, destination);\n        this.selector = selector;\n        this.caught = caught;\n    }\n    // NOTE: overriding `error` instead of `_error` because we don't want\n    // to have this flag this subscriber as `isStopped`. We can mimic the\n    // behavior of the RetrySubscriber (from the `retry` operator), where\n    // we unsubscribe from our source chain, reset our Subscriber flags,\n    // then subscribe to the selector result.\n    CatchSubscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            var result = void 0;\n            try {\n                result = this.selector(err, this.caught);\n            }\n            catch (err2) {\n                _super.prototype.error.call(this, err2);\n                return;\n            }\n            this._unsubscribeAndRecycle();\n            this.add(subscribeToResult_1.subscribeToResult(this, result));\n        }\n    };\n    return CatchSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=catchError.js.map\n\n/***/ }),\n/* 85 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar concatAll_1 = __webpack_require__(86);\n/* tslint:enable:max-line-length */\n/**\n * Converts a higher-order Observable into a first-order Observable by\n * concatenating the inner Observables in order.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by putting one\n * inner Observable after the other.</span>\n *\n * <img src=\"./img/concatAll.png\" width=\"100%\">\n *\n * Joins every Observable emitted by the source (a higher-order Observable), in\n * a serial fashion. It subscribes to each inner Observable only after the\n * previous inner Observable has completed, and merges all of their values into\n * the returned observable.\n *\n * __Warning:__ If the source Observable emits Observables quickly and\n * endlessly, and the inner Observables it emits generally complete slower than\n * the source emits, you can run into memory issues as the incoming Observables\n * collect in an unbounded buffer.\n *\n * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set\n * to `1`.\n *\n * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map(ev => Rx.Observable.interval(1000).take(4));\n * var firstOrder = higherOrder.concatAll();\n * firstOrder.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n *\n * @see {@link combineAll}\n * @see {@link concat}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n * @see {@link exhaust}\n * @see {@link mergeAll}\n * @see {@link switch}\n * @see {@link zipAll}\n *\n * @return {Observable} An Observable emitting values from all the inner\n * Observables concatenated.\n * @method concatAll\n * @owner Observable\n */\nfunction concatAll() {\n    return concatAll_1.concatAll()(this);\n}\nexports.concatAll = concatAll;\n//# sourceMappingURL=concatAll.js.map\n\n/***/ }),\n/* 86 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar mergeAll_1 = __webpack_require__(15);\n/**\n * Converts a higher-order Observable into a first-order Observable by\n * concatenating the inner Observables in order.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by putting one\n * inner Observable after the other.</span>\n *\n * <img src=\"./img/concatAll.png\" width=\"100%\">\n *\n * Joins every Observable emitted by the source (a higher-order Observable), in\n * a serial fashion. It subscribes to each inner Observable only after the\n * previous inner Observable has completed, and merges all of their values into\n * the returned observable.\n *\n * __Warning:__ If the source Observable emits Observables quickly and\n * endlessly, and the inner Observables it emits generally complete slower than\n * the source emits, you can run into memory issues as the incoming Observables\n * collect in an unbounded buffer.\n *\n * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set\n * to `1`.\n *\n * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map(ev => Rx.Observable.interval(1000).take(4));\n * var firstOrder = higherOrder.concatAll();\n * firstOrder.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n *\n * @see {@link combineAll}\n * @see {@link concat}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n * @see {@link exhaust}\n * @see {@link mergeAll}\n * @see {@link switch}\n * @see {@link zipAll}\n *\n * @return {Observable} An Observable emitting values from all the inner\n * Observables concatenated.\n * @method concatAll\n * @owner Observable\n */\nfunction concatAll() {\n    return mergeAll_1.mergeAll(1);\n}\nexports.concatAll = concatAll;\n//# sourceMappingURL=concatAll.js.map\n\n/***/ }),\n/* 87 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar first_1 = __webpack_require__(88);\n/**\n * Emits only the first value (or the first value that meets some condition)\n * emitted by the source Observable.\n *\n * <span class=\"informal\">Emits only the first value. Or emits only the first\n * value that passes some test.</span>\n *\n * <img src=\"./img/first.png\" width=\"100%\">\n *\n * If called with no arguments, `first` emits the first value of the source\n * Observable, then completes. If called with a `predicate` function, `first`\n * emits the first value of the source that matches the specified condition. It\n * may also take a `resultSelector` function to produce the output value from\n * the input value, and a `defaultValue` to emit in case the source completes\n * before it is able to emit a valid value. Throws an error if `defaultValue`\n * was not provided and a matching element is not found.\n *\n * @example <caption>Emit only the first click that happens on the DOM</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.first();\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Emits the first click that happens on a DIV</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.first(ev => ev.target.tagName === 'DIV');\n * result.subscribe(x => console.log(x));\n *\n * @see {@link filter}\n * @see {@link find}\n * @see {@link take}\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} [predicate]\n * An optional function called with each item to test for condition matching.\n * @param {function(value: T, index: number): R} [resultSelector] A function to\n * produce the value on the output Observable based on the values\n * and the indices of the source Observable. The arguments passed to this\n * function are:\n * - `value`: the value that was emitted on the source.\n * - `index`: the \"index\" of the value from the source.\n * @param {R} [defaultValue] The default value emitted in case no valid value\n * was found on the source.\n * @return {Observable<T|R>} An Observable of the first item that matches the\n * condition.\n * @method first\n * @owner Observable\n */\nfunction first(predicate, resultSelector, defaultValue) {\n    return first_1.first(predicate, resultSelector, defaultValue)(this);\n}\nexports.first = first;\n//# sourceMappingURL=first.js.map\n\n/***/ }),\n/* 88 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(1);\nvar EmptyError_1 = __webpack_require__(20);\n/**\n * Emits only the first value (or the first value that meets some condition)\n * emitted by the source Observable.\n *\n * <span class=\"informal\">Emits only the first value. Or emits only the first\n * value that passes some test.</span>\n *\n * <img src=\"./img/first.png\" width=\"100%\">\n *\n * If called with no arguments, `first` emits the first value of the source\n * Observable, then completes. If called with a `predicate` function, `first`\n * emits the first value of the source that matches the specified condition. It\n * may also take a `resultSelector` function to produce the output value from\n * the input value, and a `defaultValue` to emit in case the source completes\n * before it is able to emit a valid value. Throws an error if `defaultValue`\n * was not provided and a matching element is not found.\n *\n * @example <caption>Emit only the first click that happens on the DOM</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.first();\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Emits the first click that happens on a DIV</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.first(ev => ev.target.tagName === 'DIV');\n * result.subscribe(x => console.log(x));\n *\n * @see {@link filter}\n * @see {@link find}\n * @see {@link take}\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} [predicate]\n * An optional function called with each item to test for condition matching.\n * @param {function(value: T, index: number): R} [resultSelector] A function to\n * produce the value on the output Observable based on the values\n * and the indices of the source Observable. The arguments passed to this\n * function are:\n * - `value`: the value that was emitted on the source.\n * - `index`: the \"index\" of the value from the source.\n * @param {R} [defaultValue] The default value emitted in case no valid value\n * was found on the source.\n * @return {Observable<T|R>} An Observable of the first item that matches the\n * condition.\n * @method first\n * @owner Observable\n */\nfunction first(predicate, resultSelector, defaultValue) {\n    return function (source) { return source.lift(new FirstOperator(predicate, resultSelector, defaultValue, source)); };\n}\nexports.first = first;\nvar FirstOperator = (function () {\n    function FirstOperator(predicate, resultSelector, defaultValue, source) {\n        this.predicate = predicate;\n        this.resultSelector = resultSelector;\n        this.defaultValue = defaultValue;\n        this.source = source;\n    }\n    FirstOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new FirstSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));\n    };\n    return FirstOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar FirstSubscriber = (function (_super) {\n    __extends(FirstSubscriber, _super);\n    function FirstSubscriber(destination, predicate, resultSelector, defaultValue, source) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.resultSelector = resultSelector;\n        this.defaultValue = defaultValue;\n        this.source = source;\n        this.index = 0;\n        this.hasCompleted = false;\n        this._emitted = false;\n    }\n    FirstSubscriber.prototype._next = function (value) {\n        var index = this.index++;\n        if (this.predicate) {\n            this._tryPredicate(value, index);\n        }\n        else {\n            this._emit(value, index);\n        }\n    };\n    FirstSubscriber.prototype._tryPredicate = function (value, index) {\n        var result;\n        try {\n            result = this.predicate(value, index, this.source);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        if (result) {\n            this._emit(value, index);\n        }\n    };\n    FirstSubscriber.prototype._emit = function (value, index) {\n        if (this.resultSelector) {\n            this._tryResultSelector(value, index);\n            return;\n        }\n        this._emitFinal(value);\n    };\n    FirstSubscriber.prototype._tryResultSelector = function (value, index) {\n        var result;\n        try {\n            result = this.resultSelector(value, index);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this._emitFinal(result);\n    };\n    FirstSubscriber.prototype._emitFinal = function (value) {\n        var destination = this.destination;\n        if (!this._emitted) {\n            this._emitted = true;\n            destination.next(value);\n            destination.complete();\n            this.hasCompleted = true;\n        }\n    };\n    FirstSubscriber.prototype._complete = function () {\n        var destination = this.destination;\n        if (!this.hasCompleted && typeof this.defaultValue !== 'undefined') {\n            destination.next(this.defaultValue);\n            destination.complete();\n        }\n        else if (!this.hasCompleted) {\n            destination.error(new EmptyError_1.EmptyError);\n        }\n    };\n    return FirstSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=first.js.map\n\n/***/ }),\n/* 89 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar every_1 = __webpack_require__(90);\n/**\n * Returns an Observable that emits whether or not every item of the source satisfies the condition specified.\n *\n * @example <caption>A simple example emitting true if all elements are less than 5, false otherwise</caption>\n *  Observable.of(1, 2, 3, 4, 5, 6)\n *     .every(x => x < 5)\n *     .subscribe(x => console.log(x)); // -> false\n *\n * @param {function} predicate A function for determining if an item meets a specified condition.\n * @param {any} [thisArg] Optional object to use for `this` in the callback.\n * @return {Observable} An Observable of booleans that determines if all items of the source Observable meet the condition specified.\n * @method every\n * @owner Observable\n */\nfunction every(predicate, thisArg) {\n    return every_1.every(predicate, thisArg)(this);\n}\nexports.every = every;\n//# sourceMappingURL=every.js.map\n\n/***/ }),\n/* 90 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(1);\n/**\n * Returns an Observable that emits whether or not every item of the source satisfies the condition specified.\n *\n * @example <caption>A simple example emitting true if all elements are less than 5, false otherwise</caption>\n *  Observable.of(1, 2, 3, 4, 5, 6)\n *     .every(x => x < 5)\n *     .subscribe(x => console.log(x)); // -> false\n *\n * @param {function} predicate A function for determining if an item meets a specified condition.\n * @param {any} [thisArg] Optional object to use for `this` in the callback.\n * @return {Observable} An Observable of booleans that determines if all items of the source Observable meet the condition specified.\n * @method every\n * @owner Observable\n */\nfunction every(predicate, thisArg) {\n    return function (source) { return source.lift(new EveryOperator(predicate, thisArg, source)); };\n}\nexports.every = every;\nvar EveryOperator = (function () {\n    function EveryOperator(predicate, thisArg, source) {\n        this.predicate = predicate;\n        this.thisArg = thisArg;\n        this.source = source;\n    }\n    EveryOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));\n    };\n    return EveryOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar EverySubscriber = (function (_super) {\n    __extends(EverySubscriber, _super);\n    function EverySubscriber(destination, predicate, thisArg, source) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.thisArg = thisArg;\n        this.source = source;\n        this.index = 0;\n        this.thisArg = thisArg || this;\n    }\n    EverySubscriber.prototype.notifyComplete = function (everyValueMatch) {\n        this.destination.next(everyValueMatch);\n        this.destination.complete();\n    };\n    EverySubscriber.prototype._next = function (value) {\n        var result = false;\n        try {\n            result = this.predicate.call(this.thisArg, value, this.index++, this.source);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        if (!result) {\n            this.notifyComplete(false);\n        }\n    };\n    EverySubscriber.prototype._complete = function () {\n        this.notifyComplete(true);\n    };\n    return EverySubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=every.js.map\n\n/***/ }),\n/* 91 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar last_1 = __webpack_require__(92);\n/* tslint:enable:max-line-length */\n/**\n * Returns an Observable that emits only the last item emitted by the source Observable.\n * It optionally takes a predicate function as a parameter, in which case, rather than emitting\n * the last item from the source Observable, the resulting Observable will emit the last item\n * from the source Observable that satisfies the predicate.\n *\n * <img src=\"./img/last.png\" width=\"100%\">\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n * @param {function} predicate - The condition any source emitted item has to satisfy.\n * @return {Observable} An Observable that emits only the last item satisfying the given condition\n * from the source, or an NoSuchElementException if no such items are emitted.\n * @throws - Throws if no items that match the predicate are emitted by the source Observable.\n * @method last\n * @owner Observable\n */\nfunction last(predicate, resultSelector, defaultValue) {\n    return last_1.last(predicate, resultSelector, defaultValue)(this);\n}\nexports.last = last;\n//# sourceMappingURL=last.js.map\n\n/***/ }),\n/* 92 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(1);\nvar EmptyError_1 = __webpack_require__(20);\n/* tslint:enable:max-line-length */\n/**\n * Returns an Observable that emits only the last item emitted by the source Observable.\n * It optionally takes a predicate function as a parameter, in which case, rather than emitting\n * the last item from the source Observable, the resulting Observable will emit the last item\n * from the source Observable that satisfies the predicate.\n *\n * <img src=\"./img/last.png\" width=\"100%\">\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n * @param {function} predicate - The condition any source emitted item has to satisfy.\n * @return {Observable} An Observable that emits only the last item satisfying the given condition\n * from the source, or an NoSuchElementException if no such items are emitted.\n * @throws - Throws if no items that match the predicate are emitted by the source Observable.\n * @method last\n * @owner Observable\n */\nfunction last(predicate, resultSelector, defaultValue) {\n    return function (source) { return source.lift(new LastOperator(predicate, resultSelector, defaultValue, source)); };\n}\nexports.last = last;\nvar LastOperator = (function () {\n    function LastOperator(predicate, resultSelector, defaultValue, source) {\n        this.predicate = predicate;\n        this.resultSelector = resultSelector;\n        this.defaultValue = defaultValue;\n        this.source = source;\n    }\n    LastOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new LastSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));\n    };\n    return LastOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar LastSubscriber = (function (_super) {\n    __extends(LastSubscriber, _super);\n    function LastSubscriber(destination, predicate, resultSelector, defaultValue, source) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.resultSelector = resultSelector;\n        this.defaultValue = defaultValue;\n        this.source = source;\n        this.hasValue = false;\n        this.index = 0;\n        if (typeof defaultValue !== 'undefined') {\n            this.lastValue = defaultValue;\n            this.hasValue = true;\n        }\n    }\n    LastSubscriber.prototype._next = function (value) {\n        var index = this.index++;\n        if (this.predicate) {\n            this._tryPredicate(value, index);\n        }\n        else {\n            if (this.resultSelector) {\n                this._tryResultSelector(value, index);\n                return;\n            }\n            this.lastValue = value;\n            this.hasValue = true;\n        }\n    };\n    LastSubscriber.prototype._tryPredicate = function (value, index) {\n        var result;\n        try {\n            result = this.predicate(value, index, this.source);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        if (result) {\n            if (this.resultSelector) {\n                this._tryResultSelector(value, index);\n                return;\n            }\n            this.lastValue = value;\n            this.hasValue = true;\n        }\n    };\n    LastSubscriber.prototype._tryResultSelector = function (value, index) {\n        var result;\n        try {\n            result = this.resultSelector(value, index);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.lastValue = result;\n        this.hasValue = true;\n    };\n    LastSubscriber.prototype._complete = function () {\n        var destination = this.destination;\n        if (this.hasValue) {\n            destination.next(this.lastValue);\n            destination.complete();\n        }\n        else {\n            destination.error(new EmptyError_1.EmptyError);\n        }\n    };\n    return LastSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=last.js.map\n\n/***/ }),\n/* 93 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar mergeAll_1 = __webpack_require__(15);\n/**\n * Converts a higher-order Observable into a first-order Observable which\n * concurrently delivers all values that are emitted on the inner Observables.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables.</span>\n *\n * <img src=\"./img/mergeAll.png\" width=\"100%\">\n *\n * `mergeAll` subscribes to an Observable that emits Observables, also known as\n * a higher-order Observable. Each time it observes one of these emitted inner\n * Observables, it subscribes to that and delivers all the values from the\n * inner Observable on the output Observable. The output Observable only\n * completes once all inner Observables have completed. Any error delivered by\n * a inner Observable will be immediately emitted on the output Observable.\n *\n * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));\n * var firstOrder = higherOrder.mergeAll();\n * firstOrder.subscribe(x => console.log(x));\n *\n * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));\n * var firstOrder = higherOrder.mergeAll(2);\n * firstOrder.subscribe(x => console.log(x));\n *\n * @see {@link combineAll}\n * @see {@link concatAll}\n * @see {@link exhaust}\n * @see {@link merge}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switch}\n * @see {@link zipAll}\n *\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits values coming from all the\n * inner Observables emitted by the source Observable.\n * @method mergeAll\n * @owner Observable\n */\nfunction mergeAll(concurrent) {\n    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n    return mergeAll_1.mergeAll(concurrent)(this);\n}\nexports.mergeAll = mergeAll;\n//# sourceMappingURL=mergeAll.js.map\n\n/***/ }),\n/* 94 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar reduce_1 = __webpack_require__(95);\n/* tslint:enable:max-line-length */\n/**\n * Applies an accumulator function over the source Observable, and returns the\n * accumulated result when the source completes, given an optional seed value.\n *\n * <span class=\"informal\">Combines together all values emitted on the source,\n * using an accumulator function that knows how to join a new source value into\n * the accumulation from the past.</span>\n *\n * <img src=\"./img/reduce.png\" width=\"100%\">\n *\n * Like\n * [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce),\n * `reduce` applies an `accumulator` function against an accumulation and each\n * value of the source Observable (from the past) to reduce it to a single\n * value, emitted on the output Observable. Note that `reduce` will only emit\n * one value, only when the source Observable completes. It is equivalent to\n * applying operator {@link scan} followed by operator {@link last}.\n *\n * Returns an Observable that applies a specified `accumulator` function to each\n * item emitted by the source Observable. If a `seed` value is specified, then\n * that value will be used as the initial value for the accumulator. If no seed\n * value is specified, the first item of the source is used as the seed.\n *\n * @example <caption>Count the number of click events that happened in 5 seconds</caption>\n * var clicksInFiveSeconds = Rx.Observable.fromEvent(document, 'click')\n *   .takeUntil(Rx.Observable.interval(5000));\n * var ones = clicksInFiveSeconds.mapTo(1);\n * var seed = 0;\n * var count = ones.reduce((acc, one) => acc + one, seed);\n * count.subscribe(x => console.log(x));\n *\n * @see {@link count}\n * @see {@link expand}\n * @see {@link mergeScan}\n * @see {@link scan}\n *\n * @param {function(acc: R, value: T, index: number): R} accumulator The accumulator function\n * called on each source value.\n * @param {R} [seed] The initial accumulation value.\n * @return {Observable<R>} An Observable that emits a single value that is the\n * result of accumulating the values emitted by the source Observable.\n * @method reduce\n * @owner Observable\n */\nfunction reduce(accumulator, seed) {\n    // providing a seed of `undefined` *should* be valid and trigger\n    // hasSeed! so don't use `seed !== undefined` checks!\n    // For this reason, we have to check it here at the original call site\n    // otherwise inside Operator/Subscriber we won't know if `undefined`\n    // means they didn't provide anything or if they literally provided `undefined`\n    if (arguments.length >= 2) {\n        return reduce_1.reduce(accumulator, seed)(this);\n    }\n    return reduce_1.reduce(accumulator)(this);\n}\nexports.reduce = reduce;\n//# sourceMappingURL=reduce.js.map\n\n/***/ }),\n/* 95 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar scan_1 = __webpack_require__(96);\nvar takeLast_1 = __webpack_require__(97);\nvar defaultIfEmpty_1 = __webpack_require__(99);\nvar pipe_1 = __webpack_require__(27);\n/* tslint:enable:max-line-length */\n/**\n * Applies an accumulator function over the source Observable, and returns the\n * accumulated result when the source completes, given an optional seed value.\n *\n * <span class=\"informal\">Combines together all values emitted on the source,\n * using an accumulator function that knows how to join a new source value into\n * the accumulation from the past.</span>\n *\n * <img src=\"./img/reduce.png\" width=\"100%\">\n *\n * Like\n * [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce),\n * `reduce` applies an `accumulator` function against an accumulation and each\n * value of the source Observable (from the past) to reduce it to a single\n * value, emitted on the output Observable. Note that `reduce` will only emit\n * one value, only when the source Observable completes. It is equivalent to\n * applying operator {@link scan} followed by operator {@link last}.\n *\n * Returns an Observable that applies a specified `accumulator` function to each\n * item emitted by the source Observable. If a `seed` value is specified, then\n * that value will be used as the initial value for the accumulator. If no seed\n * value is specified, the first item of the source is used as the seed.\n *\n * @example <caption>Count the number of click events that happened in 5 seconds</caption>\n * var clicksInFiveSeconds = Rx.Observable.fromEvent(document, 'click')\n *   .takeUntil(Rx.Observable.interval(5000));\n * var ones = clicksInFiveSeconds.mapTo(1);\n * var seed = 0;\n * var count = ones.reduce((acc, one) => acc + one, seed);\n * count.subscribe(x => console.log(x));\n *\n * @see {@link count}\n * @see {@link expand}\n * @see {@link mergeScan}\n * @see {@link scan}\n *\n * @param {function(acc: R, value: T, index: number): R} accumulator The accumulator function\n * called on each source value.\n * @param {R} [seed] The initial accumulation value.\n * @return {Observable<R>} An Observable that emits a single value that is the\n * result of accumulating the values emitted by the source Observable.\n * @method reduce\n * @owner Observable\n */\nfunction reduce(accumulator, seed) {\n    // providing a seed of `undefined` *should* be valid and trigger\n    // hasSeed! so don't use `seed !== undefined` checks!\n    // For this reason, we have to check it here at the original call site\n    // otherwise inside Operator/Subscriber we won't know if `undefined`\n    // means they didn't provide anything or if they literally provided `undefined`\n    if (arguments.length >= 2) {\n        return function reduceOperatorFunctionWithSeed(source) {\n            return pipe_1.pipe(scan_1.scan(accumulator, seed), takeLast_1.takeLast(1), defaultIfEmpty_1.defaultIfEmpty(seed))(source);\n        };\n    }\n    return function reduceOperatorFunction(source) {\n        return pipe_1.pipe(scan_1.scan(function (acc, value, index) {\n            return accumulator(acc, value, index + 1);\n        }), takeLast_1.takeLast(1))(source);\n    };\n}\nexports.reduce = reduce;\n//# sourceMappingURL=reduce.js.map\n\n/***/ }),\n/* 96 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(1);\n/* tslint:enable:max-line-length */\n/**\n * Applies an accumulator function over the source Observable, and returns each\n * intermediate result, with an optional seed value.\n *\n * <span class=\"informal\">It's like {@link reduce}, but emits the current\n * accumulation whenever the source emits a value.</span>\n *\n * <img src=\"./img/scan.png\" width=\"100%\">\n *\n * Combines together all values emitted on the source, using an accumulator\n * function that knows how to join a new source value into the accumulation from\n * the past. Is similar to {@link reduce}, but emits the intermediate\n * accumulations.\n *\n * Returns an Observable that applies a specified `accumulator` function to each\n * item emitted by the source Observable. If a `seed` value is specified, then\n * that value will be used as the initial value for the accumulator. If no seed\n * value is specified, the first item of the source is used as the seed.\n *\n * @example <caption>Count the number of click events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var ones = clicks.mapTo(1);\n * var seed = 0;\n * var count = ones.scan((acc, one) => acc + one, seed);\n * count.subscribe(x => console.log(x));\n *\n * @see {@link expand}\n * @see {@link mergeScan}\n * @see {@link reduce}\n *\n * @param {function(acc: R, value: T, index: number): R} accumulator\n * The accumulator function called on each source value.\n * @param {T|R} [seed] The initial accumulation value.\n * @return {Observable<R>} An observable of the accumulated values.\n * @method scan\n * @owner Observable\n */\nfunction scan(accumulator, seed) {\n    var hasSeed = false;\n    // providing a seed of `undefined` *should* be valid and trigger\n    // hasSeed! so don't use `seed !== undefined` checks!\n    // For this reason, we have to check it here at the original call site\n    // otherwise inside Operator/Subscriber we won't know if `undefined`\n    // means they didn't provide anything or if they literally provided `undefined`\n    if (arguments.length >= 2) {\n        hasSeed = true;\n    }\n    return function scanOperatorFunction(source) {\n        return source.lift(new ScanOperator(accumulator, seed, hasSeed));\n    };\n}\nexports.scan = scan;\nvar ScanOperator = (function () {\n    function ScanOperator(accumulator, seed, hasSeed) {\n        if (hasSeed === void 0) { hasSeed = false; }\n        this.accumulator = accumulator;\n        this.seed = seed;\n        this.hasSeed = hasSeed;\n    }\n    ScanOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));\n    };\n    return ScanOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ScanSubscriber = (function (_super) {\n    __extends(ScanSubscriber, _super);\n    function ScanSubscriber(destination, accumulator, _seed, hasSeed) {\n        _super.call(this, destination);\n        this.accumulator = accumulator;\n        this._seed = _seed;\n        this.hasSeed = hasSeed;\n        this.index = 0;\n    }\n    Object.defineProperty(ScanSubscriber.prototype, \"seed\", {\n        get: function () {\n            return this._seed;\n        },\n        set: function (value) {\n            this.hasSeed = true;\n            this._seed = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ScanSubscriber.prototype._next = function (value) {\n        if (!this.hasSeed) {\n            this.seed = value;\n            this.destination.next(value);\n        }\n        else {\n            return this._tryNext(value);\n        }\n    };\n    ScanSubscriber.prototype._tryNext = function (value) {\n        var index = this.index++;\n        var result;\n        try {\n            result = this.accumulator(this.seed, value, index);\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n        this.seed = result;\n        this.destination.next(result);\n    };\n    return ScanSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=scan.js.map\n\n/***/ }),\n/* 97 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(1);\nvar ArgumentOutOfRangeError_1 = __webpack_require__(98);\nvar EmptyObservable_1 = __webpack_require__(10);\n/**\n * Emits only the last `count` values emitted by the source Observable.\n *\n * <span class=\"informal\">Remembers the latest `count` values, then emits those\n * only when the source completes.</span>\n *\n * <img src=\"./img/takeLast.png\" width=\"100%\">\n *\n * `takeLast` returns an Observable that emits at most the last `count` values\n * emitted by the source Observable. If the source emits fewer than `count`\n * values then all of its values are emitted. This operator must wait until the\n * `complete` notification emission from the source in order to emit the `next`\n * values on the output Observable, because otherwise it is impossible to know\n * whether or not more values will be emitted on the source. For this reason,\n * all values are emitted synchronously, followed by the complete notification.\n *\n * @example <caption>Take the last 3 values of an Observable with many values</caption>\n * var many = Rx.Observable.range(1, 100);\n * var lastThree = many.takeLast(3);\n * lastThree.subscribe(x => console.log(x));\n *\n * @see {@link take}\n * @see {@link takeUntil}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @throws {ArgumentOutOfRangeError} When using `takeLast(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.\n *\n * @param {number} count The maximum number of values to emit from the end of\n * the sequence of values emitted by the source Observable.\n * @return {Observable<T>} An Observable that emits at most the last count\n * values emitted by the source Observable.\n * @method takeLast\n * @owner Observable\n */\nfunction takeLast(count) {\n    return function takeLastOperatorFunction(source) {\n        if (count === 0) {\n            return new EmptyObservable_1.EmptyObservable();\n        }\n        else {\n            return source.lift(new TakeLastOperator(count));\n        }\n    };\n}\nexports.takeLast = takeLast;\nvar TakeLastOperator = (function () {\n    function TakeLastOperator(total) {\n        this.total = total;\n        if (this.total < 0) {\n            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;\n        }\n    }\n    TakeLastOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new TakeLastSubscriber(subscriber, this.total));\n    };\n    return TakeLastOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar TakeLastSubscriber = (function (_super) {\n    __extends(TakeLastSubscriber, _super);\n    function TakeLastSubscriber(destination, total) {\n        _super.call(this, destination);\n        this.total = total;\n        this.ring = new Array();\n        this.count = 0;\n    }\n    TakeLastSubscriber.prototype._next = function (value) {\n        var ring = this.ring;\n        var total = this.total;\n        var count = this.count++;\n        if (ring.length < total) {\n            ring.push(value);\n        }\n        else {\n            var index = count % total;\n            ring[index] = value;\n        }\n    };\n    TakeLastSubscriber.prototype._complete = function () {\n        var destination = this.destination;\n        var count = this.count;\n        if (count > 0) {\n            var total = this.count >= this.total ? this.total : this.count;\n            var ring = this.ring;\n            for (var i = 0; i < total; i++) {\n                var idx = (count++) % total;\n                destination.next(ring[idx]);\n            }\n        }\n        destination.complete();\n    };\n    return TakeLastSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=takeLast.js.map\n\n/***/ }),\n/* 98 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * An error thrown when an element was queried at a certain index of an\n * Observable, but no such index or position exists in that sequence.\n *\n * @see {@link elementAt}\n * @see {@link take}\n * @see {@link takeLast}\n *\n * @class ArgumentOutOfRangeError\n */\nvar ArgumentOutOfRangeError = (function (_super) {\n    __extends(ArgumentOutOfRangeError, _super);\n    function ArgumentOutOfRangeError() {\n        var err = _super.call(this, 'argument out of range');\n        this.name = err.name = 'ArgumentOutOfRangeError';\n        this.stack = err.stack;\n        this.message = err.message;\n    }\n    return ArgumentOutOfRangeError;\n}(Error));\nexports.ArgumentOutOfRangeError = ArgumentOutOfRangeError;\n//# sourceMappingURL=ArgumentOutOfRangeError.js.map\n\n/***/ }),\n/* 99 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(1);\n/* tslint:enable:max-line-length */\n/**\n * Emits a given value if the source Observable completes without emitting any\n * `next` value, otherwise mirrors the source Observable.\n *\n * <span class=\"informal\">If the source Observable turns out to be empty, then\n * this operator will emit a default value.</span>\n *\n * <img src=\"./img/defaultIfEmpty.png\" width=\"100%\">\n *\n * `defaultIfEmpty` emits the values emitted by the source Observable or a\n * specified default value if the source Observable is empty (completes without\n * having emitted any `next` value).\n *\n * @example <caption>If no clicks happen in 5 seconds, then emit \"no clicks\"</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var clicksBeforeFive = clicks.takeUntil(Rx.Observable.interval(5000));\n * var result = clicksBeforeFive.defaultIfEmpty('no clicks');\n * result.subscribe(x => console.log(x));\n *\n * @see {@link empty}\n * @see {@link last}\n *\n * @param {any} [defaultValue=null] The default value used if the source\n * Observable is empty.\n * @return {Observable} An Observable that emits either the specified\n * `defaultValue` if the source Observable emits no items, or the values emitted\n * by the source Observable.\n * @method defaultIfEmpty\n * @owner Observable\n */\nfunction defaultIfEmpty(defaultValue) {\n    if (defaultValue === void 0) { defaultValue = null; }\n    return function (source) { return source.lift(new DefaultIfEmptyOperator(defaultValue)); };\n}\nexports.defaultIfEmpty = defaultIfEmpty;\nvar DefaultIfEmptyOperator = (function () {\n    function DefaultIfEmptyOperator(defaultValue) {\n        this.defaultValue = defaultValue;\n    }\n    DefaultIfEmptyOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));\n    };\n    return DefaultIfEmptyOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DefaultIfEmptySubscriber = (function (_super) {\n    __extends(DefaultIfEmptySubscriber, _super);\n    function DefaultIfEmptySubscriber(destination, defaultValue) {\n        _super.call(this, destination);\n        this.defaultValue = defaultValue;\n        this.isEmpty = true;\n    }\n    DefaultIfEmptySubscriber.prototype._next = function (value) {\n        this.isEmpty = false;\n        this.destination.next(value);\n    };\n    DefaultIfEmptySubscriber.prototype._complete = function () {\n        if (this.isEmpty) {\n            this.destination.next(this.defaultValue);\n        }\n        this.destination.complete();\n    };\n    return DefaultIfEmptySubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=defaultIfEmpty.js.map\n\n/***/ }),\n/* 100 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(1);\n/* tslint:enable:max-line-length */\n/**\n * Filter items emitted by the source Observable by only emitting those that\n * satisfy a specified predicate.\n *\n * <span class=\"informal\">Like\n * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n * it only emits a value from the source if it passes a criterion function.</span>\n *\n * <img src=\"./img/filter.png\" width=\"100%\">\n *\n * Similar to the well-known `Array.prototype.filter` method, this operator\n * takes values from the source Observable, passes them through a `predicate`\n * function and only emits those values that yielded `true`.\n *\n * @example <caption>Emit only click events whose target was a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');\n * clicksOnDivs.subscribe(x => console.log(x));\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n * @see {@link ignoreElements}\n * @see {@link partition}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted, if `false` the value is not passed to the output\n * Observable. The `index` parameter is the number `i` for the i-th source\n * emission that has happened since the subscription, starting from the number\n * `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable} An Observable of values from the source that were\n * allowed by the `predicate` function.\n * @method filter\n * @owner Observable\n */\nfunction filter(predicate, thisArg) {\n    return function filterOperatorFunction(source) {\n        return source.lift(new FilterOperator(predicate, thisArg));\n    };\n}\nexports.filter = filter;\nvar FilterOperator = (function () {\n    function FilterOperator(predicate, thisArg) {\n        this.predicate = predicate;\n        this.thisArg = thisArg;\n    }\n    FilterOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));\n    };\n    return FilterOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar FilterSubscriber = (function (_super) {\n    __extends(FilterSubscriber, _super);\n    function FilterSubscriber(destination, predicate, thisArg) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.thisArg = thisArg;\n        this.count = 0;\n    }\n    // the try catch block below is left specifically for\n    // optimization and perf reasons. a tryCatcher is not necessary here.\n    FilterSubscriber.prototype._next = function (value) {\n        var result;\n        try {\n            result = this.predicate.call(this.thisArg, value, this.count++);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        if (result) {\n            this.destination.next(value);\n        }\n    };\n    return FilterSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=filter.js.map\n\n/***/ }),\n/* 101 */\n/***/ (function(module, exports) {\n\nmodule.exports = \"<h1>Home</h1>\\r\\n<p>\\r\\n    Welcome to the home page...\\r\\n</p>\";\n\n/***/ }),\n/* 102 */\n/***/ (function(module, exports) {\n\nmodule.exports = \"\\r\\n<h1>Page not found</h1>\";\n\n/***/ }),\n/* 103 */,\n/* 104 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar core_1 = __webpack_require__(2);\r\nvar RootComponent = /** @class */ (function () {\r\n    function RootComponent() {\r\n    }\r\n    RootComponent = __decorate([\r\n        core_1.Component({\r\n            selector: 'internal-root',\r\n            template: __webpack_require__(105)\r\n        })\r\n    ], RootComponent);\r\n    return RootComponent;\r\n}());\r\nexports.RootComponent = RootComponent;\r\n\n\n/***/ }),\n/* 105 */\n/***/ (function(module, exports) {\n\nmodule.exports = \"<div class=\\\"container-fluid\\\">\\r\\n    <div class=\\\"row\\\">\\r\\n        <div class=\\\"col-md-2\\\">\\r\\n            <ul class='list-unstyled'>\\r\\n                <li>\\r\\n                    <a routerLink=\\\"/home\\\" routerLinkActive=\\\"active-link\\\">Home</a>\\r\\n                </li>\\r\\n                <li>\\r\\n                    <a routerLink=\\\"/employees\\\" routerLinkActive=\\\"active-link\\\">Employees</a>\\r\\n                </li>\\r\\n            </ul>\\r\\n        </div>\\r\\n        <div class=\\\"col-md-10\\\">\\r\\n            <router-outlet></router-outlet>\\r\\n        </div>\\r\\n    </div>\\r\\n</div>\\r\\n\";\n\n/***/ })\n]),[71]);\n\n\n// WEBPACK FOOTER //\n// main-bundle.js","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * An error thrown when an Observable or a sequence was queried but has no\n * elements.\n *\n * @see {@link first}\n * @see {@link last}\n * @see {@link single}\n *\n * @class EmptyError\n */\nvar EmptyError = (function (_super) {\n    __extends(EmptyError, _super);\n    function EmptyError() {\n        var err = _super.call(this, 'no elements in sequence');\n        this.name = err.name = 'EmptyError';\n        this.stack = err.stack;\n        this.message = err.message;\n    }\n    return EmptyError;\n}(Error));\nexports.EmptyError = EmptyError;\n//# sourceMappingURL=EmptyError.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/util/EmptyError.js\n// module id = 20\n// module chunks = 2","import { Component } from '@angular/core';\r\n\r\n@Component({\r\n    selector: 'internal-home',\r\n    template: require('./home.component.html')\r\n})\r\nexport class HomeComponent {\r\n   \r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/angular2-template-loader!./node_modules/angular-router-loader/src!./components/root-module/home/home.component.ts","import { Component } from '@angular/core';\r\n\r\n@Component({   \r\n    template: require('./page-not-found.component.html')\r\n})\r\nexport class PageNotFoundComponent { }\r\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/angular2-template-loader!./node_modules/angular-router-loader/src!./components/root-module/page-not-found/page-not-found.component.ts","/**\n * @license Angular v5.0.1\n * (c) 2010-2017 Google, Inc. https://angular.io/\n * License: MIT\n */\nimport { APP_BASE_HREF, HashLocationStrategy, LOCATION_INITIALIZED, Location, LocationStrategy, PathLocationStrategy, PlatformLocation } from '@angular/common';\nimport { ANALYZE_FOR_ENTRY_COMPONENTS, APP_BOOTSTRAP_LISTENER, APP_INITIALIZER, ApplicationRef, Attribute, ChangeDetectorRef, Compiler, ComponentFactoryResolver, ContentChildren, Directive, ElementRef, EventEmitter, HostBinding, HostListener, Inject, Injectable, InjectionToken, Injector, Input, NgModule, NgModuleFactory, NgModuleFactoryLoader, NgModuleRef, NgProbeToken, Optional, Output, Renderer2, SkipSelf, SystemJsNgModuleLoader, Version, ViewContainerRef, isDevMode, isObservable, isPromise } from '@angular/core';\nimport { __assign, __extends } from 'tslib';\nimport { BehaviorSubject } from 'rxjs/BehaviorSubject';\nimport { Subject } from 'rxjs/Subject';\nimport { of } from 'rxjs/observable/of';\nimport { concatMap } from 'rxjs/operator/concatMap';\nimport { map } from 'rxjs/operator/map';\nimport { mergeMap } from 'rxjs/operator/mergeMap';\nimport { Observable } from 'rxjs/Observable';\nimport { from } from 'rxjs/observable/from';\nimport { _catch } from 'rxjs/operator/catch';\nimport { concatAll } from 'rxjs/operator/concatAll';\nimport { first } from 'rxjs/operator/first';\nimport { EmptyError } from 'rxjs/util/EmptyError';\nimport { fromPromise } from 'rxjs/observable/fromPromise';\nimport { every } from 'rxjs/operator/every';\nimport { last } from 'rxjs/operator/last';\nimport { mergeAll } from 'rxjs/operator/mergeAll';\nimport { reduce } from 'rxjs/operator/reduce';\nimport { getDOM } from '@angular/platform-browser';\nimport { filter } from 'rxjs/operator/filter';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * \\@whatItDoes Base for events the Router goes through, as opposed to events tied to a specific\n * Route. `RouterEvent`s will only be fired one time for any given navigation.\n *\n * Example:\n *\n * ```\n * class MyService {\n *   constructor(public router: Router, logger: Logger) {\n *     router.events.filter(e => e instanceof RouterEvent).subscribe(e => {\n *       logger.log(e.id, e.url);\n *     });\n *   }\n * }\n * ```\n *\n * \\@experimental\n */\nvar RouterEvent = (function () {\n    function RouterEvent(id, url) {\n        this.id = id;\n        this.url = url;\n    }\n    return RouterEvent;\n}());\n/**\n * \\@whatItDoes Represents an event triggered when a navigation starts.\n *\n * \\@stable\n */\nvar NavigationStart = (function (_super) {\n    __extends(NavigationStart, _super);\n    function NavigationStart() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /** @docsNotRequired */\n    /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    NavigationStart.prototype.toString = /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    function () { return \"NavigationStart(id: \" + this.id + \", url: '\" + this.url + \"')\"; };\n    return NavigationStart;\n}(RouterEvent));\n/**\n * \\@whatItDoes Represents an event triggered when a navigation ends successfully.\n *\n * \\@stable\n */\nvar NavigationEnd = (function (_super) {\n    __extends(NavigationEnd, _super);\n    function NavigationEnd(/** @docsNotRequired */\n        /** @docsNotRequired */\n        id, /** @docsNotRequired */\n        /** @docsNotRequired */\n        url, urlAfterRedirects) {\n        var _this = _super.call(this, id, url) || this;\n        _this.urlAfterRedirects = urlAfterRedirects;\n        return _this;\n    }\n    /** @docsNotRequired */\n    /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    NavigationEnd.prototype.toString = /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    function () {\n        return \"NavigationEnd(id: \" + this.id + \", url: '\" + this.url + \"', urlAfterRedirects: '\" + this.urlAfterRedirects + \"')\";\n    };\n    return NavigationEnd;\n}(RouterEvent));\n/**\n * \\@whatItDoes Represents an event triggered when a navigation is canceled.\n *\n * \\@stable\n */\nvar NavigationCancel = (function (_super) {\n    __extends(NavigationCancel, _super);\n    function NavigationCancel(/** @docsNotRequired */\n        /** @docsNotRequired */\n        id, /** @docsNotRequired */\n        /** @docsNotRequired */\n        url, reason) {\n        var _this = _super.call(this, id, url) || this;\n        _this.reason = reason;\n        return _this;\n    }\n    /** @docsNotRequired */\n    /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    NavigationCancel.prototype.toString = /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    function () { return \"NavigationCancel(id: \" + this.id + \", url: '\" + this.url + \"')\"; };\n    return NavigationCancel;\n}(RouterEvent));\n/**\n * \\@whatItDoes Represents an event triggered when a navigation fails due to an unexpected error.\n *\n * \\@stable\n */\nvar NavigationError = (function (_super) {\n    __extends(NavigationError, _super);\n    function NavigationError(/** @docsNotRequired */\n        /** @docsNotRequired */\n        id, /** @docsNotRequired */\n        /** @docsNotRequired */\n        url, error) {\n        var _this = _super.call(this, id, url) || this;\n        _this.error = error;\n        return _this;\n    }\n    /** @docsNotRequired */\n    /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    NavigationError.prototype.toString = /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    function () {\n        return \"NavigationError(id: \" + this.id + \", url: '\" + this.url + \"', error: \" + this.error + \")\";\n    };\n    return NavigationError;\n}(RouterEvent));\n/**\n * \\@whatItDoes Represents an event triggered when routes are recognized.\n *\n * \\@stable\n */\nvar RoutesRecognized = (function (_super) {\n    __extends(RoutesRecognized, _super);\n    function RoutesRecognized(/** @docsNotRequired */\n        /** @docsNotRequired */\n        id, /** @docsNotRequired */\n        /** @docsNotRequired */\n        url, urlAfterRedirects, state) {\n        var _this = _super.call(this, id, url) || this;\n        _this.urlAfterRedirects = urlAfterRedirects;\n        _this.state = state;\n        return _this;\n    }\n    /** @docsNotRequired */\n    /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    RoutesRecognized.prototype.toString = /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    function () {\n        return \"RoutesRecognized(id: \" + this.id + \", url: '\" + this.url + \"', urlAfterRedirects: '\" + this.urlAfterRedirects + \"', state: \" + this.state + \")\";\n    };\n    return RoutesRecognized;\n}(RouterEvent));\n/**\n * \\@whatItDoes Represents the start of the Guard phase of routing.\n *\n * \\@experimental\n */\nvar GuardsCheckStart = (function (_super) {\n    __extends(GuardsCheckStart, _super);\n    function GuardsCheckStart(/** @docsNotRequired */\n        /** @docsNotRequired */\n        id, /** @docsNotRequired */\n        /** @docsNotRequired */\n        url, urlAfterRedirects, state) {\n        var _this = _super.call(this, id, url) || this;\n        _this.urlAfterRedirects = urlAfterRedirects;\n        _this.state = state;\n        return _this;\n    }\n    /**\n     * @return {?}\n     */\n    GuardsCheckStart.prototype.toString = /**\n     * @return {?}\n     */\n    function () {\n        return \"GuardsCheckStart(id: \" + this.id + \", url: '\" + this.url + \"', urlAfterRedirects: '\" + this.urlAfterRedirects + \"', state: \" + this.state + \")\";\n    };\n    return GuardsCheckStart;\n}(RouterEvent));\n/**\n * \\@whatItDoes Represents the end of the Guard phase of routing.\n *\n * \\@experimental\n */\nvar GuardsCheckEnd = (function (_super) {\n    __extends(GuardsCheckEnd, _super);\n    function GuardsCheckEnd(/** @docsNotRequired */\n        /** @docsNotRequired */\n        id, /** @docsNotRequired */\n        /** @docsNotRequired */\n        url, urlAfterRedirects, state, shouldActivate) {\n        var _this = _super.call(this, id, url) || this;\n        _this.urlAfterRedirects = urlAfterRedirects;\n        _this.state = state;\n        _this.shouldActivate = shouldActivate;\n        return _this;\n    }\n    /**\n     * @return {?}\n     */\n    GuardsCheckEnd.prototype.toString = /**\n     * @return {?}\n     */\n    function () {\n        return \"GuardsCheckEnd(id: \" + this.id + \", url: '\" + this.url + \"', urlAfterRedirects: '\" + this.urlAfterRedirects + \"', state: \" + this.state + \", shouldActivate: \" + this.shouldActivate + \")\";\n    };\n    return GuardsCheckEnd;\n}(RouterEvent));\n/**\n * \\@whatItDoes Represents the start of the Resolve phase of routing. The timing of this\n * event may change, thus it's experimental. In the current iteration it will run\n * in the \"resolve\" phase whether there's things to resolve or not. In the future this\n * behavior may change to only run when there are things to be resolved.\n *\n * \\@experimental\n */\nvar ResolveStart = (function (_super) {\n    __extends(ResolveStart, _super);\n    function ResolveStart(/** @docsNotRequired */\n        /** @docsNotRequired */\n        id, /** @docsNotRequired */\n        /** @docsNotRequired */\n        url, urlAfterRedirects, state) {\n        var _this = _super.call(this, id, url) || this;\n        _this.urlAfterRedirects = urlAfterRedirects;\n        _this.state = state;\n        return _this;\n    }\n    /**\n     * @return {?}\n     */\n    ResolveStart.prototype.toString = /**\n     * @return {?}\n     */\n    function () {\n        return \"ResolveStart(id: \" + this.id + \", url: '\" + this.url + \"', urlAfterRedirects: '\" + this.urlAfterRedirects + \"', state: \" + this.state + \")\";\n    };\n    return ResolveStart;\n}(RouterEvent));\n/**\n * \\@whatItDoes Represents the end of the Resolve phase of routing. See note on\n * {\\@link ResolveStart} for use of this experimental API.\n *\n * \\@experimental\n */\nvar ResolveEnd = (function (_super) {\n    __extends(ResolveEnd, _super);\n    function ResolveEnd(/** @docsNotRequired */\n        /** @docsNotRequired */\n        id, /** @docsNotRequired */\n        /** @docsNotRequired */\n        url, urlAfterRedirects, state) {\n        var _this = _super.call(this, id, url) || this;\n        _this.urlAfterRedirects = urlAfterRedirects;\n        _this.state = state;\n        return _this;\n    }\n    /**\n     * @return {?}\n     */\n    ResolveEnd.prototype.toString = /**\n     * @return {?}\n     */\n    function () {\n        return \"ResolveEnd(id: \" + this.id + \", url: '\" + this.url + \"', urlAfterRedirects: '\" + this.urlAfterRedirects + \"', state: \" + this.state + \")\";\n    };\n    return ResolveEnd;\n}(RouterEvent));\n/**\n * \\@whatItDoes Represents an event triggered before lazy loading a route config.\n *\n * \\@experimental\n */\nvar RouteConfigLoadStart = (function () {\n    function RouteConfigLoadStart(route) {\n        this.route = route;\n    }\n    /**\n     * @return {?}\n     */\n    RouteConfigLoadStart.prototype.toString = /**\n     * @return {?}\n     */\n    function () { return \"RouteConfigLoadStart(path: \" + this.route.path + \")\"; };\n    return RouteConfigLoadStart;\n}());\n/**\n * \\@whatItDoes Represents an event triggered when a route has been lazy loaded.\n *\n * \\@experimental\n */\nvar RouteConfigLoadEnd = (function () {\n    function RouteConfigLoadEnd(route) {\n        this.route = route;\n    }\n    /**\n     * @return {?}\n     */\n    RouteConfigLoadEnd.prototype.toString = /**\n     * @return {?}\n     */\n    function () { return \"RouteConfigLoadEnd(path: \" + this.route.path + \")\"; };\n    return RouteConfigLoadEnd;\n}());\n/**\n * \\@whatItDoes Represents the start of end of the Resolve phase of routing. See note on\n * {\\@link ChildActivationEnd} for use of this experimental API.\n *\n * \\@experimental\n */\nvar ChildActivationStart = (function () {\n    function ChildActivationStart(snapshot) {\n        this.snapshot = snapshot;\n    }\n    /**\n     * @return {?}\n     */\n    ChildActivationStart.prototype.toString = /**\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n        return \"ChildActivationStart(path: '\" + path + \"')\";\n    };\n    return ChildActivationStart;\n}());\n/**\n * \\@whatItDoes Represents the start of end of the Resolve phase of routing. See note on\n * {\\@link ChildActivationStart} for use of this experimental API.\n *\n * \\@experimental\n */\nvar ChildActivationEnd = (function () {\n    function ChildActivationEnd(snapshot) {\n        this.snapshot = snapshot;\n    }\n    /**\n     * @return {?}\n     */\n    ChildActivationEnd.prototype.toString = /**\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n        return \"ChildActivationEnd(path: '\" + path + \"')\";\n    };\n    return ChildActivationEnd;\n}());\n/**\n * \\@whatItDoes Represents the start of end of the Resolve phase of routing. See note on\n * {\\@link ActivationEnd} for use of this experimental API.\n *\n * \\@experimental\n */\nvar ActivationStart = (function () {\n    function ActivationStart(snapshot) {\n        this.snapshot = snapshot;\n    }\n    /**\n     * @return {?}\n     */\n    ActivationStart.prototype.toString = /**\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n        return \"ActivationStart(path: '\" + path + \"')\";\n    };\n    return ActivationStart;\n}());\n/**\n * \\@whatItDoes Represents the start of end of the Resolve phase of routing. See note on\n * {\\@link ActivationStart} for use of this experimental API.\n *\n * \\@experimental\n */\nvar ActivationEnd = (function () {\n    function ActivationEnd(snapshot) {\n        this.snapshot = snapshot;\n    }\n    /**\n     * @return {?}\n     */\n    ActivationEnd.prototype.toString = /**\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n        return \"ActivationEnd(path: '\" + path + \"')\";\n    };\n    return ActivationEnd;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * \\@whatItDoes Name of the primary outlet.\n *\n * \\@stable\n */\nvar PRIMARY_OUTLET = 'primary';\n/**\n * Matrix and Query parameters.\n *\n * `ParamMap` makes it easier to work with parameters as they could have either a single value or\n * multiple value. Because this should be known by the user, calling `get` or `getAll` returns the\n * correct type (either `string` or `string[]`).\n *\n * The API is inspired by the URLSearchParams interface.\n * see https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams\n *\n * \\@stable\n * @record\n */\n\nvar ParamsAsMap = (function () {\n    function ParamsAsMap(params) {\n        this.params = params || {};\n    }\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    ParamsAsMap.prototype.has = /**\n     * @param {?} name\n     * @return {?}\n     */\n    function (name) { return this.params.hasOwnProperty(name); };\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    ParamsAsMap.prototype.get = /**\n     * @param {?} name\n     * @return {?}\n     */\n    function (name) {\n        if (this.has(name)) {\n            var /** @type {?} */ v = this.params[name];\n            return Array.isArray(v) ? v[0] : v;\n        }\n        return null;\n    };\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    ParamsAsMap.prototype.getAll = /**\n     * @param {?} name\n     * @return {?}\n     */\n    function (name) {\n        if (this.has(name)) {\n            var /** @type {?} */ v = this.params[name];\n            return Array.isArray(v) ? v : [v];\n        }\n        return [];\n    };\n    Object.defineProperty(ParamsAsMap.prototype, \"keys\", {\n        get: /**\n         * @return {?}\n         */\n        function () { return Object.keys(this.params); },\n        enumerable: true,\n        configurable: true\n    });\n    return ParamsAsMap;\n}());\n/**\n * Convert a {\\@link Params} instance to a {\\@link ParamMap}.\n *\n * \\@stable\n * @param {?} params\n * @return {?}\n */\nfunction convertToParamMap(params) {\n    return new ParamsAsMap(params);\n}\nvar NAVIGATION_CANCELING_ERROR = 'ngNavigationCancelingError';\n/**\n * @param {?} message\n * @return {?}\n */\nfunction navigationCancelingError(message) {\n    var /** @type {?} */ error = Error('NavigationCancelingError: ' + message);\n    (/** @type {?} */ (error))[NAVIGATION_CANCELING_ERROR] = true;\n    return error;\n}\n/**\n * @param {?} error\n * @return {?}\n */\nfunction isNavigationCancelingError(error) {\n    return error && (/** @type {?} */ (error))[NAVIGATION_CANCELING_ERROR];\n}\n/**\n * @param {?} segments\n * @param {?} segmentGroup\n * @param {?} route\n * @return {?}\n */\nfunction defaultUrlMatcher(segments, segmentGroup, route) {\n    var /** @type {?} */ parts = /** @type {?} */ ((route.path)).split('/');\n    if (parts.length > segments.length) {\n        // The actual URL is shorter than the config, no match\n        return null;\n    }\n    if (route.pathMatch === 'full' &&\n        (segmentGroup.hasChildren() || parts.length < segments.length)) {\n        // The config is longer than the actual URL but we are looking for a full match, return null\n        return null;\n    }\n    var /** @type {?} */ posParams = {};\n    // Check each config part against the actual URL\n    for (var /** @type {?} */ index = 0; index < parts.length; index++) {\n        var /** @type {?} */ part = parts[index];\n        var /** @type {?} */ segment = segments[index];\n        var /** @type {?} */ isParameter = part.startsWith(':');\n        if (isParameter) {\n            posParams[part.substring(1)] = segment;\n        }\n        else if (part !== segment.path) {\n            // The actual URL part does not match the config, no match\n            return null;\n        }\n    }\n    return { consumed: segments.slice(0, parts.length), posParams: posParams };\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * See {\\@link Routes} for more details.\n * \\@stable\n * @record\n */\n\nvar LoadedRouterConfig = (function () {\n    function LoadedRouterConfig(routes, module) {\n        this.routes = routes;\n        this.module = module;\n    }\n    return LoadedRouterConfig;\n}());\n/**\n * @param {?} config\n * @param {?=} parentPath\n * @return {?}\n */\nfunction validateConfig(config, parentPath) {\n    if (parentPath === void 0) { parentPath = ''; }\n    // forEach doesn't iterate undefined values\n    for (var /** @type {?} */ i = 0; i < config.length; i++) {\n        var /** @type {?} */ route = config[i];\n        var /** @type {?} */ fullPath = getFullPath(parentPath, route);\n        validateNode(route, fullPath);\n    }\n}\n/**\n * @param {?} route\n * @param {?} fullPath\n * @return {?}\n */\nfunction validateNode(route, fullPath) {\n    if (!route) {\n        throw new Error(\"\\n      Invalid configuration of route '\" + fullPath + \"': Encountered undefined route.\\n      The reason might be an extra comma.\\n\\n      Example:\\n      const routes: Routes = [\\n        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },\\n        { path: 'dashboard',  component: DashboardComponent },, << two commas\\n        { path: 'detail/:id', component: HeroDetailComponent }\\n      ];\\n    \");\n    }\n    if (Array.isArray(route)) {\n        throw new Error(\"Invalid configuration of route '\" + fullPath + \"': Array cannot be specified\");\n    }\n    if (!route.component && (route.outlet && route.outlet !== PRIMARY_OUTLET)) {\n        throw new Error(\"Invalid configuration of route '\" + fullPath + \"': a componentless route cannot have a named outlet set\");\n    }\n    if (route.redirectTo && route.children) {\n        throw new Error(\"Invalid configuration of route '\" + fullPath + \"': redirectTo and children cannot be used together\");\n    }\n    if (route.redirectTo && route.loadChildren) {\n        throw new Error(\"Invalid configuration of route '\" + fullPath + \"': redirectTo and loadChildren cannot be used together\");\n    }\n    if (route.children && route.loadChildren) {\n        throw new Error(\"Invalid configuration of route '\" + fullPath + \"': children and loadChildren cannot be used together\");\n    }\n    if (route.redirectTo && route.component) {\n        throw new Error(\"Invalid configuration of route '\" + fullPath + \"': redirectTo and component cannot be used together\");\n    }\n    if (route.path && route.matcher) {\n        throw new Error(\"Invalid configuration of route '\" + fullPath + \"': path and matcher cannot be used together\");\n    }\n    if (route.redirectTo === void 0 && !route.component && !route.children && !route.loadChildren) {\n        throw new Error(\"Invalid configuration of route '\" + fullPath + \"'. One of the following must be provided: component, redirectTo, children or loadChildren\");\n    }\n    if (route.path === void 0 && route.matcher === void 0) {\n        throw new Error(\"Invalid configuration of route '\" + fullPath + \"': routes must have either a path or a matcher specified\");\n    }\n    if (typeof route.path === 'string' && route.path.charAt(0) === '/') {\n        throw new Error(\"Invalid configuration of route '\" + fullPath + \"': path cannot start with a slash\");\n    }\n    if (route.path === '' && route.redirectTo !== void 0 && route.pathMatch === void 0) {\n        var /** @type {?} */ exp = \"The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.\";\n        throw new Error(\"Invalid configuration of route '{path: \\\"\" + fullPath + \"\\\", redirectTo: \\\"\" + route.redirectTo + \"\\\"}': please provide 'pathMatch'. \" + exp);\n    }\n    if (route.pathMatch !== void 0 && route.pathMatch !== 'full' && route.pathMatch !== 'prefix') {\n        throw new Error(\"Invalid configuration of route '\" + fullPath + \"': pathMatch can only be set to 'prefix' or 'full'\");\n    }\n    if (route.children) {\n        validateConfig(route.children, fullPath);\n    }\n}\n/**\n * @param {?} parentPath\n * @param {?} currentRoute\n * @return {?}\n */\nfunction getFullPath(parentPath, currentRoute) {\n    if (!currentRoute) {\n        return parentPath;\n    }\n    if (!parentPath && !currentRoute.path) {\n        return '';\n    }\n    else if (parentPath && !currentRoute.path) {\n        return parentPath + \"/\";\n    }\n    else if (!parentPath && currentRoute.path) {\n        return currentRoute.path;\n    }\n    else {\n        return parentPath + \"/\" + currentRoute.path;\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @param {?} a\n * @param {?} b\n * @return {?}\n */\nfunction shallowEqualArrays(a, b) {\n    if (a.length !== b.length)\n        return false;\n    for (var /** @type {?} */ i = 0; i < a.length; ++i) {\n        if (!shallowEqual(a[i], b[i]))\n            return false;\n    }\n    return true;\n}\n/**\n * @param {?} a\n * @param {?} b\n * @return {?}\n */\nfunction shallowEqual(a, b) {\n    var /** @type {?} */ k1 = Object.keys(a);\n    var /** @type {?} */ k2 = Object.keys(b);\n    if (k1.length != k2.length) {\n        return false;\n    }\n    var /** @type {?} */ key;\n    for (var /** @type {?} */ i = 0; i < k1.length; i++) {\n        key = k1[i];\n        if (a[key] !== b[key]) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Flattens single-level nested arrays.\n * @template T\n * @param {?} arr\n * @return {?}\n */\nfunction flatten(arr) {\n    return Array.prototype.concat.apply([], arr);\n}\n/**\n * Return the last element of an array.\n * @template T\n * @param {?} a\n * @return {?}\n */\nfunction last$1(a) {\n    return a.length > 0 ? a[a.length - 1] : null;\n}\n/**\n * Verifys all booleans in an array are `true`.\n * @param {?} bools\n * @return {?}\n */\n\n/**\n * @template K, V\n * @param {?} map\n * @param {?} callback\n * @return {?}\n */\nfunction forEach(map$$1, callback) {\n    for (var /** @type {?} */ prop in map$$1) {\n        if (map$$1.hasOwnProperty(prop)) {\n            callback(map$$1[prop], prop);\n        }\n    }\n}\n/**\n * @template A, B\n * @param {?} obj\n * @param {?} fn\n * @return {?}\n */\nfunction waitForMap(obj, fn) {\n    if (Object.keys(obj).length === 0) {\n        return of({});\n    }\n    var /** @type {?} */ waitHead = [];\n    var /** @type {?} */ waitTail = [];\n    var /** @type {?} */ res = {};\n    forEach(obj, function (a, k) {\n        var /** @type {?} */ mapped = map.call(fn(k, a), function (r) { return res[k] = r; });\n        if (k === PRIMARY_OUTLET) {\n            waitHead.push(mapped);\n        }\n        else {\n            waitTail.push(mapped);\n        }\n    });\n    var /** @type {?} */ concat$ = concatAll.call(of.apply(void 0, waitHead.concat(waitTail)));\n    var /** @type {?} */ last$ = last.call(concat$);\n    return map.call(last$, function () { return res; });\n}\n/**\n * ANDs Observables by merging all input observables, reducing to an Observable verifying all\n * input Observables return `true`.\n * @param {?} observables\n * @return {?}\n */\nfunction andObservables(observables) {\n    var /** @type {?} */ merged$ = mergeAll.call(observables);\n    return every.call(merged$, function (result) { return result === true; });\n}\n/**\n * @template T\n * @param {?} value\n * @return {?}\n */\nfunction wrapIntoObservable(value) {\n    if (isObservable(value)) {\n        return value;\n    }\n    if (isPromise(value)) {\n        // Use `Promise.resolve()` to wrap promise-like instances.\n        // Required ie when a Resolver returns a AngularJS `$q` promise to correctly trigger the\n        // change detection.\n        return fromPromise(Promise.resolve(value));\n    }\n    return of(/** @type {?} */ (value));\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @return {?}\n */\nfunction createEmptyUrlTree() {\n    return new UrlTree(new UrlSegmentGroup([], {}), {}, null);\n}\n/**\n * @param {?} container\n * @param {?} containee\n * @param {?} exact\n * @return {?}\n */\nfunction containsTree(container, containee, exact) {\n    if (exact) {\n        return equalQueryParams(container.queryParams, containee.queryParams) &&\n            equalSegmentGroups(container.root, containee.root);\n    }\n    return containsQueryParams(container.queryParams, containee.queryParams) &&\n        containsSegmentGroup(container.root, containee.root);\n}\n/**\n * @param {?} container\n * @param {?} containee\n * @return {?}\n */\nfunction equalQueryParams(container, containee) {\n    return shallowEqual(container, containee);\n}\n/**\n * @param {?} container\n * @param {?} containee\n * @return {?}\n */\nfunction equalSegmentGroups(container, containee) {\n    if (!equalPath(container.segments, containee.segments))\n        return false;\n    if (container.numberOfChildren !== containee.numberOfChildren)\n        return false;\n    for (var /** @type {?} */ c in containee.children) {\n        if (!container.children[c])\n            return false;\n        if (!equalSegmentGroups(container.children[c], containee.children[c]))\n            return false;\n    }\n    return true;\n}\n/**\n * @param {?} container\n * @param {?} containee\n * @return {?}\n */\nfunction containsQueryParams(container, containee) {\n    return Object.keys(containee).length <= Object.keys(container).length &&\n        Object.keys(containee).every(function (key) { return containee[key] === container[key]; });\n}\n/**\n * @param {?} container\n * @param {?} containee\n * @return {?}\n */\nfunction containsSegmentGroup(container, containee) {\n    return containsSegmentGroupHelper(container, containee, containee.segments);\n}\n/**\n * @param {?} container\n * @param {?} containee\n * @param {?} containeePaths\n * @return {?}\n */\nfunction containsSegmentGroupHelper(container, containee, containeePaths) {\n    if (container.segments.length > containeePaths.length) {\n        var /** @type {?} */ current = container.segments.slice(0, containeePaths.length);\n        if (!equalPath(current, containeePaths))\n            return false;\n        if (containee.hasChildren())\n            return false;\n        return true;\n    }\n    else if (container.segments.length === containeePaths.length) {\n        if (!equalPath(container.segments, containeePaths))\n            return false;\n        for (var /** @type {?} */ c in containee.children) {\n            if (!container.children[c])\n                return false;\n            if (!containsSegmentGroup(container.children[c], containee.children[c]))\n                return false;\n        }\n        return true;\n    }\n    else {\n        var /** @type {?} */ current = containeePaths.slice(0, container.segments.length);\n        var /** @type {?} */ next = containeePaths.slice(container.segments.length);\n        if (!equalPath(container.segments, current))\n            return false;\n        if (!container.children[PRIMARY_OUTLET])\n            return false;\n        return containsSegmentGroupHelper(container.children[PRIMARY_OUTLET], containee, next);\n    }\n}\n/**\n * \\@whatItDoes Represents the parsed URL.\n *\n * \\@howToUse\n *\n * ```\n * \\@Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const tree: UrlTree =\n *       router.parseUrl('/team/33/(user/victor//support:help)?debug=true#fragment');\n *     const f = tree.fragment; // return 'fragment'\n *     const q = tree.queryParams; // returns {debug: 'true'}\n *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n *     const s: UrlSegment[] = g.segments; // returns 2 segments 'team' and '33'\n *     g.children[PRIMARY_OUTLET].segments; // returns 2 segments 'user' and 'victor'\n *     g.children['support'].segments; // return 1 segment 'help'\n *   }\n * }\n * ```\n *\n * \\@description\n *\n * Since a router state is a tree, and the URL is nothing but a serialized state, the URL is a\n * serialized tree.\n * UrlTree is a data structure that provides a lot of affordances in dealing with URLs\n *\n * \\@stable\n */\nvar UrlTree = (function () {\n    /** @internal */\n    function UrlTree(root, queryParams, fragment) {\n        this.root = root;\n        this.queryParams = queryParams;\n        this.fragment = fragment;\n    }\n    Object.defineProperty(UrlTree.prototype, \"queryParamMap\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            if (!this._queryParamMap) {\n                this._queryParamMap = convertToParamMap(this.queryParams);\n            }\n            return this._queryParamMap;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** @docsNotRequired */\n    /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    UrlTree.prototype.toString = /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    function () { return DEFAULT_SERIALIZER.serialize(this); };\n    return UrlTree;\n}());\n/**\n * \\@whatItDoes Represents the parsed URL segment group.\n *\n * See {\\@link UrlTree} for more information.\n *\n * \\@stable\n */\nvar UrlSegmentGroup = (function () {\n    function UrlSegmentGroup(segments, children) {\n        var _this = this;\n        this.segments = segments;\n        this.children = children;\n        /**\n         * The parent node in the url tree\n         */\n        this.parent = null;\n        forEach(children, function (v, k) { return v.parent = _this; });\n    }\n    /** Whether the segment has child segments */\n    /**\n     * Whether the segment has child segments\n     * @return {?}\n     */\n    UrlSegmentGroup.prototype.hasChildren = /**\n     * Whether the segment has child segments\n     * @return {?}\n     */\n    function () { return this.numberOfChildren > 0; };\n    Object.defineProperty(UrlSegmentGroup.prototype, \"numberOfChildren\", {\n        /** Number of child segments */\n        get: /**\n         * Number of child segments\n         * @return {?}\n         */\n        function () { return Object.keys(this.children).length; },\n        enumerable: true,\n        configurable: true\n    });\n    /** @docsNotRequired */\n    /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    UrlSegmentGroup.prototype.toString = /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    function () { return serializePaths(this); };\n    return UrlSegmentGroup;\n}());\n/**\n * \\@whatItDoes Represents a single URL segment.\n *\n * \\@howToUse\n *\n * ```\n * \\@Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const tree: UrlTree = router.parseUrl('/team;id=33');\n *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n *     const s: UrlSegment[] = g.segments;\n *     s[0].path; // returns 'team'\n *     s[0].parameters; // returns {id: 33}\n *   }\n * }\n * ```\n *\n * \\@description\n *\n * A UrlSegment is a part of a URL between the two slashes. It contains a path and the matrix\n * parameters associated with the segment.\n *\n * \\@stable\n */\nvar UrlSegment = (function () {\n    function UrlSegment(path, parameters) {\n        this.path = path;\n        this.parameters = parameters;\n    }\n    Object.defineProperty(UrlSegment.prototype, \"parameterMap\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            if (!this._parameterMap) {\n                this._parameterMap = convertToParamMap(this.parameters);\n            }\n            return this._parameterMap;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** @docsNotRequired */\n    /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    UrlSegment.prototype.toString = /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    function () { return serializePath(this); };\n    return UrlSegment;\n}());\n/**\n * @param {?} as\n * @param {?} bs\n * @return {?}\n */\nfunction equalSegments(as, bs) {\n    return equalPath(as, bs) && as.every(function (a, i) { return shallowEqual(a.parameters, bs[i].parameters); });\n}\n/**\n * @param {?} as\n * @param {?} bs\n * @return {?}\n */\nfunction equalPath(as, bs) {\n    if (as.length !== bs.length)\n        return false;\n    return as.every(function (a, i) { return a.path === bs[i].path; });\n}\n/**\n * @template T\n * @param {?} segment\n * @param {?} fn\n * @return {?}\n */\nfunction mapChildrenIntoArray(segment, fn) {\n    var /** @type {?} */ res = [];\n    forEach(segment.children, function (child, childOutlet) {\n        if (childOutlet === PRIMARY_OUTLET) {\n            res = res.concat(fn(child, childOutlet));\n        }\n    });\n    forEach(segment.children, function (child, childOutlet) {\n        if (childOutlet !== PRIMARY_OUTLET) {\n            res = res.concat(fn(child, childOutlet));\n        }\n    });\n    return res;\n}\n/**\n * \\@whatItDoes Serializes and deserializes a URL string into a URL tree.\n *\n * \\@description The url serialization strategy is customizable. You can\n * make all URLs case insensitive by providing a custom UrlSerializer.\n *\n * See {\\@link DefaultUrlSerializer} for an example of a URL serializer.\n *\n * \\@stable\n * @abstract\n */\nvar UrlSerializer = (function () {\n    function UrlSerializer() {\n    }\n    return UrlSerializer;\n}());\n/**\n * \\@whatItDoes A default implementation of the {\\@link UrlSerializer}.\n *\n * \\@description\n *\n * Example URLs:\n *\n * ```\n * /inbox/33(popup:compose)\n * /inbox/33;open=true/messages/44\n * ```\n *\n * DefaultUrlSerializer uses parentheses to serialize secondary segments (e.g., popup:compose), the\n * colon syntax to specify the outlet, and the ';parameter=value' syntax (e.g., open=true) to\n * specify route specific parameters.\n *\n * \\@stable\n */\nvar DefaultUrlSerializer = (function () {\n    function DefaultUrlSerializer() {\n    }\n    /** Parses a url into a {@link UrlTree} */\n    /**\n     * Parses a url into a {\\@link UrlTree}\n     * @param {?} url\n     * @return {?}\n     */\n    DefaultUrlSerializer.prototype.parse = /**\n     * Parses a url into a {\\@link UrlTree}\n     * @param {?} url\n     * @return {?}\n     */\n    function (url) {\n        var /** @type {?} */ p = new UrlParser(url);\n        return new UrlTree(p.parseRootSegment(), p.parseQueryParams(), p.parseFragment());\n    };\n    /** Converts a {@link UrlTree} into a url */\n    /**\n     * Converts a {\\@link UrlTree} into a url\n     * @param {?} tree\n     * @return {?}\n     */\n    DefaultUrlSerializer.prototype.serialize = /**\n     * Converts a {\\@link UrlTree} into a url\n     * @param {?} tree\n     * @return {?}\n     */\n    function (tree) {\n        var /** @type {?} */ segment = \"/\" + serializeSegment(tree.root, true);\n        var /** @type {?} */ query = serializeQueryParams(tree.queryParams);\n        var /** @type {?} */ fragment = typeof tree.fragment === \"string\" ? \"#\" + encodeURI((/** @type {?} */ ((tree.fragment)))) : '';\n        return \"\" + segment + query + fragment;\n    };\n    return DefaultUrlSerializer;\n}());\nvar DEFAULT_SERIALIZER = new DefaultUrlSerializer();\n/**\n * @param {?} segment\n * @return {?}\n */\nfunction serializePaths(segment) {\n    return segment.segments.map(function (p) { return serializePath(p); }).join('/');\n}\n/**\n * @param {?} segment\n * @param {?} root\n * @return {?}\n */\nfunction serializeSegment(segment, root) {\n    if (!segment.hasChildren()) {\n        return serializePaths(segment);\n    }\n    if (root) {\n        var /** @type {?} */ primary = segment.children[PRIMARY_OUTLET] ?\n            serializeSegment(segment.children[PRIMARY_OUTLET], false) :\n            '';\n        var /** @type {?} */ children_1 = [];\n        forEach(segment.children, function (v, k) {\n            if (k !== PRIMARY_OUTLET) {\n                children_1.push(k + \":\" + serializeSegment(v, false));\n            }\n        });\n        return children_1.length > 0 ? primary + \"(\" + children_1.join('//') + \")\" : primary;\n    }\n    else {\n        var /** @type {?} */ children = mapChildrenIntoArray(segment, function (v, k) {\n            if (k === PRIMARY_OUTLET) {\n                return [serializeSegment(segment.children[PRIMARY_OUTLET], false)];\n            }\n            return [k + \":\" + serializeSegment(v, false)];\n        });\n        return serializePaths(segment) + \"/(\" + children.join('//') + \")\";\n    }\n}\n/**\n * This method is intended for encoding *key* or *value* parts of query component. We need a custom\n * method because encodeURIComponent is too aggressive and encodes stuff that doesn't have to be\n * encoded per http://tools.ietf.org/html/rfc3986:\n *    query         = *( pchar / \"/\" / \"?\" )\n *    pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"\\@\"\n *    unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n *    pct-encoded   = \"%\" HEXDIG HEXDIG\n *    sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n *                     / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n * @param {?} s\n * @return {?}\n */\nfunction encode(s) {\n    return encodeURIComponent(s)\n        .replace(/%40/g, '@')\n        .replace(/%3A/gi, ':')\n        .replace(/%24/g, '$')\n        .replace(/%2C/gi, ',')\n        .replace(/%3B/gi, ';');\n}\n/**\n * @param {?} s\n * @return {?}\n */\nfunction decode(s) {\n    return decodeURIComponent(s);\n}\n/**\n * @param {?} path\n * @return {?}\n */\nfunction serializePath(path) {\n    return \"\" + encode(path.path) + serializeParams(path.parameters);\n}\n/**\n * @param {?} params\n * @return {?}\n */\nfunction serializeParams(params) {\n    return Object.keys(params).map(function (key) { return \";\" + encode(key) + \"=\" + encode(params[key]); }).join('');\n}\n/**\n * @param {?} params\n * @return {?}\n */\nfunction serializeQueryParams(params) {\n    var /** @type {?} */ strParams = Object.keys(params).map(function (name) {\n        var /** @type {?} */ value = params[name];\n        return Array.isArray(value) ? value.map(function (v) { return encode(name) + \"=\" + encode(v); }).join('&') :\n            encode(name) + \"=\" + encode(value);\n    });\n    return strParams.length ? \"?\" + strParams.join(\"&\") : '';\n}\nvar SEGMENT_RE = /^[^\\/()?;=&#]+/;\n/**\n * @param {?} str\n * @return {?}\n */\nfunction matchSegments(str) {\n    var /** @type {?} */ match = str.match(SEGMENT_RE);\n    return match ? match[0] : '';\n}\nvar QUERY_PARAM_RE = /^[^=?&#]+/;\n/**\n * @param {?} str\n * @return {?}\n */\nfunction matchQueryParams(str) {\n    var /** @type {?} */ match = str.match(QUERY_PARAM_RE);\n    return match ? match[0] : '';\n}\nvar QUERY_PARAM_VALUE_RE = /^[^?&#]+/;\n/**\n * @param {?} str\n * @return {?}\n */\nfunction matchUrlQueryParamValue(str) {\n    var /** @type {?} */ match = str.match(QUERY_PARAM_VALUE_RE);\n    return match ? match[0] : '';\n}\nvar UrlParser = (function () {\n    function UrlParser(url) {\n        this.url = url;\n        this.remaining = url;\n    }\n    /**\n     * @return {?}\n     */\n    UrlParser.prototype.parseRootSegment = /**\n     * @return {?}\n     */\n    function () {\n        this.consumeOptional('/');\n        if (this.remaining === '' || this.peekStartsWith('?') || this.peekStartsWith('#')) {\n            return new UrlSegmentGroup([], {});\n        }\n        // The root segment group never has segments\n        return new UrlSegmentGroup([], this.parseChildren());\n    };\n    /**\n     * @return {?}\n     */\n    UrlParser.prototype.parseQueryParams = /**\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ params = {};\n        if (this.consumeOptional('?')) {\n            do {\n                this.parseQueryParam(params);\n            } while (this.consumeOptional('&'));\n        }\n        return params;\n    };\n    /**\n     * @return {?}\n     */\n    UrlParser.prototype.parseFragment = /**\n     * @return {?}\n     */\n    function () {\n        return this.consumeOptional('#') ? decodeURI(this.remaining) : null;\n    };\n    /**\n     * @return {?}\n     */\n    UrlParser.prototype.parseChildren = /**\n     * @return {?}\n     */\n    function () {\n        if (this.remaining === '') {\n            return {};\n        }\n        this.consumeOptional('/');\n        var /** @type {?} */ segments = [];\n        if (!this.peekStartsWith('(')) {\n            segments.push(this.parseSegment());\n        }\n        while (this.peekStartsWith('/') && !this.peekStartsWith('//') && !this.peekStartsWith('/(')) {\n            this.capture('/');\n            segments.push(this.parseSegment());\n        }\n        var /** @type {?} */ children = {};\n        if (this.peekStartsWith('/(')) {\n            this.capture('/');\n            children = this.parseParens(true);\n        }\n        var /** @type {?} */ res = {};\n        if (this.peekStartsWith('(')) {\n            res = this.parseParens(false);\n        }\n        if (segments.length > 0 || Object.keys(children).length > 0) {\n            res[PRIMARY_OUTLET] = new UrlSegmentGroup(segments, children);\n        }\n        return res;\n    };\n    /**\n     * @return {?}\n     */\n    UrlParser.prototype.parseSegment = /**\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ path = matchSegments(this.remaining);\n        if (path === '' && this.peekStartsWith(';')) {\n            throw new Error(\"Empty path url segment cannot have parameters: '\" + this.remaining + \"'.\");\n        }\n        this.capture(path);\n        return new UrlSegment(decode(path), this.parseMatrixParams());\n    };\n    /**\n     * @return {?}\n     */\n    UrlParser.prototype.parseMatrixParams = /**\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ params = {};\n        while (this.consumeOptional(';')) {\n            this.parseParam(params);\n        }\n        return params;\n    };\n    /**\n     * @param {?} params\n     * @return {?}\n     */\n    UrlParser.prototype.parseParam = /**\n     * @param {?} params\n     * @return {?}\n     */\n    function (params) {\n        var /** @type {?} */ key = matchSegments(this.remaining);\n        if (!key) {\n            return;\n        }\n        this.capture(key);\n        var /** @type {?} */ value = '';\n        if (this.consumeOptional('=')) {\n            var /** @type {?} */ valueMatch = matchSegments(this.remaining);\n            if (valueMatch) {\n                value = valueMatch;\n                this.capture(value);\n            }\n        }\n        params[decode(key)] = decode(value);\n    };\n    /**\n     * @param {?} params\n     * @return {?}\n     */\n    UrlParser.prototype.parseQueryParam = /**\n     * @param {?} params\n     * @return {?}\n     */\n    function (params) {\n        var /** @type {?} */ key = matchQueryParams(this.remaining);\n        if (!key) {\n            return;\n        }\n        this.capture(key);\n        var /** @type {?} */ value = '';\n        if (this.consumeOptional('=')) {\n            var /** @type {?} */ valueMatch = matchUrlQueryParamValue(this.remaining);\n            if (valueMatch) {\n                value = valueMatch;\n                this.capture(value);\n            }\n        }\n        var /** @type {?} */ decodedKey = decode(key);\n        var /** @type {?} */ decodedVal = decode(value);\n        if (params.hasOwnProperty(decodedKey)) {\n            // Append to existing values\n            var /** @type {?} */ currentVal = params[decodedKey];\n            if (!Array.isArray(currentVal)) {\n                currentVal = [currentVal];\n                params[decodedKey] = currentVal;\n            }\n            currentVal.push(decodedVal);\n        }\n        else {\n            // Create a new value\n            params[decodedKey] = decodedVal;\n        }\n    };\n    /**\n     * @param {?} allowPrimary\n     * @return {?}\n     */\n    UrlParser.prototype.parseParens = /**\n     * @param {?} allowPrimary\n     * @return {?}\n     */\n    function (allowPrimary) {\n        var /** @type {?} */ segments = {};\n        this.capture('(');\n        while (!this.consumeOptional(')') && this.remaining.length > 0) {\n            var /** @type {?} */ path = matchSegments(this.remaining);\n            var /** @type {?} */ next = this.remaining[path.length];\n            // if is is not one of these characters, then the segment was unescaped\n            // or the group was not closed\n            if (next !== '/' && next !== ')' && next !== ';') {\n                throw new Error(\"Cannot parse url '\" + this.url + \"'\");\n            }\n            var /** @type {?} */ outletName = /** @type {?} */ ((undefined));\n            if (path.indexOf(':') > -1) {\n                outletName = path.substr(0, path.indexOf(':'));\n                this.capture(outletName);\n                this.capture(':');\n            }\n            else if (allowPrimary) {\n                outletName = PRIMARY_OUTLET;\n            }\n            var /** @type {?} */ children = this.parseChildren();\n            segments[outletName] = Object.keys(children).length === 1 ? children[PRIMARY_OUTLET] :\n                new UrlSegmentGroup([], children);\n            this.consumeOptional('//');\n        }\n        return segments;\n    };\n    /**\n     * @param {?} str\n     * @return {?}\n     */\n    UrlParser.prototype.peekStartsWith = /**\n     * @param {?} str\n     * @return {?}\n     */\n    function (str) { return this.remaining.startsWith(str); };\n    /**\n     * @param {?} str\n     * @return {?}\n     */\n    UrlParser.prototype.consumeOptional = /**\n     * @param {?} str\n     * @return {?}\n     */\n    function (str) {\n        if (this.peekStartsWith(str)) {\n            this.remaining = this.remaining.substring(str.length);\n            return true;\n        }\n        return false;\n    };\n    /**\n     * @param {?} str\n     * @return {?}\n     */\n    UrlParser.prototype.capture = /**\n     * @param {?} str\n     * @return {?}\n     */\n    function (str) {\n        if (!this.consumeOptional(str)) {\n            throw new Error(\"Expected \\\"\" + str + \"\\\".\");\n        }\n    };\n    return UrlParser;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar NoMatch = (function () {\n    function NoMatch(segmentGroup) {\n        this.segmentGroup = segmentGroup || null;\n    }\n    return NoMatch;\n}());\nvar AbsoluteRedirect = (function () {\n    function AbsoluteRedirect(urlTree) {\n        this.urlTree = urlTree;\n    }\n    return AbsoluteRedirect;\n}());\n/**\n * @param {?} segmentGroup\n * @return {?}\n */\nfunction noMatch(segmentGroup) {\n    return new Observable(function (obs) { return obs.error(new NoMatch(segmentGroup)); });\n}\n/**\n * @param {?} newTree\n * @return {?}\n */\nfunction absoluteRedirect(newTree) {\n    return new Observable(function (obs) { return obs.error(new AbsoluteRedirect(newTree)); });\n}\n/**\n * @param {?} redirectTo\n * @return {?}\n */\nfunction namedOutletsRedirect(redirectTo) {\n    return new Observable(function (obs) {\n        return obs.error(new Error(\"Only absolute redirects can have named outlets. redirectTo: '\" + redirectTo + \"'\"));\n    });\n}\n/**\n * @param {?} route\n * @return {?}\n */\nfunction canLoadFails(route) {\n    return new Observable(function (obs) {\n        return obs.error(navigationCancelingError(\"Cannot load children because the guard of the route \\\"path: '\" + route.path + \"'\\\" returned false\"));\n    });\n}\n/**\n * Returns the `UrlTree` with the redirection applied.\n *\n * Lazy modules are loaded along the way.\n * @param {?} moduleInjector\n * @param {?} configLoader\n * @param {?} urlSerializer\n * @param {?} urlTree\n * @param {?} config\n * @return {?}\n */\nfunction applyRedirects(moduleInjector, configLoader, urlSerializer, urlTree, config) {\n    return new ApplyRedirects(moduleInjector, configLoader, urlSerializer, urlTree, config).apply();\n}\nvar ApplyRedirects = (function () {\n    function ApplyRedirects(moduleInjector, configLoader, urlSerializer, urlTree, config) {\n        this.configLoader = configLoader;\n        this.urlSerializer = urlSerializer;\n        this.urlTree = urlTree;\n        this.config = config;\n        this.allowRedirects = true;\n        this.ngModule = moduleInjector.get(NgModuleRef);\n    }\n    /**\n     * @return {?}\n     */\n    ApplyRedirects.prototype.apply = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        var /** @type {?} */ expanded$ = this.expandSegmentGroup(this.ngModule, this.config, this.urlTree.root, PRIMARY_OUTLET);\n        var /** @type {?} */ urlTrees$ = map.call(expanded$, function (rootSegmentGroup) {\n            return _this.createUrlTree(rootSegmentGroup, _this.urlTree.queryParams, /** @type {?} */ ((_this.urlTree.fragment)));\n        });\n        return _catch.call(urlTrees$, function (e) {\n            if (e instanceof AbsoluteRedirect) {\n                // after an absolute redirect we do not apply any more redirects!\n                // after an absolute redirect we do not apply any more redirects!\n                _this.allowRedirects = false;\n                // we need to run matching, so we can fetch all lazy-loaded modules\n                return _this.match(e.urlTree);\n            }\n            if (e instanceof NoMatch) {\n                throw _this.noMatchError(e);\n            }\n            throw e;\n        });\n    };\n    /**\n     * @param {?} tree\n     * @return {?}\n     */\n    ApplyRedirects.prototype.match = /**\n     * @param {?} tree\n     * @return {?}\n     */\n    function (tree) {\n        var _this = this;\n        var /** @type {?} */ expanded$ = this.expandSegmentGroup(this.ngModule, this.config, tree.root, PRIMARY_OUTLET);\n        var /** @type {?} */ mapped$ = map.call(expanded$, function (rootSegmentGroup) {\n            return _this.createUrlTree(rootSegmentGroup, tree.queryParams, /** @type {?} */ ((tree.fragment)));\n        });\n        return _catch.call(mapped$, function (e) {\n            if (e instanceof NoMatch) {\n                throw _this.noMatchError(e);\n            }\n            throw e;\n        });\n    };\n    /**\n     * @param {?} e\n     * @return {?}\n     */\n    ApplyRedirects.prototype.noMatchError = /**\n     * @param {?} e\n     * @return {?}\n     */\n    function (e) {\n        return new Error(\"Cannot match any routes. URL Segment: '\" + e.segmentGroup + \"'\");\n    };\n    /**\n     * @param {?} rootCandidate\n     * @param {?} queryParams\n     * @param {?} fragment\n     * @return {?}\n     */\n    ApplyRedirects.prototype.createUrlTree = /**\n     * @param {?} rootCandidate\n     * @param {?} queryParams\n     * @param {?} fragment\n     * @return {?}\n     */\n    function (rootCandidate, queryParams, fragment) {\n        var /** @type {?} */ root = rootCandidate.segments.length > 0 ?\n            new UrlSegmentGroup([], (_a = {}, _a[PRIMARY_OUTLET] = rootCandidate, _a)) :\n            rootCandidate;\n        return new UrlTree(root, queryParams, fragment);\n        var _a;\n    };\n    /**\n     * @param {?} ngModule\n     * @param {?} routes\n     * @param {?} segmentGroup\n     * @param {?} outlet\n     * @return {?}\n     */\n    ApplyRedirects.prototype.expandSegmentGroup = /**\n     * @param {?} ngModule\n     * @param {?} routes\n     * @param {?} segmentGroup\n     * @param {?} outlet\n     * @return {?}\n     */\n    function (ngModule, routes, segmentGroup, outlet) {\n        if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n            return map.call(this.expandChildren(ngModule, routes, segmentGroup), function (children) { return new UrlSegmentGroup([], children); });\n        }\n        return this.expandSegment(ngModule, segmentGroup, routes, segmentGroup.segments, outlet, true);\n    };\n    /**\n     * @param {?} ngModule\n     * @param {?} routes\n     * @param {?} segmentGroup\n     * @return {?}\n     */\n    ApplyRedirects.prototype.expandChildren = /**\n     * @param {?} ngModule\n     * @param {?} routes\n     * @param {?} segmentGroup\n     * @return {?}\n     */\n    function (ngModule, routes, segmentGroup) {\n        var _this = this;\n        return waitForMap(segmentGroup.children, function (childOutlet, child) { return _this.expandSegmentGroup(ngModule, routes, child, childOutlet); });\n    };\n    /**\n     * @param {?} ngModule\n     * @param {?} segmentGroup\n     * @param {?} routes\n     * @param {?} segments\n     * @param {?} outlet\n     * @param {?} allowRedirects\n     * @return {?}\n     */\n    ApplyRedirects.prototype.expandSegment = /**\n     * @param {?} ngModule\n     * @param {?} segmentGroup\n     * @param {?} routes\n     * @param {?} segments\n     * @param {?} outlet\n     * @param {?} allowRedirects\n     * @return {?}\n     */\n    function (ngModule, segmentGroup, routes, segments, outlet, allowRedirects) {\n        var _this = this;\n        var /** @type {?} */ routes$ = of.apply(void 0, routes);\n        var /** @type {?} */ processedRoutes$ = map.call(routes$, function (r) {\n            var /** @type {?} */ expanded$ = _this.expandSegmentAgainstRoute(ngModule, segmentGroup, routes, r, segments, outlet, allowRedirects);\n            return _catch.call(expanded$, function (e) {\n                if (e instanceof NoMatch) {\n                    return of(null);\n                }\n                throw e;\n            });\n        });\n        var /** @type {?} */ concattedProcessedRoutes$ = concatAll.call(processedRoutes$);\n        var /** @type {?} */ first$ = first.call(concattedProcessedRoutes$, function (s) { return !!s; });\n        return _catch.call(first$, function (e, _) {\n            if (e instanceof EmptyError) {\n                if (_this.noLeftoversInUrl(segmentGroup, segments, outlet)) {\n                    return of(new UrlSegmentGroup([], {}));\n                }\n                throw new NoMatch(segmentGroup);\n            }\n            throw e;\n        });\n    };\n    /**\n     * @param {?} segmentGroup\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n    ApplyRedirects.prototype.noLeftoversInUrl = /**\n     * @param {?} segmentGroup\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n    function (segmentGroup, segments, outlet) {\n        return segments.length === 0 && !segmentGroup.children[outlet];\n    };\n    /**\n     * @param {?} ngModule\n     * @param {?} segmentGroup\n     * @param {?} routes\n     * @param {?} route\n     * @param {?} paths\n     * @param {?} outlet\n     * @param {?} allowRedirects\n     * @return {?}\n     */\n    ApplyRedirects.prototype.expandSegmentAgainstRoute = /**\n     * @param {?} ngModule\n     * @param {?} segmentGroup\n     * @param {?} routes\n     * @param {?} route\n     * @param {?} paths\n     * @param {?} outlet\n     * @param {?} allowRedirects\n     * @return {?}\n     */\n    function (ngModule, segmentGroup, routes, route, paths, outlet, allowRedirects) {\n        if (getOutlet(route) !== outlet) {\n            return noMatch(segmentGroup);\n        }\n        if (route.redirectTo === undefined) {\n            return this.matchSegmentAgainstRoute(ngModule, segmentGroup, route, paths);\n        }\n        if (allowRedirects && this.allowRedirects) {\n            return this.expandSegmentAgainstRouteUsingRedirect(ngModule, segmentGroup, routes, route, paths, outlet);\n        }\n        return noMatch(segmentGroup);\n    };\n    /**\n     * @param {?} ngModule\n     * @param {?} segmentGroup\n     * @param {?} routes\n     * @param {?} route\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n    ApplyRedirects.prototype.expandSegmentAgainstRouteUsingRedirect = /**\n     * @param {?} ngModule\n     * @param {?} segmentGroup\n     * @param {?} routes\n     * @param {?} route\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n    function (ngModule, segmentGroup, routes, route, segments, outlet) {\n        if (route.path === '**') {\n            return this.expandWildCardWithParamsAgainstRouteUsingRedirect(ngModule, routes, route, outlet);\n        }\n        return this.expandRegularSegmentAgainstRouteUsingRedirect(ngModule, segmentGroup, routes, route, segments, outlet);\n    };\n    /**\n     * @param {?} ngModule\n     * @param {?} routes\n     * @param {?} route\n     * @param {?} outlet\n     * @return {?}\n     */\n    ApplyRedirects.prototype.expandWildCardWithParamsAgainstRouteUsingRedirect = /**\n     * @param {?} ngModule\n     * @param {?} routes\n     * @param {?} route\n     * @param {?} outlet\n     * @return {?}\n     */\n    function (ngModule, routes, route, outlet) {\n        var _this = this;\n        var /** @type {?} */ newTree = this.applyRedirectCommands([], /** @type {?} */ ((route.redirectTo)), {});\n        if (/** @type {?} */ ((route.redirectTo)).startsWith('/')) {\n            return absoluteRedirect(newTree);\n        }\n        return mergeMap.call(this.lineralizeSegments(route, newTree), function (newSegments) {\n            var /** @type {?} */ group = new UrlSegmentGroup(newSegments, {});\n            return _this.expandSegment(ngModule, group, routes, newSegments, outlet, false);\n        });\n    };\n    /**\n     * @param {?} ngModule\n     * @param {?} segmentGroup\n     * @param {?} routes\n     * @param {?} route\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n    ApplyRedirects.prototype.expandRegularSegmentAgainstRouteUsingRedirect = /**\n     * @param {?} ngModule\n     * @param {?} segmentGroup\n     * @param {?} routes\n     * @param {?} route\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n    function (ngModule, segmentGroup, routes, route, segments, outlet) {\n        var _this = this;\n        var _a = match(segmentGroup, route, segments), matched = _a.matched, consumedSegments = _a.consumedSegments, lastChild = _a.lastChild, positionalParamSegments = _a.positionalParamSegments;\n        if (!matched)\n            return noMatch(segmentGroup);\n        var /** @type {?} */ newTree = this.applyRedirectCommands(consumedSegments, /** @type {?} */ ((route.redirectTo)), /** @type {?} */ (positionalParamSegments));\n        if (/** @type {?} */ ((route.redirectTo)).startsWith('/')) {\n            return absoluteRedirect(newTree);\n        }\n        return mergeMap.call(this.lineralizeSegments(route, newTree), function (newSegments) {\n            return _this.expandSegment(ngModule, segmentGroup, routes, newSegments.concat(segments.slice(lastChild)), outlet, false);\n        });\n    };\n    /**\n     * @param {?} ngModule\n     * @param {?} rawSegmentGroup\n     * @param {?} route\n     * @param {?} segments\n     * @return {?}\n     */\n    ApplyRedirects.prototype.matchSegmentAgainstRoute = /**\n     * @param {?} ngModule\n     * @param {?} rawSegmentGroup\n     * @param {?} route\n     * @param {?} segments\n     * @return {?}\n     */\n    function (ngModule, rawSegmentGroup, route, segments) {\n        var _this = this;\n        if (route.path === '**') {\n            if (route.loadChildren) {\n                return map.call(this.configLoader.load(ngModule.injector, route), function (cfg) {\n                    route._loadedConfig = cfg;\n                    return new UrlSegmentGroup(segments, {});\n                });\n            }\n            return of(new UrlSegmentGroup(segments, {}));\n        }\n        var _a = match(rawSegmentGroup, route, segments), matched = _a.matched, consumedSegments = _a.consumedSegments, lastChild = _a.lastChild;\n        if (!matched)\n            return noMatch(rawSegmentGroup);\n        var /** @type {?} */ rawSlicedSegments = segments.slice(lastChild);\n        var /** @type {?} */ childConfig$ = this.getChildConfig(ngModule, route);\n        return mergeMap.call(childConfig$, function (routerConfig) {\n            var /** @type {?} */ childModule = routerConfig.module;\n            var /** @type {?} */ childConfig = routerConfig.routes;\n            var _a = split(rawSegmentGroup, consumedSegments, rawSlicedSegments, childConfig), segmentGroup = _a.segmentGroup, slicedSegments = _a.slicedSegments;\n            if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {\n                var /** @type {?} */ expanded$_1 = _this.expandChildren(childModule, childConfig, segmentGroup);\n                return map.call(expanded$_1, function (children) { return new UrlSegmentGroup(consumedSegments, children); });\n            }\n            if (childConfig.length === 0 && slicedSegments.length === 0) {\n                return of(new UrlSegmentGroup(consumedSegments, {}));\n            }\n            var /** @type {?} */ expanded$ = _this.expandSegment(childModule, segmentGroup, childConfig, slicedSegments, PRIMARY_OUTLET, true);\n            return map.call(expanded$, function (cs) {\n                return new UrlSegmentGroup(consumedSegments.concat(cs.segments), cs.children);\n            });\n        });\n    };\n    /**\n     * @param {?} ngModule\n     * @param {?} route\n     * @return {?}\n     */\n    ApplyRedirects.prototype.getChildConfig = /**\n     * @param {?} ngModule\n     * @param {?} route\n     * @return {?}\n     */\n    function (ngModule, route) {\n        var _this = this;\n        if (route.children) {\n            // The children belong to the same module\n            return of(new LoadedRouterConfig(route.children, ngModule));\n        }\n        if (route.loadChildren) {\n            // lazy children belong to the loaded module\n            if (route._loadedConfig !== undefined) {\n                return of(route._loadedConfig);\n            }\n            return mergeMap.call(runCanLoadGuard(ngModule.injector, route), function (shouldLoad) {\n                if (shouldLoad) {\n                    return map.call(_this.configLoader.load(ngModule.injector, route), function (cfg) {\n                        route._loadedConfig = cfg;\n                        return cfg;\n                    });\n                }\n                return canLoadFails(route);\n            });\n        }\n        return of(new LoadedRouterConfig([], ngModule));\n    };\n    /**\n     * @param {?} route\n     * @param {?} urlTree\n     * @return {?}\n     */\n    ApplyRedirects.prototype.lineralizeSegments = /**\n     * @param {?} route\n     * @param {?} urlTree\n     * @return {?}\n     */\n    function (route, urlTree) {\n        var /** @type {?} */ res = [];\n        var /** @type {?} */ c = urlTree.root;\n        while (true) {\n            res = res.concat(c.segments);\n            if (c.numberOfChildren === 0) {\n                return of(res);\n            }\n            if (c.numberOfChildren > 1 || !c.children[PRIMARY_OUTLET]) {\n                return namedOutletsRedirect(/** @type {?} */ ((route.redirectTo)));\n            }\n            c = c.children[PRIMARY_OUTLET];\n        }\n    };\n    /**\n     * @param {?} segments\n     * @param {?} redirectTo\n     * @param {?} posParams\n     * @return {?}\n     */\n    ApplyRedirects.prototype.applyRedirectCommands = /**\n     * @param {?} segments\n     * @param {?} redirectTo\n     * @param {?} posParams\n     * @return {?}\n     */\n    function (segments, redirectTo, posParams) {\n        return this.applyRedirectCreatreUrlTree(redirectTo, this.urlSerializer.parse(redirectTo), segments, posParams);\n    };\n    /**\n     * @param {?} redirectTo\n     * @param {?} urlTree\n     * @param {?} segments\n     * @param {?} posParams\n     * @return {?}\n     */\n    ApplyRedirects.prototype.applyRedirectCreatreUrlTree = /**\n     * @param {?} redirectTo\n     * @param {?} urlTree\n     * @param {?} segments\n     * @param {?} posParams\n     * @return {?}\n     */\n    function (redirectTo, urlTree, segments, posParams) {\n        var /** @type {?} */ newRoot = this.createSegmentGroup(redirectTo, urlTree.root, segments, posParams);\n        return new UrlTree(newRoot, this.createQueryParams(urlTree.queryParams, this.urlTree.queryParams), urlTree.fragment);\n    };\n    /**\n     * @param {?} redirectToParams\n     * @param {?} actualParams\n     * @return {?}\n     */\n    ApplyRedirects.prototype.createQueryParams = /**\n     * @param {?} redirectToParams\n     * @param {?} actualParams\n     * @return {?}\n     */\n    function (redirectToParams, actualParams) {\n        var /** @type {?} */ res = {};\n        forEach(redirectToParams, function (v, k) {\n            var /** @type {?} */ copySourceValue = typeof v === 'string' && v.startsWith(':');\n            if (copySourceValue) {\n                var /** @type {?} */ sourceName = v.substring(1);\n                res[k] = actualParams[sourceName];\n            }\n            else {\n                res[k] = v;\n            }\n        });\n        return res;\n    };\n    /**\n     * @param {?} redirectTo\n     * @param {?} group\n     * @param {?} segments\n     * @param {?} posParams\n     * @return {?}\n     */\n    ApplyRedirects.prototype.createSegmentGroup = /**\n     * @param {?} redirectTo\n     * @param {?} group\n     * @param {?} segments\n     * @param {?} posParams\n     * @return {?}\n     */\n    function (redirectTo, group, segments, posParams) {\n        var _this = this;\n        var /** @type {?} */ updatedSegments = this.createSegments(redirectTo, group.segments, segments, posParams);\n        var /** @type {?} */ children = {};\n        forEach(group.children, function (child, name) {\n            children[name] = _this.createSegmentGroup(redirectTo, child, segments, posParams);\n        });\n        return new UrlSegmentGroup(updatedSegments, children);\n    };\n    /**\n     * @param {?} redirectTo\n     * @param {?} redirectToSegments\n     * @param {?} actualSegments\n     * @param {?} posParams\n     * @return {?}\n     */\n    ApplyRedirects.prototype.createSegments = /**\n     * @param {?} redirectTo\n     * @param {?} redirectToSegments\n     * @param {?} actualSegments\n     * @param {?} posParams\n     * @return {?}\n     */\n    function (redirectTo, redirectToSegments, actualSegments, posParams) {\n        var _this = this;\n        return redirectToSegments.map(function (s) {\n            return s.path.startsWith(':') ? _this.findPosParam(redirectTo, s, posParams) :\n                _this.findOrReturn(s, actualSegments);\n        });\n    };\n    /**\n     * @param {?} redirectTo\n     * @param {?} redirectToUrlSegment\n     * @param {?} posParams\n     * @return {?}\n     */\n    ApplyRedirects.prototype.findPosParam = /**\n     * @param {?} redirectTo\n     * @param {?} redirectToUrlSegment\n     * @param {?} posParams\n     * @return {?}\n     */\n    function (redirectTo, redirectToUrlSegment, posParams) {\n        var /** @type {?} */ pos = posParams[redirectToUrlSegment.path.substring(1)];\n        if (!pos)\n            throw new Error(\"Cannot redirect to '\" + redirectTo + \"'. Cannot find '\" + redirectToUrlSegment.path + \"'.\");\n        return pos;\n    };\n    /**\n     * @param {?} redirectToUrlSegment\n     * @param {?} actualSegments\n     * @return {?}\n     */\n    ApplyRedirects.prototype.findOrReturn = /**\n     * @param {?} redirectToUrlSegment\n     * @param {?} actualSegments\n     * @return {?}\n     */\n    function (redirectToUrlSegment, actualSegments) {\n        var /** @type {?} */ idx = 0;\n        for (var _i = 0, actualSegments_1 = actualSegments; _i < actualSegments_1.length; _i++) {\n            var s = actualSegments_1[_i];\n            if (s.path === redirectToUrlSegment.path) {\n                actualSegments.splice(idx);\n                return s;\n            }\n            idx++;\n        }\n        return redirectToUrlSegment;\n    };\n    return ApplyRedirects;\n}());\n/**\n * @param {?} moduleInjector\n * @param {?} route\n * @return {?}\n */\nfunction runCanLoadGuard(moduleInjector, route) {\n    var /** @type {?} */ canLoad = route.canLoad;\n    if (!canLoad || canLoad.length === 0)\n        return of(true);\n    var /** @type {?} */ obs = map.call(from(canLoad), function (injectionToken) {\n        var /** @type {?} */ guard = moduleInjector.get(injectionToken);\n        return wrapIntoObservable(guard.canLoad ? guard.canLoad(route) : guard(route));\n    });\n    return andObservables(obs);\n}\n/**\n * @param {?} segmentGroup\n * @param {?} route\n * @param {?} segments\n * @return {?}\n */\nfunction match(segmentGroup, route, segments) {\n    if (route.path === '') {\n        if ((route.pathMatch === 'full') && (segmentGroup.hasChildren() || segments.length > 0)) {\n            return { matched: false, consumedSegments: [], lastChild: 0, positionalParamSegments: {} };\n        }\n        return { matched: true, consumedSegments: [], lastChild: 0, positionalParamSegments: {} };\n    }\n    var /** @type {?} */ matcher = route.matcher || defaultUrlMatcher;\n    var /** @type {?} */ res = matcher(segments, segmentGroup, route);\n    if (!res) {\n        return {\n            matched: false,\n            consumedSegments: /** @type {?} */ ([]),\n            lastChild: 0,\n            positionalParamSegments: {},\n        };\n    }\n    return {\n        matched: true,\n        consumedSegments: /** @type {?} */ ((res.consumed)),\n        lastChild: /** @type {?} */ ((res.consumed.length)),\n        positionalParamSegments: /** @type {?} */ ((res.posParams)),\n    };\n}\n/**\n * @param {?} segmentGroup\n * @param {?} consumedSegments\n * @param {?} slicedSegments\n * @param {?} config\n * @return {?}\n */\nfunction split(segmentGroup, consumedSegments, slicedSegments, config) {\n    if (slicedSegments.length > 0 &&\n        containsEmptyPathRedirectsWithNamedOutlets(segmentGroup, slicedSegments, config)) {\n        var /** @type {?} */ s = new UrlSegmentGroup(consumedSegments, createChildrenForEmptySegments(config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));\n        return { segmentGroup: mergeTrivialChildren(s), slicedSegments: [] };\n    }\n    if (slicedSegments.length === 0 &&\n        containsEmptyPathRedirects(segmentGroup, slicedSegments, config)) {\n        var /** @type {?} */ s = new UrlSegmentGroup(segmentGroup.segments, addEmptySegmentsToChildrenIfNeeded(segmentGroup, slicedSegments, config, segmentGroup.children));\n        return { segmentGroup: mergeTrivialChildren(s), slicedSegments: slicedSegments };\n    }\n    return { segmentGroup: segmentGroup, slicedSegments: slicedSegments };\n}\n/**\n * @param {?} s\n * @return {?}\n */\nfunction mergeTrivialChildren(s) {\n    if (s.numberOfChildren === 1 && s.children[PRIMARY_OUTLET]) {\n        var /** @type {?} */ c = s.children[PRIMARY_OUTLET];\n        return new UrlSegmentGroup(s.segments.concat(c.segments), c.children);\n    }\n    return s;\n}\n/**\n * @param {?} segmentGroup\n * @param {?} slicedSegments\n * @param {?} routes\n * @param {?} children\n * @return {?}\n */\nfunction addEmptySegmentsToChildrenIfNeeded(segmentGroup, slicedSegments, routes, children) {\n    var /** @type {?} */ res = {};\n    for (var _i = 0, routes_1 = routes; _i < routes_1.length; _i++) {\n        var r = routes_1[_i];\n        if (isEmptyPathRedirect(segmentGroup, slicedSegments, r) && !children[getOutlet(r)]) {\n            res[getOutlet(r)] = new UrlSegmentGroup([], {});\n        }\n    }\n    return __assign({}, children, res);\n}\n/**\n * @param {?} routes\n * @param {?} primarySegmentGroup\n * @return {?}\n */\nfunction createChildrenForEmptySegments(routes, primarySegmentGroup) {\n    var /** @type {?} */ res = {};\n    res[PRIMARY_OUTLET] = primarySegmentGroup;\n    for (var _i = 0, routes_2 = routes; _i < routes_2.length; _i++) {\n        var r = routes_2[_i];\n        if (r.path === '' && getOutlet(r) !== PRIMARY_OUTLET) {\n            res[getOutlet(r)] = new UrlSegmentGroup([], {});\n        }\n    }\n    return res;\n}\n/**\n * @param {?} segmentGroup\n * @param {?} segments\n * @param {?} routes\n * @return {?}\n */\nfunction containsEmptyPathRedirectsWithNamedOutlets(segmentGroup, segments, routes) {\n    return routes.some(function (r) { return isEmptyPathRedirect(segmentGroup, segments, r) && getOutlet(r) !== PRIMARY_OUTLET; });\n}\n/**\n * @param {?} segmentGroup\n * @param {?} segments\n * @param {?} routes\n * @return {?}\n */\nfunction containsEmptyPathRedirects(segmentGroup, segments, routes) {\n    return routes.some(function (r) { return isEmptyPathRedirect(segmentGroup, segments, r); });\n}\n/**\n * @param {?} segmentGroup\n * @param {?} segments\n * @param {?} r\n * @return {?}\n */\nfunction isEmptyPathRedirect(segmentGroup, segments, r) {\n    if ((segmentGroup.hasChildren() || segments.length > 0) && r.pathMatch === 'full') {\n        return false;\n    }\n    return r.path === '' && r.redirectTo !== undefined;\n}\n/**\n * @param {?} route\n * @return {?}\n */\nfunction getOutlet(route) {\n    return route.outlet || PRIMARY_OUTLET;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar Tree = (function () {\n    function Tree(root) {\n        this._root = root;\n    }\n    Object.defineProperty(Tree.prototype, \"root\", {\n        get: /**\n         * @return {?}\n         */\n        function () { return this._root.value; },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @internal\n     */\n    /**\n     * \\@internal\n     * @param {?} t\n     * @return {?}\n     */\n    Tree.prototype.parent = /**\n     * \\@internal\n     * @param {?} t\n     * @return {?}\n     */\n    function (t) {\n        var /** @type {?} */ p = this.pathFromRoot(t);\n        return p.length > 1 ? p[p.length - 2] : null;\n    };\n    /**\n     * @internal\n     */\n    /**\n     * \\@internal\n     * @param {?} t\n     * @return {?}\n     */\n    Tree.prototype.children = /**\n     * \\@internal\n     * @param {?} t\n     * @return {?}\n     */\n    function (t) {\n        var /** @type {?} */ n = findNode(t, this._root);\n        return n ? n.children.map(function (t) { return t.value; }) : [];\n    };\n    /**\n     * @internal\n     */\n    /**\n     * \\@internal\n     * @param {?} t\n     * @return {?}\n     */\n    Tree.prototype.firstChild = /**\n     * \\@internal\n     * @param {?} t\n     * @return {?}\n     */\n    function (t) {\n        var /** @type {?} */ n = findNode(t, this._root);\n        return n && n.children.length > 0 ? n.children[0].value : null;\n    };\n    /**\n     * @internal\n     */\n    /**\n     * \\@internal\n     * @param {?} t\n     * @return {?}\n     */\n    Tree.prototype.siblings = /**\n     * \\@internal\n     * @param {?} t\n     * @return {?}\n     */\n    function (t) {\n        var /** @type {?} */ p = findPath(t, this._root);\n        if (p.length < 2)\n            return [];\n        var /** @type {?} */ c = p[p.length - 2].children.map(function (c) { return c.value; });\n        return c.filter(function (cc) { return cc !== t; });\n    };\n    /**\n     * @internal\n     */\n    /**\n     * \\@internal\n     * @param {?} t\n     * @return {?}\n     */\n    Tree.prototype.pathFromRoot = /**\n     * \\@internal\n     * @param {?} t\n     * @return {?}\n     */\n    function (t) { return findPath(t, this._root).map(function (s) { return s.value; }); };\n    return Tree;\n}());\n/**\n * @template T\n * @param {?} value\n * @param {?} node\n * @return {?}\n */\nfunction findNode(value, node) {\n    if (value === node.value)\n        return node;\n    for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n        var child = _a[_i];\n        var /** @type {?} */ node_1 = findNode(value, child);\n        if (node_1)\n            return node_1;\n    }\n    return null;\n}\n/**\n * @template T\n * @param {?} value\n * @param {?} node\n * @return {?}\n */\nfunction findPath(value, node) {\n    if (value === node.value)\n        return [node];\n    for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n        var child = _a[_i];\n        var /** @type {?} */ path = findPath(value, child);\n        if (path.length) {\n            path.unshift(node);\n            return path;\n        }\n    }\n    return [];\n}\nvar TreeNode = (function () {\n    function TreeNode(value, children) {\n        this.value = value;\n        this.children = children;\n    }\n    /**\n     * @return {?}\n     */\n    TreeNode.prototype.toString = /**\n     * @return {?}\n     */\n    function () { return \"TreeNode(\" + this.value + \")\"; };\n    return TreeNode;\n}());\n/**\n * @template T\n * @param {?} node\n * @return {?}\n */\nfunction nodeChildrenAsMap(node) {\n    var /** @type {?} */ map$$1 = {};\n    if (node) {\n        node.children.forEach(function (child) { return map$$1[child.value.outlet] = child; });\n    }\n    return map$$1;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * \\@whatItDoes Represents the state of the router.\n *\n * \\@howToUse\n *\n * ```\n * \\@Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const state: RouterState = router.routerState;\n *     const root: ActivatedRoute = state.root;\n *     const child = root.firstChild;\n *     const id: Observable<string> = child.params.map(p => p.id);\n *     //...\n *   }\n * }\n * ```\n *\n * \\@description\n * RouterState is a tree of activated routes. Every node in this tree knows about the \"consumed\" URL\n * segments, the extracted parameters, and the resolved data.\n *\n * See {\\@link ActivatedRoute} for more information.\n *\n * \\@stable\n */\nvar RouterState = (function (_super) {\n    __extends(RouterState, _super);\n    /** @internal */\n    function RouterState(root, snapshot) {\n        var _this = _super.call(this, root) || this;\n        _this.snapshot = snapshot;\n        setRouterState(/** @type {?} */ (_this), root);\n        return _this;\n    }\n    /**\n     * @return {?}\n     */\n    RouterState.prototype.toString = /**\n     * @return {?}\n     */\n    function () { return this.snapshot.toString(); };\n    return RouterState;\n}(Tree));\n/**\n * @param {?} urlTree\n * @param {?} rootComponent\n * @return {?}\n */\nfunction createEmptyState(urlTree, rootComponent) {\n    var /** @type {?} */ snapshot = createEmptyStateSnapshot(urlTree, rootComponent);\n    var /** @type {?} */ emptyUrl = new BehaviorSubject([new UrlSegment('', {})]);\n    var /** @type {?} */ emptyParams = new BehaviorSubject({});\n    var /** @type {?} */ emptyData = new BehaviorSubject({});\n    var /** @type {?} */ emptyQueryParams = new BehaviorSubject({});\n    var /** @type {?} */ fragment = new BehaviorSubject('');\n    var /** @type {?} */ activated = new ActivatedRoute(emptyUrl, emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, snapshot.root);\n    activated.snapshot = snapshot.root;\n    return new RouterState(new TreeNode(activated, []), snapshot);\n}\n/**\n * @param {?} urlTree\n * @param {?} rootComponent\n * @return {?}\n */\nfunction createEmptyStateSnapshot(urlTree, rootComponent) {\n    var /** @type {?} */ emptyParams = {};\n    var /** @type {?} */ emptyData = {};\n    var /** @type {?} */ emptyQueryParams = {};\n    var /** @type {?} */ fragment = '';\n    var /** @type {?} */ activated = new ActivatedRouteSnapshot([], emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, null, urlTree.root, -1, {});\n    return new RouterStateSnapshot('', new TreeNode(activated, []));\n}\n/**\n * \\@whatItDoes Contains the information about a route associated with a component loaded in an\n * outlet.\n * An `ActivatedRoute` can also be used to traverse the router state tree.\n *\n * \\@howToUse\n *\n * ```\n * \\@Component({...})\n * class MyComponent {\n *   constructor(route: ActivatedRoute) {\n *     const id: Observable<string> = route.params.map(p => p.id);\n *     const url: Observable<string> = route.url.map(segments => segments.join(''));\n *     // route.data includes both `data` and `resolve`\n *     const user = route.data.map(d => d.user);\n *   }\n * }\n * ```\n *\n * \\@stable\n */\nvar ActivatedRoute = (function () {\n    /** @internal */\n    function ActivatedRoute(url, params, queryParams, fragment, data, outlet, component, futureSnapshot) {\n        this.url = url;\n        this.params = params;\n        this.queryParams = queryParams;\n        this.fragment = fragment;\n        this.data = data;\n        this.outlet = outlet;\n        this.component = component;\n        this._futureSnapshot = futureSnapshot;\n    }\n    Object.defineProperty(ActivatedRoute.prototype, \"routeConfig\", {\n        /** The configuration used to match this route */\n        get: /**\n         * The configuration used to match this route\n         * @return {?}\n         */\n        function () { return this._futureSnapshot.routeConfig; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ActivatedRoute.prototype, \"root\", {\n        /** The root of the router state */\n        get: /**\n         * The root of the router state\n         * @return {?}\n         */\n        function () { return this._routerState.root; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ActivatedRoute.prototype, \"parent\", {\n        /** The parent of this route in the router state tree */\n        get: /**\n         * The parent of this route in the router state tree\n         * @return {?}\n         */\n        function () { return this._routerState.parent(this); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ActivatedRoute.prototype, \"firstChild\", {\n        /** The first child of this route in the router state tree */\n        get: /**\n         * The first child of this route in the router state tree\n         * @return {?}\n         */\n        function () { return this._routerState.firstChild(this); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ActivatedRoute.prototype, \"children\", {\n        /** The children of this route in the router state tree */\n        get: /**\n         * The children of this route in the router state tree\n         * @return {?}\n         */\n        function () { return this._routerState.children(this); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ActivatedRoute.prototype, \"pathFromRoot\", {\n        /** The path from the root of the router state tree to this route */\n        get: /**\n         * The path from the root of the router state tree to this route\n         * @return {?}\n         */\n        function () { return this._routerState.pathFromRoot(this); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ActivatedRoute.prototype, \"paramMap\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            if (!this._paramMap) {\n                this._paramMap = map.call(this.params, function (p) { return convertToParamMap(p); });\n            }\n            return this._paramMap;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ActivatedRoute.prototype, \"queryParamMap\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            if (!this._queryParamMap) {\n                this._queryParamMap =\n                    map.call(this.queryParams, function (p) { return convertToParamMap(p); });\n            }\n            return this._queryParamMap;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    ActivatedRoute.prototype.toString = /**\n     * @return {?}\n     */\n    function () {\n        return this.snapshot ? this.snapshot.toString() : \"Future(\" + this._futureSnapshot + \")\";\n    };\n    return ActivatedRoute;\n}());\n/**\n * \\@internal\n * @param {?} route\n * @return {?}\n */\nfunction inheritedParamsDataResolve(route) {\n    var /** @type {?} */ pathToRoot = route.pathFromRoot;\n    var /** @type {?} */ inhertingStartingFrom = pathToRoot.length - 1;\n    while (inhertingStartingFrom >= 1) {\n        var /** @type {?} */ current = pathToRoot[inhertingStartingFrom];\n        var /** @type {?} */ parent_1 = pathToRoot[inhertingStartingFrom - 1];\n        // current route is an empty path => inherits its parent's params and data\n        if (current.routeConfig && current.routeConfig.path === '') {\n            inhertingStartingFrom--;\n            // parent is componentless => current route should inherit its params and data\n        }\n        else if (!parent_1.component) {\n            inhertingStartingFrom--;\n        }\n        else {\n            break;\n        }\n    }\n    return pathToRoot.slice(inhertingStartingFrom).reduce(function (res, curr) {\n        var /** @type {?} */ params = __assign({}, res.params, curr.params);\n        var /** @type {?} */ data = __assign({}, res.data, curr.data);\n        var /** @type {?} */ resolve = __assign({}, res.resolve, curr._resolvedData);\n        return { params: params, data: data, resolve: resolve };\n    }, /** @type {?} */ ({ params: {}, data: {}, resolve: {} }));\n}\n/**\n * \\@whatItDoes Contains the information about a route associated with a component loaded in an\n * outlet\n * at a particular moment in time. ActivatedRouteSnapshot can also be used to traverse the router\n * state tree.\n *\n * \\@howToUse\n *\n * ```\n * \\@Component({templateUrl:'./my-component.html'})\n * class MyComponent {\n *   constructor(route: ActivatedRoute) {\n *     const id: string = route.snapshot.params.id;\n *     const url: string = route.snapshot.url.join('');\n *     const user = route.snapshot.data.user;\n *   }\n * }\n * ```\n *\n * \\@stable\n */\nvar ActivatedRouteSnapshot = (function () {\n    /** @internal */\n    function ActivatedRouteSnapshot(url, params, queryParams, fragment, data, outlet, component, routeConfig, urlSegment, lastPathIndex, resolve) {\n        this.url = url;\n        this.params = params;\n        this.queryParams = queryParams;\n        this.fragment = fragment;\n        this.data = data;\n        this.outlet = outlet;\n        this.component = component;\n        this.routeConfig = routeConfig;\n        this._urlSegment = urlSegment;\n        this._lastPathIndex = lastPathIndex;\n        this._resolve = resolve;\n    }\n    Object.defineProperty(ActivatedRouteSnapshot.prototype, \"root\", {\n        /** The root of the router state */\n        get: /**\n         * The root of the router state\n         * @return {?}\n         */\n        function () { return this._routerState.root; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ActivatedRouteSnapshot.prototype, \"parent\", {\n        /** The parent of this route in the router state tree */\n        get: /**\n         * The parent of this route in the router state tree\n         * @return {?}\n         */\n        function () { return this._routerState.parent(this); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ActivatedRouteSnapshot.prototype, \"firstChild\", {\n        /** The first child of this route in the router state tree */\n        get: /**\n         * The first child of this route in the router state tree\n         * @return {?}\n         */\n        function () { return this._routerState.firstChild(this); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ActivatedRouteSnapshot.prototype, \"children\", {\n        /** The children of this route in the router state tree */\n        get: /**\n         * The children of this route in the router state tree\n         * @return {?}\n         */\n        function () { return this._routerState.children(this); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ActivatedRouteSnapshot.prototype, \"pathFromRoot\", {\n        /** The path from the root of the router state tree to this route */\n        get: /**\n         * The path from the root of the router state tree to this route\n         * @return {?}\n         */\n        function () { return this._routerState.pathFromRoot(this); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ActivatedRouteSnapshot.prototype, \"paramMap\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            if (!this._paramMap) {\n                this._paramMap = convertToParamMap(this.params);\n            }\n            return this._paramMap;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ActivatedRouteSnapshot.prototype, \"queryParamMap\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            if (!this._queryParamMap) {\n                this._queryParamMap = convertToParamMap(this.queryParams);\n            }\n            return this._queryParamMap;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    ActivatedRouteSnapshot.prototype.toString = /**\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ url = this.url.map(function (segment) { return segment.toString(); }).join('/');\n        var /** @type {?} */ matched = this.routeConfig ? this.routeConfig.path : '';\n        return \"Route(url:'\" + url + \"', path:'\" + matched + \"')\";\n    };\n    return ActivatedRouteSnapshot;\n}());\n/**\n * \\@whatItDoes Represents the state of the router at a moment in time.\n *\n * \\@howToUse\n *\n * ```\n * \\@Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const state: RouterState = router.routerState;\n *     const snapshot: RouterStateSnapshot = state.snapshot;\n *     const root: ActivatedRouteSnapshot = snapshot.root;\n *     const child = root.firstChild;\n *     const id: Observable<string> = child.params.map(p => p.id);\n *     //...\n *   }\n * }\n * ```\n *\n * \\@description\n * RouterStateSnapshot is a tree of activated route snapshots. Every node in this tree knows about\n * the \"consumed\" URL segments, the extracted parameters, and the resolved data.\n *\n * \\@stable\n */\nvar RouterStateSnapshot = (function (_super) {\n    __extends(RouterStateSnapshot, _super);\n    /** @internal */\n    function RouterStateSnapshot(url, root) {\n        var _this = _super.call(this, root) || this;\n        _this.url = url;\n        setRouterState(/** @type {?} */ (_this), root);\n        return _this;\n    }\n    /**\n     * @return {?}\n     */\n    RouterStateSnapshot.prototype.toString = /**\n     * @return {?}\n     */\n    function () { return serializeNode(this._root); };\n    return RouterStateSnapshot;\n}(Tree));\n/**\n * @template U, T\n * @param {?} state\n * @param {?} node\n * @return {?}\n */\nfunction setRouterState(state, node) {\n    node.value._routerState = state;\n    node.children.forEach(function (c) { return setRouterState(state, c); });\n}\n/**\n * @param {?} node\n * @return {?}\n */\nfunction serializeNode(node) {\n    var /** @type {?} */ c = node.children.length > 0 ? \" { \" + node.children.map(serializeNode).join(\", \") + \" } \" : '';\n    return \"\" + node.value + c;\n}\n/**\n * The expectation is that the activate route is created with the right set of parameters.\n * So we push new values into the observables only when they are not the initial values.\n * And we detect that by checking if the snapshot field is set.\n * @param {?} route\n * @return {?}\n */\nfunction advanceActivatedRoute(route) {\n    if (route.snapshot) {\n        var /** @type {?} */ currentSnapshot = route.snapshot;\n        var /** @type {?} */ nextSnapshot = route._futureSnapshot;\n        route.snapshot = nextSnapshot;\n        if (!shallowEqual(currentSnapshot.queryParams, nextSnapshot.queryParams)) {\n            (/** @type {?} */ (route.queryParams)).next(nextSnapshot.queryParams);\n        }\n        if (currentSnapshot.fragment !== nextSnapshot.fragment) {\n            (/** @type {?} */ (route.fragment)).next(nextSnapshot.fragment);\n        }\n        if (!shallowEqual(currentSnapshot.params, nextSnapshot.params)) {\n            (/** @type {?} */ (route.params)).next(nextSnapshot.params);\n        }\n        if (!shallowEqualArrays(currentSnapshot.url, nextSnapshot.url)) {\n            (/** @type {?} */ (route.url)).next(nextSnapshot.url);\n        }\n        if (!shallowEqual(currentSnapshot.data, nextSnapshot.data)) {\n            (/** @type {?} */ (route.data)).next(nextSnapshot.data);\n        }\n    }\n    else {\n        route.snapshot = route._futureSnapshot;\n        // this is for resolved data\n        (/** @type {?} */ (route.data)).next(route._futureSnapshot.data);\n    }\n}\n/**\n * @param {?} a\n * @param {?} b\n * @return {?}\n */\nfunction equalParamsAndUrlSegments(a, b) {\n    var /** @type {?} */ equalUrlParams = shallowEqual(a.params, b.params) && equalSegments(a.url, b.url);\n    var /** @type {?} */ parentsMismatch = !a.parent !== !b.parent;\n    return equalUrlParams && !parentsMismatch &&\n        (!a.parent || equalParamsAndUrlSegments(a.parent, /** @type {?} */ ((b.parent))));\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @param {?} routeReuseStrategy\n * @param {?} curr\n * @param {?} prevState\n * @return {?}\n */\nfunction createRouterState(routeReuseStrategy, curr, prevState) {\n    var /** @type {?} */ root = createNode(routeReuseStrategy, curr._root, prevState ? prevState._root : undefined);\n    return new RouterState(root, curr);\n}\n/**\n * @param {?} routeReuseStrategy\n * @param {?} curr\n * @param {?=} prevState\n * @return {?}\n */\nfunction createNode(routeReuseStrategy, curr, prevState) {\n    // reuse an activated route that is currently displayed on the screen\n    if (prevState && routeReuseStrategy.shouldReuseRoute(curr.value, prevState.value.snapshot)) {\n        var /** @type {?} */ value = prevState.value;\n        value._futureSnapshot = curr.value;\n        var /** @type {?} */ children = createOrReuseChildren(routeReuseStrategy, curr, prevState);\n        return new TreeNode(value, children);\n        // retrieve an activated route that is used to be displayed, but is not currently displayed\n    }\n    else if (routeReuseStrategy.retrieve(curr.value)) {\n        var /** @type {?} */ tree = (/** @type {?} */ (routeReuseStrategy.retrieve(curr.value))).route;\n        setFutureSnapshotsOfActivatedRoutes(curr, tree);\n        return tree;\n    }\n    else {\n        var /** @type {?} */ value = createActivatedRoute(curr.value);\n        var /** @type {?} */ children = curr.children.map(function (c) { return createNode(routeReuseStrategy, c); });\n        return new TreeNode(value, children);\n    }\n}\n/**\n * @param {?} curr\n * @param {?} result\n * @return {?}\n */\nfunction setFutureSnapshotsOfActivatedRoutes(curr, result) {\n    if (curr.value.routeConfig !== result.value.routeConfig) {\n        throw new Error('Cannot reattach ActivatedRouteSnapshot created from a different route');\n    }\n    if (curr.children.length !== result.children.length) {\n        throw new Error('Cannot reattach ActivatedRouteSnapshot with a different number of children');\n    }\n    result.value._futureSnapshot = curr.value;\n    for (var /** @type {?} */ i = 0; i < curr.children.length; ++i) {\n        setFutureSnapshotsOfActivatedRoutes(curr.children[i], result.children[i]);\n    }\n}\n/**\n * @param {?} routeReuseStrategy\n * @param {?} curr\n * @param {?} prevState\n * @return {?}\n */\nfunction createOrReuseChildren(routeReuseStrategy, curr, prevState) {\n    return curr.children.map(function (child) {\n        for (var _i = 0, _a = prevState.children; _i < _a.length; _i++) {\n            var p = _a[_i];\n            if (routeReuseStrategy.shouldReuseRoute(p.value.snapshot, child.value)) {\n                return createNode(routeReuseStrategy, child, p);\n            }\n        }\n        return createNode(routeReuseStrategy, child);\n    });\n}\n/**\n * @param {?} c\n * @return {?}\n */\nfunction createActivatedRoute(c) {\n    return new ActivatedRoute(new BehaviorSubject(c.url), new BehaviorSubject(c.params), new BehaviorSubject(c.queryParams), new BehaviorSubject(c.fragment), new BehaviorSubject(c.data), c.outlet, c.component, c);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @param {?} route\n * @param {?} urlTree\n * @param {?} commands\n * @param {?} queryParams\n * @param {?} fragment\n * @return {?}\n */\nfunction createUrlTree(route, urlTree, commands, queryParams, fragment) {\n    if (commands.length === 0) {\n        return tree(urlTree.root, urlTree.root, urlTree, queryParams, fragment);\n    }\n    var /** @type {?} */ nav = computeNavigation(commands);\n    if (nav.toRoot()) {\n        return tree(urlTree.root, new UrlSegmentGroup([], {}), urlTree, queryParams, fragment);\n    }\n    var /** @type {?} */ startingPosition = findStartingPosition(nav, urlTree, route);\n    var /** @type {?} */ segmentGroup = startingPosition.processChildren ?\n        updateSegmentGroupChildren(startingPosition.segmentGroup, startingPosition.index, nav.commands) :\n        updateSegmentGroup(startingPosition.segmentGroup, startingPosition.index, nav.commands);\n    return tree(startingPosition.segmentGroup, segmentGroup, urlTree, queryParams, fragment);\n}\n/**\n * @param {?} command\n * @return {?}\n */\nfunction isMatrixParams(command) {\n    return typeof command === 'object' && command != null && !command.outlets && !command.segmentPath;\n}\n/**\n * @param {?} oldSegmentGroup\n * @param {?} newSegmentGroup\n * @param {?} urlTree\n * @param {?} queryParams\n * @param {?} fragment\n * @return {?}\n */\nfunction tree(oldSegmentGroup, newSegmentGroup, urlTree, queryParams, fragment) {\n    var /** @type {?} */ qp = {};\n    if (queryParams) {\n        forEach(queryParams, function (value, name) {\n            qp[name] = Array.isArray(value) ? value.map(function (v) { return \"\" + v; }) : \"\" + value;\n        });\n    }\n    if (urlTree.root === oldSegmentGroup) {\n        return new UrlTree(newSegmentGroup, qp, fragment);\n    }\n    return new UrlTree(replaceSegment(urlTree.root, oldSegmentGroup, newSegmentGroup), qp, fragment);\n}\n/**\n * @param {?} current\n * @param {?} oldSegment\n * @param {?} newSegment\n * @return {?}\n */\nfunction replaceSegment(current, oldSegment, newSegment) {\n    var /** @type {?} */ children = {};\n    forEach(current.children, function (c, outletName) {\n        if (c === oldSegment) {\n            children[outletName] = newSegment;\n        }\n        else {\n            children[outletName] = replaceSegment(c, oldSegment, newSegment);\n        }\n    });\n    return new UrlSegmentGroup(current.segments, children);\n}\nvar Navigation = (function () {\n    function Navigation(isAbsolute, numberOfDoubleDots, commands) {\n        this.isAbsolute = isAbsolute;\n        this.numberOfDoubleDots = numberOfDoubleDots;\n        this.commands = commands;\n        if (isAbsolute && commands.length > 0 && isMatrixParams(commands[0])) {\n            throw new Error('Root segment cannot have matrix parameters');\n        }\n        var /** @type {?} */ cmdWithOutlet = commands.find(function (c) { return typeof c === 'object' && c != null && c.outlets; });\n        if (cmdWithOutlet && cmdWithOutlet !== last$1(commands)) {\n            throw new Error('{outlets:{}} has to be the last command');\n        }\n    }\n    /**\n     * @return {?}\n     */\n    Navigation.prototype.toRoot = /**\n     * @return {?}\n     */\n    function () {\n        return this.isAbsolute && this.commands.length === 1 && this.commands[0] == '/';\n    };\n    return Navigation;\n}());\n/**\n * Transforms commands to a normalized `Navigation`\n * @param {?} commands\n * @return {?}\n */\nfunction computeNavigation(commands) {\n    if ((typeof commands[0] === 'string') && commands.length === 1 && commands[0] === '/') {\n        return new Navigation(true, 0, commands);\n    }\n    var /** @type {?} */ numberOfDoubleDots = 0;\n    var /** @type {?} */ isAbsolute = false;\n    var /** @type {?} */ res = commands.reduce(function (res, cmd, cmdIdx) {\n        if (typeof cmd === 'object' && cmd != null) {\n            if (cmd.outlets) {\n                var /** @type {?} */ outlets_1 = {};\n                forEach(cmd.outlets, function (commands, name) {\n                    outlets_1[name] = typeof commands === 'string' ? commands.split('/') : commands;\n                });\n                return res.concat([{ outlets: outlets_1 }]);\n            }\n            if (cmd.segmentPath) {\n                return res.concat([cmd.segmentPath]);\n            }\n        }\n        if (!(typeof cmd === 'string')) {\n            return res.concat([cmd]);\n        }\n        if (cmdIdx === 0) {\n            cmd.split('/').forEach(function (urlPart, partIndex) {\n                if (partIndex == 0 && urlPart === '.') {\n                    // skip './a'\n                }\n                else if (partIndex == 0 && urlPart === '') {\n                    //  '/a'\n                    isAbsolute = true;\n                }\n                else if (urlPart === '..') {\n                    //  '../a'\n                    numberOfDoubleDots++;\n                }\n                else if (urlPart != '') {\n                    res.push(urlPart);\n                }\n            });\n            return res;\n        }\n        return res.concat([cmd]);\n    }, []);\n    return new Navigation(isAbsolute, numberOfDoubleDots, res);\n}\nvar Position = (function () {\n    function Position(segmentGroup, processChildren, index) {\n        this.segmentGroup = segmentGroup;\n        this.processChildren = processChildren;\n        this.index = index;\n    }\n    return Position;\n}());\n/**\n * @param {?} nav\n * @param {?} tree\n * @param {?} route\n * @return {?}\n */\nfunction findStartingPosition(nav, tree, route) {\n    if (nav.isAbsolute) {\n        return new Position(tree.root, true, 0);\n    }\n    if (route.snapshot._lastPathIndex === -1) {\n        return new Position(route.snapshot._urlSegment, true, 0);\n    }\n    var /** @type {?} */ modifier = isMatrixParams(nav.commands[0]) ? 0 : 1;\n    var /** @type {?} */ index = route.snapshot._lastPathIndex + modifier;\n    return createPositionApplyingDoubleDots(route.snapshot._urlSegment, index, nav.numberOfDoubleDots);\n}\n/**\n * @param {?} group\n * @param {?} index\n * @param {?} numberOfDoubleDots\n * @return {?}\n */\nfunction createPositionApplyingDoubleDots(group, index, numberOfDoubleDots) {\n    var /** @type {?} */ g = group;\n    var /** @type {?} */ ci = index;\n    var /** @type {?} */ dd = numberOfDoubleDots;\n    while (dd > ci) {\n        dd -= ci;\n        g = /** @type {?} */ ((g.parent));\n        if (!g) {\n            throw new Error('Invalid number of \\'../\\'');\n        }\n        ci = g.segments.length;\n    }\n    return new Position(g, false, ci - dd);\n}\n/**\n * @param {?} command\n * @return {?}\n */\nfunction getPath(command) {\n    if (typeof command === 'object' && command != null && command.outlets) {\n        return command.outlets[PRIMARY_OUTLET];\n    }\n    return \"\" + command;\n}\n/**\n * @param {?} commands\n * @return {?}\n */\nfunction getOutlets(commands) {\n    if (!(typeof commands[0] === 'object'))\n        return _a = {}, _a[PRIMARY_OUTLET] = commands, _a;\n    if (commands[0].outlets === undefined)\n        return _b = {}, _b[PRIMARY_OUTLET] = commands, _b;\n    return commands[0].outlets;\n    var _a, _b;\n}\n/**\n * @param {?} segmentGroup\n * @param {?} startIndex\n * @param {?} commands\n * @return {?}\n */\nfunction updateSegmentGroup(segmentGroup, startIndex, commands) {\n    if (!segmentGroup) {\n        segmentGroup = new UrlSegmentGroup([], {});\n    }\n    if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n        return updateSegmentGroupChildren(segmentGroup, startIndex, commands);\n    }\n    var /** @type {?} */ m = prefixedWith(segmentGroup, startIndex, commands);\n    var /** @type {?} */ slicedCommands = commands.slice(m.commandIndex);\n    if (m.match && m.pathIndex < segmentGroup.segments.length) {\n        var /** @type {?} */ g = new UrlSegmentGroup(segmentGroup.segments.slice(0, m.pathIndex), {});\n        g.children[PRIMARY_OUTLET] =\n            new UrlSegmentGroup(segmentGroup.segments.slice(m.pathIndex), segmentGroup.children);\n        return updateSegmentGroupChildren(g, 0, slicedCommands);\n    }\n    else if (m.match && slicedCommands.length === 0) {\n        return new UrlSegmentGroup(segmentGroup.segments, {});\n    }\n    else if (m.match && !segmentGroup.hasChildren()) {\n        return createNewSegmentGroup(segmentGroup, startIndex, commands);\n    }\n    else if (m.match) {\n        return updateSegmentGroupChildren(segmentGroup, 0, slicedCommands);\n    }\n    else {\n        return createNewSegmentGroup(segmentGroup, startIndex, commands);\n    }\n}\n/**\n * @param {?} segmentGroup\n * @param {?} startIndex\n * @param {?} commands\n * @return {?}\n */\nfunction updateSegmentGroupChildren(segmentGroup, startIndex, commands) {\n    if (commands.length === 0) {\n        return new UrlSegmentGroup(segmentGroup.segments, {});\n    }\n    else {\n        var /** @type {?} */ outlets_2 = getOutlets(commands);\n        var /** @type {?} */ children_1 = {};\n        forEach(outlets_2, function (commands, outlet) {\n            if (commands !== null) {\n                children_1[outlet] = updateSegmentGroup(segmentGroup.children[outlet], startIndex, commands);\n            }\n        });\n        forEach(segmentGroup.children, function (child, childOutlet) {\n            if (outlets_2[childOutlet] === undefined) {\n                children_1[childOutlet] = child;\n            }\n        });\n        return new UrlSegmentGroup(segmentGroup.segments, children_1);\n    }\n}\n/**\n * @param {?} segmentGroup\n * @param {?} startIndex\n * @param {?} commands\n * @return {?}\n */\nfunction prefixedWith(segmentGroup, startIndex, commands) {\n    var /** @type {?} */ currentCommandIndex = 0;\n    var /** @type {?} */ currentPathIndex = startIndex;\n    var /** @type {?} */ noMatch = { match: false, pathIndex: 0, commandIndex: 0 };\n    while (currentPathIndex < segmentGroup.segments.length) {\n        if (currentCommandIndex >= commands.length)\n            return noMatch;\n        var /** @type {?} */ path = segmentGroup.segments[currentPathIndex];\n        var /** @type {?} */ curr = getPath(commands[currentCommandIndex]);\n        var /** @type {?} */ next = currentCommandIndex < commands.length - 1 ? commands[currentCommandIndex + 1] : null;\n        if (currentPathIndex > 0 && curr === undefined)\n            break;\n        if (curr && next && (typeof next === 'object') && next.outlets === undefined) {\n            if (!compare(curr, next, path))\n                return noMatch;\n            currentCommandIndex += 2;\n        }\n        else {\n            if (!compare(curr, {}, path))\n                return noMatch;\n            currentCommandIndex++;\n        }\n        currentPathIndex++;\n    }\n    return { match: true, pathIndex: currentPathIndex, commandIndex: currentCommandIndex };\n}\n/**\n * @param {?} segmentGroup\n * @param {?} startIndex\n * @param {?} commands\n * @return {?}\n */\nfunction createNewSegmentGroup(segmentGroup, startIndex, commands) {\n    var /** @type {?} */ paths = segmentGroup.segments.slice(0, startIndex);\n    var /** @type {?} */ i = 0;\n    while (i < commands.length) {\n        if (typeof commands[i] === 'object' && commands[i].outlets !== undefined) {\n            var /** @type {?} */ children = createNewSegmentChildren(commands[i].outlets);\n            return new UrlSegmentGroup(paths, children);\n        }\n        // if we start with an object literal, we need to reuse the path part from the segment\n        if (i === 0 && isMatrixParams(commands[0])) {\n            var /** @type {?} */ p = segmentGroup.segments[startIndex];\n            paths.push(new UrlSegment(p.path, commands[0]));\n            i++;\n            continue;\n        }\n        var /** @type {?} */ curr = getPath(commands[i]);\n        var /** @type {?} */ next = (i < commands.length - 1) ? commands[i + 1] : null;\n        if (curr && next && isMatrixParams(next)) {\n            paths.push(new UrlSegment(curr, stringify(next)));\n            i += 2;\n        }\n        else {\n            paths.push(new UrlSegment(curr, {}));\n            i++;\n        }\n    }\n    return new UrlSegmentGroup(paths, {});\n}\n/**\n * @param {?} outlets\n * @return {?}\n */\nfunction createNewSegmentChildren(outlets) {\n    var /** @type {?} */ children = {};\n    forEach(outlets, function (commands, outlet) {\n        if (commands !== null) {\n            children[outlet] = createNewSegmentGroup(new UrlSegmentGroup([], {}), 0, commands);\n        }\n    });\n    return children;\n}\n/**\n * @param {?} params\n * @return {?}\n */\nfunction stringify(params) {\n    var /** @type {?} */ res = {};\n    forEach(params, function (v, k) { return res[k] = \"\" + v; });\n    return res;\n}\n/**\n * @param {?} path\n * @param {?} params\n * @param {?} segment\n * @return {?}\n */\nfunction compare(path, params, segment) {\n    return path == segment.path && shallowEqual(params, segment.parameters);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar CanActivate = (function () {\n    function CanActivate(path) {\n        this.path = path;\n    }\n    Object.defineProperty(CanActivate.prototype, \"route\", {\n        get: /**\n         * @return {?}\n         */\n        function () { return this.path[this.path.length - 1]; },\n        enumerable: true,\n        configurable: true\n    });\n    return CanActivate;\n}());\nvar CanDeactivate = (function () {\n    function CanDeactivate(component, route) {\n        this.component = component;\n        this.route = route;\n    }\n    return CanDeactivate;\n}());\n/**\n * This class bundles the actions involved in preactivation of a route.\n */\nvar PreActivation = (function () {\n    function PreActivation(future, curr, moduleInjector, forwardEvent) {\n        this.future = future;\n        this.curr = curr;\n        this.moduleInjector = moduleInjector;\n        this.forwardEvent = forwardEvent;\n        this.canActivateChecks = [];\n        this.canDeactivateChecks = [];\n    }\n    /**\n     * @param {?} parentContexts\n     * @return {?}\n     */\n    PreActivation.prototype.initialize = /**\n     * @param {?} parentContexts\n     * @return {?}\n     */\n    function (parentContexts) {\n        var /** @type {?} */ futureRoot = this.future._root;\n        var /** @type {?} */ currRoot = this.curr ? this.curr._root : null;\n        this.setupChildRouteGuards(futureRoot, currRoot, parentContexts, [futureRoot.value]);\n    };\n    /**\n     * @return {?}\n     */\n    PreActivation.prototype.checkGuards = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (!this.isDeactivating() && !this.isActivating()) {\n            return of(true);\n        }\n        var /** @type {?} */ canDeactivate$ = this.runCanDeactivateChecks();\n        return mergeMap.call(canDeactivate$, function (canDeactivate) { return canDeactivate ? _this.runCanActivateChecks() : of(false); });\n    };\n    /**\n     * @return {?}\n     */\n    PreActivation.prototype.resolveData = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (!this.isActivating())\n            return of(null);\n        var /** @type {?} */ checks$ = from(this.canActivateChecks);\n        var /** @type {?} */ runningChecks$ = concatMap.call(checks$, function (check) { return _this.runResolve(check.route); });\n        return reduce.call(runningChecks$, function (_, __) { return _; });\n    };\n    /**\n     * @return {?}\n     */\n    PreActivation.prototype.isDeactivating = /**\n     * @return {?}\n     */\n    function () { return this.canDeactivateChecks.length !== 0; };\n    /**\n     * @return {?}\n     */\n    PreActivation.prototype.isActivating = /**\n     * @return {?}\n     */\n    function () { return this.canActivateChecks.length !== 0; };\n    /**\n     * Iterates over child routes and calls recursive `setupRouteGuards` to get `this` instance in\n     * proper state to run `checkGuards()` method.\n     * @param {?} futureNode\n     * @param {?} currNode\n     * @param {?} contexts\n     * @param {?} futurePath\n     * @return {?}\n     */\n    PreActivation.prototype.setupChildRouteGuards = /**\n     * Iterates over child routes and calls recursive `setupRouteGuards` to get `this` instance in\n     * proper state to run `checkGuards()` method.\n     * @param {?} futureNode\n     * @param {?} currNode\n     * @param {?} contexts\n     * @param {?} futurePath\n     * @return {?}\n     */\n    function (futureNode, currNode, contexts, futurePath) {\n        var _this = this;\n        var /** @type {?} */ prevChildren = nodeChildrenAsMap(currNode);\n        // Process the children of the future route\n        futureNode.children.forEach(function (c) {\n            _this.setupRouteGuards(c, prevChildren[c.value.outlet], contexts, futurePath.concat([c.value]));\n            delete prevChildren[c.value.outlet];\n        });\n        // Process any children left from the current route (not active for the future route)\n        forEach(prevChildren, function (v, k) {\n            return _this.deactivateRouteAndItsChildren(v, /** @type {?} */ ((contexts)).getContext(k));\n        });\n    };\n    /**\n     * Iterates over child routes and calls recursive `setupRouteGuards` to get `this` instance in\n     * proper state to run `checkGuards()` method.\n     * @param {?} futureNode\n     * @param {?} currNode\n     * @param {?} parentContexts\n     * @param {?} futurePath\n     * @return {?}\n     */\n    PreActivation.prototype.setupRouteGuards = /**\n     * Iterates over child routes and calls recursive `setupRouteGuards` to get `this` instance in\n     * proper state to run `checkGuards()` method.\n     * @param {?} futureNode\n     * @param {?} currNode\n     * @param {?} parentContexts\n     * @param {?} futurePath\n     * @return {?}\n     */\n    function (futureNode, currNode, parentContexts, futurePath) {\n        var /** @type {?} */ future = futureNode.value;\n        var /** @type {?} */ curr = currNode ? currNode.value : null;\n        var /** @type {?} */ context = parentContexts ? parentContexts.getContext(futureNode.value.outlet) : null;\n        // reusing the node\n        if (curr && future.routeConfig === curr.routeConfig) {\n            var /** @type {?} */ shouldRunGuardsAndResolvers = this.shouldRunGuardsAndResolvers(curr, future, /** @type {?} */ ((future.routeConfig)).runGuardsAndResolvers);\n            if (shouldRunGuardsAndResolvers) {\n                this.canActivateChecks.push(new CanActivate(futurePath));\n            }\n            else {\n                // we need to set the data\n                future.data = curr.data;\n                future._resolvedData = curr._resolvedData;\n            }\n            // If we have a component, we need to go through an outlet.\n            if (future.component) {\n                this.setupChildRouteGuards(futureNode, currNode, context ? context.children : null, futurePath);\n                // if we have a componentless route, we recurse but keep the same outlet map.\n            }\n            else {\n                this.setupChildRouteGuards(futureNode, currNode, parentContexts, futurePath);\n            }\n            if (shouldRunGuardsAndResolvers) {\n                var /** @type {?} */ outlet = /** @type {?} */ ((/** @type {?} */ ((context)).outlet));\n                this.canDeactivateChecks.push(new CanDeactivate(outlet.component, curr));\n            }\n        }\n        else {\n            if (curr) {\n                this.deactivateRouteAndItsChildren(currNode, context);\n            }\n            this.canActivateChecks.push(new CanActivate(futurePath));\n            // If we have a component, we need to go through an outlet.\n            if (future.component) {\n                this.setupChildRouteGuards(futureNode, null, context ? context.children : null, futurePath);\n                // if we have a componentless route, we recurse but keep the same outlet map.\n            }\n            else {\n                this.setupChildRouteGuards(futureNode, null, parentContexts, futurePath);\n            }\n        }\n    };\n    /**\n     * @param {?} curr\n     * @param {?} future\n     * @param {?} mode\n     * @return {?}\n     */\n    PreActivation.prototype.shouldRunGuardsAndResolvers = /**\n     * @param {?} curr\n     * @param {?} future\n     * @param {?} mode\n     * @return {?}\n     */\n    function (curr, future, mode) {\n        switch (mode) {\n            case 'always':\n                return true;\n            case 'paramsOrQueryParamsChange':\n                return !equalParamsAndUrlSegments(curr, future) ||\n                    !shallowEqual(curr.queryParams, future.queryParams);\n            case 'paramsChange':\n            default:\n                return !equalParamsAndUrlSegments(curr, future);\n        }\n    };\n    /**\n     * @param {?} route\n     * @param {?} context\n     * @return {?}\n     */\n    PreActivation.prototype.deactivateRouteAndItsChildren = /**\n     * @param {?} route\n     * @param {?} context\n     * @return {?}\n     */\n    function (route, context) {\n        var _this = this;\n        var /** @type {?} */ children = nodeChildrenAsMap(route);\n        var /** @type {?} */ r = route.value;\n        forEach(children, function (node, childName) {\n            if (!r.component) {\n                _this.deactivateRouteAndItsChildren(node, context);\n            }\n            else if (context) {\n                _this.deactivateRouteAndItsChildren(node, context.children.getContext(childName));\n            }\n            else {\n                _this.deactivateRouteAndItsChildren(node, null);\n            }\n        });\n        if (!r.component) {\n            this.canDeactivateChecks.push(new CanDeactivate(null, r));\n        }\n        else if (context && context.outlet && context.outlet.isActivated) {\n            this.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, r));\n        }\n        else {\n            this.canDeactivateChecks.push(new CanDeactivate(null, r));\n        }\n    };\n    /**\n     * @return {?}\n     */\n    PreActivation.prototype.runCanDeactivateChecks = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        var /** @type {?} */ checks$ = from(this.canDeactivateChecks);\n        var /** @type {?} */ runningChecks$ = mergeMap.call(checks$, function (check) { return _this.runCanDeactivate(check.component, check.route); });\n        return every.call(runningChecks$, function (result) { return result === true; });\n    };\n    /**\n     * @return {?}\n     */\n    PreActivation.prototype.runCanActivateChecks = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        var /** @type {?} */ checks$ = from(this.canActivateChecks);\n        var /** @type {?} */ runningChecks$ = concatMap.call(checks$, function (check) {\n            return andObservables(from([\n                _this.fireChildActivationStart(check.route.parent), _this.fireActivationStart(check.route),\n                _this.runCanActivateChild(check.path), _this.runCanActivate(check.route)\n            ]));\n        });\n        return every.call(runningChecks$, function (result) { return result === true; });\n        // this.fireChildActivationStart(check.path),\n    };\n    /**\n     * This should fire off `ActivationStart` events for each route being activated at this\n     * level.\n     * In other words, if you're activating `a` and `b` below, `path` will contain the\n     * `ActivatedRouteSnapshot`s for both and we will fire `ActivationStart` for both. Always\n     * return\n     * `true` so checks continue to run.\n     * @param {?} snapshot\n     * @return {?}\n     */\n    PreActivation.prototype.fireActivationStart = /**\n     * This should fire off `ActivationStart` events for each route being activated at this\n     * level.\n     * In other words, if you're activating `a` and `b` below, `path` will contain the\n     * `ActivatedRouteSnapshot`s for both and we will fire `ActivationStart` for both. Always\n     * return\n     * `true` so checks continue to run.\n     * @param {?} snapshot\n     * @return {?}\n     */\n    function (snapshot) {\n        if (snapshot !== null && this.forwardEvent) {\n            this.forwardEvent(new ActivationStart(snapshot));\n        }\n        return of(true);\n    };\n    /**\n     * This should fire off `ChildActivationStart` events for each route being activated at this\n     * level.\n     * In other words, if you're activating `a` and `b` below, `path` will contain the\n     * `ActivatedRouteSnapshot`s for both and we will fire `ChildActivationStart` for both. Always\n     * return\n     * `true` so checks continue to run.\n     * @param {?} snapshot\n     * @return {?}\n     */\n    PreActivation.prototype.fireChildActivationStart = /**\n     * This should fire off `ChildActivationStart` events for each route being activated at this\n     * level.\n     * In other words, if you're activating `a` and `b` below, `path` will contain the\n     * `ActivatedRouteSnapshot`s for both and we will fire `ChildActivationStart` for both. Always\n     * return\n     * `true` so checks continue to run.\n     * @param {?} snapshot\n     * @return {?}\n     */\n    function (snapshot) {\n        if (snapshot !== null && this.forwardEvent) {\n            this.forwardEvent(new ChildActivationStart(snapshot));\n        }\n        return of(true);\n    };\n    /**\n     * @param {?} future\n     * @return {?}\n     */\n    PreActivation.prototype.runCanActivate = /**\n     * @param {?} future\n     * @return {?}\n     */\n    function (future) {\n        var _this = this;\n        var /** @type {?} */ canActivate = future.routeConfig ? future.routeConfig.canActivate : null;\n        if (!canActivate || canActivate.length === 0)\n            return of(true);\n        var /** @type {?} */ obs = map.call(from(canActivate), function (c) {\n            var /** @type {?} */ guard = _this.getToken(c, future);\n            var /** @type {?} */ observable;\n            if (guard.canActivate) {\n                observable = wrapIntoObservable(guard.canActivate(future, _this.future));\n            }\n            else {\n                observable = wrapIntoObservable(guard(future, _this.future));\n            }\n            return first.call(observable);\n        });\n        return andObservables(obs);\n    };\n    /**\n     * @param {?} path\n     * @return {?}\n     */\n    PreActivation.prototype.runCanActivateChild = /**\n     * @param {?} path\n     * @return {?}\n     */\n    function (path) {\n        var _this = this;\n        var /** @type {?} */ future = path[path.length - 1];\n        var /** @type {?} */ canActivateChildGuards = path.slice(0, path.length - 1)\n            .reverse()\n            .map(function (p) { return _this.extractCanActivateChild(p); })\n            .filter(function (_) { return _ !== null; });\n        return andObservables(map.call(from(canActivateChildGuards), function (d) {\n            var /** @type {?} */ obs = map.call(from(d.guards), function (c) {\n                var /** @type {?} */ guard = _this.getToken(c, d.node);\n                var /** @type {?} */ observable;\n                if (guard.canActivateChild) {\n                    observable = wrapIntoObservable(guard.canActivateChild(future, _this.future));\n                }\n                else {\n                    observable = wrapIntoObservable(guard(future, _this.future));\n                }\n                return first.call(observable);\n            });\n            return andObservables(obs);\n        }));\n    };\n    /**\n     * @param {?} p\n     * @return {?}\n     */\n    PreActivation.prototype.extractCanActivateChild = /**\n     * @param {?} p\n     * @return {?}\n     */\n    function (p) {\n        var /** @type {?} */ canActivateChild = p.routeConfig ? p.routeConfig.canActivateChild : null;\n        if (!canActivateChild || canActivateChild.length === 0)\n            return null;\n        return { node: p, guards: canActivateChild };\n    };\n    /**\n     * @param {?} component\n     * @param {?} curr\n     * @return {?}\n     */\n    PreActivation.prototype.runCanDeactivate = /**\n     * @param {?} component\n     * @param {?} curr\n     * @return {?}\n     */\n    function (component, curr) {\n        var _this = this;\n        var /** @type {?} */ canDeactivate = curr && curr.routeConfig ? curr.routeConfig.canDeactivate : null;\n        if (!canDeactivate || canDeactivate.length === 0)\n            return of(true);\n        var /** @type {?} */ canDeactivate$ = mergeMap.call(from(canDeactivate), function (c) {\n            var /** @type {?} */ guard = _this.getToken(c, curr);\n            var /** @type {?} */ observable;\n            if (guard.canDeactivate) {\n                observable =\n                    wrapIntoObservable(guard.canDeactivate(component, curr, _this.curr, _this.future));\n            }\n            else {\n                observable = wrapIntoObservable(guard(component, curr, _this.curr, _this.future));\n            }\n            return first.call(observable);\n        });\n        return every.call(canDeactivate$, function (result) { return result === true; });\n    };\n    /**\n     * @param {?} future\n     * @return {?}\n     */\n    PreActivation.prototype.runResolve = /**\n     * @param {?} future\n     * @return {?}\n     */\n    function (future) {\n        var /** @type {?} */ resolve = future._resolve;\n        return map.call(this.resolveNode(resolve, future), function (resolvedData) {\n            future._resolvedData = resolvedData;\n            future.data = __assign({}, future.data, inheritedParamsDataResolve(future).resolve);\n            return null;\n        });\n    };\n    /**\n     * @param {?} resolve\n     * @param {?} future\n     * @return {?}\n     */\n    PreActivation.prototype.resolveNode = /**\n     * @param {?} resolve\n     * @param {?} future\n     * @return {?}\n     */\n    function (resolve, future) {\n        var _this = this;\n        var /** @type {?} */ keys = Object.keys(resolve);\n        if (keys.length === 0) {\n            return of({});\n        }\n        if (keys.length === 1) {\n            var /** @type {?} */ key_1 = keys[0];\n            return map.call(this.getResolver(resolve[key_1], future), function (value) {\n                return _a = {}, _a[key_1] = value, _a;\n                var _a;\n            });\n        }\n        var /** @type {?} */ data = {};\n        var /** @type {?} */ runningResolvers$ = mergeMap.call(from(keys), function (key) {\n            return map.call(_this.getResolver(resolve[key], future), function (value) {\n                data[key] = value;\n                return value;\n            });\n        });\n        return map.call(last.call(runningResolvers$), function () { return data; });\n    };\n    /**\n     * @param {?} injectionToken\n     * @param {?} future\n     * @return {?}\n     */\n    PreActivation.prototype.getResolver = /**\n     * @param {?} injectionToken\n     * @param {?} future\n     * @return {?}\n     */\n    function (injectionToken, future) {\n        var /** @type {?} */ resolver = this.getToken(injectionToken, future);\n        return resolver.resolve ? wrapIntoObservable(resolver.resolve(future, this.future)) :\n            wrapIntoObservable(resolver(future, this.future));\n    };\n    /**\n     * @param {?} token\n     * @param {?} snapshot\n     * @return {?}\n     */\n    PreActivation.prototype.getToken = /**\n     * @param {?} token\n     * @param {?} snapshot\n     * @return {?}\n     */\n    function (token, snapshot) {\n        var /** @type {?} */ config = closestLoadedConfig(snapshot);\n        var /** @type {?} */ injector = config ? config.module.injector : this.moduleInjector;\n        return injector.get(token);\n    };\n    return PreActivation;\n}());\n/**\n * @param {?} snapshot\n * @return {?}\n */\nfunction closestLoadedConfig(snapshot) {\n    if (!snapshot)\n        return null;\n    for (var /** @type {?} */ s = snapshot.parent; s; s = s.parent) {\n        var /** @type {?} */ route = s.routeConfig;\n        if (route && route._loadedConfig)\n            return route._loadedConfig;\n    }\n    return null;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar NoMatch$1 = (function () {\n    function NoMatch() {\n    }\n    return NoMatch;\n}());\n/**\n * @param {?} rootComponentType\n * @param {?} config\n * @param {?} urlTree\n * @param {?} url\n * @return {?}\n */\nfunction recognize(rootComponentType, config, urlTree, url) {\n    return new Recognizer(rootComponentType, config, urlTree, url).recognize();\n}\nvar Recognizer = (function () {\n    function Recognizer(rootComponentType, config, urlTree, url) {\n        this.rootComponentType = rootComponentType;\n        this.config = config;\n        this.urlTree = urlTree;\n        this.url = url;\n    }\n    /**\n     * @return {?}\n     */\n    Recognizer.prototype.recognize = /**\n     * @return {?}\n     */\n    function () {\n        try {\n            var /** @type {?} */ rootSegmentGroup = split$1(this.urlTree.root, [], [], this.config).segmentGroup;\n            var /** @type {?} */ children = this.processSegmentGroup(this.config, rootSegmentGroup, PRIMARY_OUTLET);\n            var /** @type {?} */ root = new ActivatedRouteSnapshot([], Object.freeze({}), Object.freeze(this.urlTree.queryParams), /** @type {?} */ ((this.urlTree.fragment)), {}, PRIMARY_OUTLET, this.rootComponentType, null, this.urlTree.root, -1, {});\n            var /** @type {?} */ rootNode = new TreeNode(root, children);\n            var /** @type {?} */ routeState = new RouterStateSnapshot(this.url, rootNode);\n            this.inheritParamsAndData(routeState._root);\n            return of(routeState);\n        }\n        catch (/** @type {?} */ e) {\n            return new Observable(function (obs) { return obs.error(e); });\n        }\n    };\n    /**\n     * @param {?} routeNode\n     * @return {?}\n     */\n    Recognizer.prototype.inheritParamsAndData = /**\n     * @param {?} routeNode\n     * @return {?}\n     */\n    function (routeNode) {\n        var _this = this;\n        var /** @type {?} */ route = routeNode.value;\n        var /** @type {?} */ i = inheritedParamsDataResolve(route);\n        route.params = Object.freeze(i.params);\n        route.data = Object.freeze(i.data);\n        routeNode.children.forEach(function (n) { return _this.inheritParamsAndData(n); });\n    };\n    /**\n     * @param {?} config\n     * @param {?} segmentGroup\n     * @param {?} outlet\n     * @return {?}\n     */\n    Recognizer.prototype.processSegmentGroup = /**\n     * @param {?} config\n     * @param {?} segmentGroup\n     * @param {?} outlet\n     * @return {?}\n     */\n    function (config, segmentGroup, outlet) {\n        if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n            return this.processChildren(config, segmentGroup);\n        }\n        return this.processSegment(config, segmentGroup, segmentGroup.segments, outlet);\n    };\n    /**\n     * @param {?} config\n     * @param {?} segmentGroup\n     * @return {?}\n     */\n    Recognizer.prototype.processChildren = /**\n     * @param {?} config\n     * @param {?} segmentGroup\n     * @return {?}\n     */\n    function (config, segmentGroup) {\n        var _this = this;\n        var /** @type {?} */ children = mapChildrenIntoArray(segmentGroup, function (child, childOutlet) { return _this.processSegmentGroup(config, child, childOutlet); });\n        checkOutletNameUniqueness(children);\n        sortActivatedRouteSnapshots(children);\n        return children;\n    };\n    /**\n     * @param {?} config\n     * @param {?} segmentGroup\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n    Recognizer.prototype.processSegment = /**\n     * @param {?} config\n     * @param {?} segmentGroup\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n    function (config, segmentGroup, segments, outlet) {\n        for (var _i = 0, config_1 = config; _i < config_1.length; _i++) {\n            var r = config_1[_i];\n            try {\n                return this.processSegmentAgainstRoute(r, segmentGroup, segments, outlet);\n            }\n            catch (/** @type {?} */ e) {\n                if (!(e instanceof NoMatch$1))\n                    throw e;\n            }\n        }\n        if (this.noLeftoversInUrl(segmentGroup, segments, outlet)) {\n            return [];\n        }\n        throw new NoMatch$1();\n    };\n    /**\n     * @param {?} segmentGroup\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n    Recognizer.prototype.noLeftoversInUrl = /**\n     * @param {?} segmentGroup\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n    function (segmentGroup, segments, outlet) {\n        return segments.length === 0 && !segmentGroup.children[outlet];\n    };\n    /**\n     * @param {?} route\n     * @param {?} rawSegment\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n    Recognizer.prototype.processSegmentAgainstRoute = /**\n     * @param {?} route\n     * @param {?} rawSegment\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n    function (route, rawSegment, segments, outlet) {\n        if (route.redirectTo)\n            throw new NoMatch$1();\n        if ((route.outlet || PRIMARY_OUTLET) !== outlet)\n            throw new NoMatch$1();\n        if (route.path === '**') {\n            var /** @type {?} */ params = segments.length > 0 ? /** @type {?} */ ((last$1(segments))).parameters : {};\n            var /** @type {?} */ snapshot_1 = new ActivatedRouteSnapshot(segments, params, Object.freeze(this.urlTree.queryParams), /** @type {?} */ ((this.urlTree.fragment)), getData(route), outlet, /** @type {?} */ ((route.component)), route, getSourceSegmentGroup(rawSegment), getPathIndexShift(rawSegment) + segments.length, getResolve(route));\n            return [new TreeNode(snapshot_1, [])];\n        }\n        var _a = match$1(rawSegment, route, segments), consumedSegments = _a.consumedSegments, parameters = _a.parameters, lastChild = _a.lastChild;\n        var /** @type {?} */ rawSlicedSegments = segments.slice(lastChild);\n        var /** @type {?} */ childConfig = getChildConfig(route);\n        var _b = split$1(rawSegment, consumedSegments, rawSlicedSegments, childConfig), segmentGroup = _b.segmentGroup, slicedSegments = _b.slicedSegments;\n        var /** @type {?} */ snapshot = new ActivatedRouteSnapshot(consumedSegments, parameters, Object.freeze(this.urlTree.queryParams), /** @type {?} */ ((this.urlTree.fragment)), getData(route), outlet, /** @type {?} */ ((route.component)), route, getSourceSegmentGroup(rawSegment), getPathIndexShift(rawSegment) + consumedSegments.length, getResolve(route));\n        if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {\n            var /** @type {?} */ children_1 = this.processChildren(childConfig, segmentGroup);\n            return [new TreeNode(snapshot, children_1)];\n        }\n        if (childConfig.length === 0 && slicedSegments.length === 0) {\n            return [new TreeNode(snapshot, [])];\n        }\n        var /** @type {?} */ children = this.processSegment(childConfig, segmentGroup, slicedSegments, PRIMARY_OUTLET);\n        return [new TreeNode(snapshot, children)];\n    };\n    return Recognizer;\n}());\n/**\n * @param {?} nodes\n * @return {?}\n */\nfunction sortActivatedRouteSnapshots(nodes) {\n    nodes.sort(function (a, b) {\n        if (a.value.outlet === PRIMARY_OUTLET)\n            return -1;\n        if (b.value.outlet === PRIMARY_OUTLET)\n            return 1;\n        return a.value.outlet.localeCompare(b.value.outlet);\n    });\n}\n/**\n * @param {?} route\n * @return {?}\n */\nfunction getChildConfig(route) {\n    if (route.children) {\n        return route.children;\n    }\n    if (route.loadChildren) {\n        return /** @type {?} */ ((route._loadedConfig)).routes;\n    }\n    return [];\n}\n/**\n * @param {?} segmentGroup\n * @param {?} route\n * @param {?} segments\n * @return {?}\n */\nfunction match$1(segmentGroup, route, segments) {\n    if (route.path === '') {\n        if (route.pathMatch === 'full' && (segmentGroup.hasChildren() || segments.length > 0)) {\n            throw new NoMatch$1();\n        }\n        return { consumedSegments: [], lastChild: 0, parameters: {} };\n    }\n    var /** @type {?} */ matcher = route.matcher || defaultUrlMatcher;\n    var /** @type {?} */ res = matcher(segments, segmentGroup, route);\n    if (!res)\n        throw new NoMatch$1();\n    var /** @type {?} */ posParams = {};\n    forEach(/** @type {?} */ ((res.posParams)), function (v, k) { posParams[k] = v.path; });\n    var /** @type {?} */ parameters = res.consumed.length > 0 ? __assign({}, posParams, res.consumed[res.consumed.length - 1].parameters) :\n        posParams;\n    return { consumedSegments: res.consumed, lastChild: res.consumed.length, parameters: parameters };\n}\n/**\n * @param {?} nodes\n * @return {?}\n */\nfunction checkOutletNameUniqueness(nodes) {\n    var /** @type {?} */ names = {};\n    nodes.forEach(function (n) {\n        var /** @type {?} */ routeWithSameOutletName = names[n.value.outlet];\n        if (routeWithSameOutletName) {\n            var /** @type {?} */ p = routeWithSameOutletName.url.map(function (s) { return s.toString(); }).join('/');\n            var /** @type {?} */ c = n.value.url.map(function (s) { return s.toString(); }).join('/');\n            throw new Error(\"Two segments cannot have the same outlet name: '\" + p + \"' and '\" + c + \"'.\");\n        }\n        names[n.value.outlet] = n.value;\n    });\n}\n/**\n * @param {?} segmentGroup\n * @return {?}\n */\nfunction getSourceSegmentGroup(segmentGroup) {\n    var /** @type {?} */ s = segmentGroup;\n    while (s._sourceSegment) {\n        s = s._sourceSegment;\n    }\n    return s;\n}\n/**\n * @param {?} segmentGroup\n * @return {?}\n */\nfunction getPathIndexShift(segmentGroup) {\n    var /** @type {?} */ s = segmentGroup;\n    var /** @type {?} */ res = (s._segmentIndexShift ? s._segmentIndexShift : 0);\n    while (s._sourceSegment) {\n        s = s._sourceSegment;\n        res += (s._segmentIndexShift ? s._segmentIndexShift : 0);\n    }\n    return res - 1;\n}\n/**\n * @param {?} segmentGroup\n * @param {?} consumedSegments\n * @param {?} slicedSegments\n * @param {?} config\n * @return {?}\n */\nfunction split$1(segmentGroup, consumedSegments, slicedSegments, config) {\n    if (slicedSegments.length > 0 &&\n        containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, config)) {\n        var /** @type {?} */ s_1 = new UrlSegmentGroup(consumedSegments, createChildrenForEmptyPaths(segmentGroup, consumedSegments, config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));\n        s_1._sourceSegment = segmentGroup;\n        s_1._segmentIndexShift = consumedSegments.length;\n        return { segmentGroup: s_1, slicedSegments: [] };\n    }\n    if (slicedSegments.length === 0 &&\n        containsEmptyPathMatches(segmentGroup, slicedSegments, config)) {\n        var /** @type {?} */ s_2 = new UrlSegmentGroup(segmentGroup.segments, addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, config, segmentGroup.children));\n        s_2._sourceSegment = segmentGroup;\n        s_2._segmentIndexShift = consumedSegments.length;\n        return { segmentGroup: s_2, slicedSegments: slicedSegments };\n    }\n    var /** @type {?} */ s = new UrlSegmentGroup(segmentGroup.segments, segmentGroup.children);\n    s._sourceSegment = segmentGroup;\n    s._segmentIndexShift = consumedSegments.length;\n    return { segmentGroup: s, slicedSegments: slicedSegments };\n}\n/**\n * @param {?} segmentGroup\n * @param {?} slicedSegments\n * @param {?} routes\n * @param {?} children\n * @return {?}\n */\nfunction addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, routes, children) {\n    var /** @type {?} */ res = {};\n    for (var _i = 0, routes_1 = routes; _i < routes_1.length; _i++) {\n        var r = routes_1[_i];\n        if (emptyPathMatch(segmentGroup, slicedSegments, r) && !children[getOutlet$1(r)]) {\n            var /** @type {?} */ s = new UrlSegmentGroup([], {});\n            s._sourceSegment = segmentGroup;\n            s._segmentIndexShift = segmentGroup.segments.length;\n            res[getOutlet$1(r)] = s;\n        }\n    }\n    return __assign({}, children, res);\n}\n/**\n * @param {?} segmentGroup\n * @param {?} consumedSegments\n * @param {?} routes\n * @param {?} primarySegment\n * @return {?}\n */\nfunction createChildrenForEmptyPaths(segmentGroup, consumedSegments, routes, primarySegment) {\n    var /** @type {?} */ res = {};\n    res[PRIMARY_OUTLET] = primarySegment;\n    primarySegment._sourceSegment = segmentGroup;\n    primarySegment._segmentIndexShift = consumedSegments.length;\n    for (var _i = 0, routes_2 = routes; _i < routes_2.length; _i++) {\n        var r = routes_2[_i];\n        if (r.path === '' && getOutlet$1(r) !== PRIMARY_OUTLET) {\n            var /** @type {?} */ s = new UrlSegmentGroup([], {});\n            s._sourceSegment = segmentGroup;\n            s._segmentIndexShift = consumedSegments.length;\n            res[getOutlet$1(r)] = s;\n        }\n    }\n    return res;\n}\n/**\n * @param {?} segmentGroup\n * @param {?} slicedSegments\n * @param {?} routes\n * @return {?}\n */\nfunction containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, routes) {\n    return routes.some(function (r) { return emptyPathMatch(segmentGroup, slicedSegments, r) && getOutlet$1(r) !== PRIMARY_OUTLET; });\n}\n/**\n * @param {?} segmentGroup\n * @param {?} slicedSegments\n * @param {?} routes\n * @return {?}\n */\nfunction containsEmptyPathMatches(segmentGroup, slicedSegments, routes) {\n    return routes.some(function (r) { return emptyPathMatch(segmentGroup, slicedSegments, r); });\n}\n/**\n * @param {?} segmentGroup\n * @param {?} slicedSegments\n * @param {?} r\n * @return {?}\n */\nfunction emptyPathMatch(segmentGroup, slicedSegments, r) {\n    if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r.pathMatch === 'full') {\n        return false;\n    }\n    return r.path === '' && r.redirectTo === undefined;\n}\n/**\n * @param {?} route\n * @return {?}\n */\nfunction getOutlet$1(route) {\n    return route.outlet || PRIMARY_OUTLET;\n}\n/**\n * @param {?} route\n * @return {?}\n */\nfunction getData(route) {\n    return route.data || {};\n}\n/**\n * @param {?} route\n * @return {?}\n */\nfunction getResolve(route) {\n    return route.resolve || {};\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * \\@whatItDoes Provides a way to customize when activated routes get reused.\n *\n * \\@experimental\n * @abstract\n */\nvar RouteReuseStrategy = (function () {\n    function RouteReuseStrategy() {\n    }\n    return RouteReuseStrategy;\n}());\n/**\n * Does not detach any subtrees. Reuses routes as long as their route config is the same.\n */\nvar DefaultRouteReuseStrategy = (function () {\n    function DefaultRouteReuseStrategy() {\n    }\n    /**\n     * @param {?} route\n     * @return {?}\n     */\n    DefaultRouteReuseStrategy.prototype.shouldDetach = /**\n     * @param {?} route\n     * @return {?}\n     */\n    function (route) { return false; };\n    /**\n     * @param {?} route\n     * @param {?} detachedTree\n     * @return {?}\n     */\n    DefaultRouteReuseStrategy.prototype.store = /**\n     * @param {?} route\n     * @param {?} detachedTree\n     * @return {?}\n     */\n    function (route, detachedTree) { };\n    /**\n     * @param {?} route\n     * @return {?}\n     */\n    DefaultRouteReuseStrategy.prototype.shouldAttach = /**\n     * @param {?} route\n     * @return {?}\n     */\n    function (route) { return false; };\n    /**\n     * @param {?} route\n     * @return {?}\n     */\n    DefaultRouteReuseStrategy.prototype.retrieve = /**\n     * @param {?} route\n     * @return {?}\n     */\n    function (route) { return null; };\n    /**\n     * @param {?} future\n     * @param {?} curr\n     * @return {?}\n     */\n    DefaultRouteReuseStrategy.prototype.shouldReuseRoute = /**\n     * @param {?} future\n     * @param {?} curr\n     * @return {?}\n     */\n    function (future, curr) {\n        return future.routeConfig === curr.routeConfig;\n    };\n    return DefaultRouteReuseStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * \\@docsNotRequired\n * \\@experimental\n */\nvar ROUTES = new InjectionToken('ROUTES');\nvar RouterConfigLoader = (function () {\n    function RouterConfigLoader(loader, compiler, onLoadStartListener, onLoadEndListener) {\n        this.loader = loader;\n        this.compiler = compiler;\n        this.onLoadStartListener = onLoadStartListener;\n        this.onLoadEndListener = onLoadEndListener;\n    }\n    /**\n     * @param {?} parentInjector\n     * @param {?} route\n     * @return {?}\n     */\n    RouterConfigLoader.prototype.load = /**\n     * @param {?} parentInjector\n     * @param {?} route\n     * @return {?}\n     */\n    function (parentInjector, route) {\n        var _this = this;\n        if (this.onLoadStartListener) {\n            this.onLoadStartListener(route);\n        }\n        var /** @type {?} */ moduleFactory$ = this.loadModuleFactory(/** @type {?} */ ((route.loadChildren)));\n        return map.call(moduleFactory$, function (factory) {\n            if (_this.onLoadEndListener) {\n                _this.onLoadEndListener(route);\n            }\n            var /** @type {?} */ module = factory.create(parentInjector);\n            return new LoadedRouterConfig(flatten(module.injector.get(ROUTES)), module);\n        });\n    };\n    /**\n     * @param {?} loadChildren\n     * @return {?}\n     */\n    RouterConfigLoader.prototype.loadModuleFactory = /**\n     * @param {?} loadChildren\n     * @return {?}\n     */\n    function (loadChildren) {\n        var _this = this;\n        if (typeof loadChildren === 'string') {\n            return fromPromise(this.loader.load(loadChildren));\n        }\n        else {\n            return mergeMap.call(wrapIntoObservable(loadChildren()), function (t) {\n                if (t instanceof NgModuleFactory) {\n                    return of(t);\n                }\n                else {\n                    return fromPromise(_this.compiler.compileModuleAsync(t));\n                }\n            });\n        }\n    };\n    return RouterConfigLoader;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * \\@whatItDoes Provides a way to migrate AngularJS applications to Angular.\n *\n * \\@experimental\n * @abstract\n */\nvar UrlHandlingStrategy = (function () {\n    function UrlHandlingStrategy() {\n    }\n    return UrlHandlingStrategy;\n}());\n/**\n * \\@experimental\n */\nvar DefaultUrlHandlingStrategy = (function () {\n    function DefaultUrlHandlingStrategy() {\n    }\n    /**\n     * @param {?} url\n     * @return {?}\n     */\n    DefaultUrlHandlingStrategy.prototype.shouldProcessUrl = /**\n     * @param {?} url\n     * @return {?}\n     */\n    function (url) { return true; };\n    /**\n     * @param {?} url\n     * @return {?}\n     */\n    DefaultUrlHandlingStrategy.prototype.extract = /**\n     * @param {?} url\n     * @return {?}\n     */\n    function (url) { return url; };\n    /**\n     * @param {?} newUrlPart\n     * @param {?} wholeUrl\n     * @return {?}\n     */\n    DefaultUrlHandlingStrategy.prototype.merge = /**\n     * @param {?} newUrlPart\n     * @param {?} wholeUrl\n     * @return {?}\n     */\n    function (newUrlPart, wholeUrl) { return newUrlPart; };\n    return DefaultUrlHandlingStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * \\@whatItDoes Represents the extra options used during navigation.\n *\n * \\@stable\n * @record\n */\n\n/**\n * @param {?} error\n * @return {?}\n */\nfunction defaultErrorHandler(error) {\n    throw error;\n}\n/**\n * \\@internal\n * @param {?} snapshot\n * @return {?}\n */\nfunction defaultRouterHook(snapshot) {\n    return /** @type {?} */ (of(null));\n}\n/**\n * \\@whatItDoes Provides the navigation and url manipulation capabilities.\n *\n * See {\\@link Routes} for more details and examples.\n *\n * \\@ngModule RouterModule\n *\n * \\@stable\n */\nvar Router = (function () {\n    /**\n     * Creates the router service.\n     */\n    // TODO: vsavkin make internal after the final is out.\n    function Router(rootComponentType, urlSerializer, rootContexts, location, injector, loader, compiler, config) {\n        var _this = this;\n        this.rootComponentType = rootComponentType;\n        this.urlSerializer = urlSerializer;\n        this.rootContexts = rootContexts;\n        this.location = location;\n        this.config = config;\n        this.navigations = new BehaviorSubject(/** @type {?} */ ((null)));\n        this.navigationId = 0;\n        this.events = new Subject();\n        /**\n         * Error handler that is invoked when a navigation errors.\n         *\n         * See {\\@link ErrorHandler} for more information.\n         */\n        this.errorHandler = defaultErrorHandler;\n        /**\n         * Indicates if at least one navigation happened.\n         */\n        this.navigated = false;\n        /**\n         * Used by RouterModule. This allows us to\n         * pause the navigation either before preactivation or after it.\n         * \\@internal\n         */\n        this.hooks = {\n            beforePreactivation: defaultRouterHook,\n            afterPreactivation: defaultRouterHook\n        };\n        /**\n         * Extracts and merges URLs. Used for AngularJS to Angular migrations.\n         */\n        this.urlHandlingStrategy = new DefaultUrlHandlingStrategy();\n        this.routeReuseStrategy = new DefaultRouteReuseStrategy();\n        var /** @type {?} */ onLoadStart = function (r) { return _this.triggerEvent(new RouteConfigLoadStart(r)); };\n        var /** @type {?} */ onLoadEnd = function (r) { return _this.triggerEvent(new RouteConfigLoadEnd(r)); };\n        this.ngModule = injector.get(NgModuleRef);\n        this.resetConfig(config);\n        this.currentUrlTree = createEmptyUrlTree();\n        this.rawUrlTree = this.currentUrlTree;\n        this.configLoader = new RouterConfigLoader(loader, compiler, onLoadStart, onLoadEnd);\n        this.routerState = createEmptyState(this.currentUrlTree, this.rootComponentType);\n        this.processNavigations();\n    }\n    /**\n     * @internal\n     * TODO: this should be removed once the constructor of the router made internal\n     */\n    /**\n     * \\@internal\n     * TODO: this should be removed once the constructor of the router made internal\n     * @param {?} rootComponentType\n     * @return {?}\n     */\n    Router.prototype.resetRootComponentType = /**\n     * \\@internal\n     * TODO: this should be removed once the constructor of the router made internal\n     * @param {?} rootComponentType\n     * @return {?}\n     */\n    function (rootComponentType) {\n        this.rootComponentType = rootComponentType;\n        // TODO: vsavkin router 4.0 should make the root component set to null\n        // this will simplify the lifecycle of the router.\n        this.routerState.root.component = this.rootComponentType;\n    };\n    /**\n     * Sets up the location change listener and performs the initial navigation.\n     */\n    /**\n     * Sets up the location change listener and performs the initial navigation.\n     * @return {?}\n     */\n    Router.prototype.initialNavigation = /**\n     * Sets up the location change listener and performs the initial navigation.\n     * @return {?}\n     */\n    function () {\n        this.setUpLocationChangeListener();\n        if (this.navigationId === 0) {\n            this.navigateByUrl(this.location.path(true), { replaceUrl: true });\n        }\n    };\n    /**\n     * Sets up the location change listener.\n     */\n    /**\n     * Sets up the location change listener.\n     * @return {?}\n     */\n    Router.prototype.setUpLocationChangeListener = /**\n     * Sets up the location change listener.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        // Zone.current.wrap is needed because of the issue with RxJS scheduler,\n        // which does not work properly with zone.js in IE and Safari\n        if (!this.locationSubscription) {\n            this.locationSubscription = /** @type {?} */ (this.location.subscribe(Zone.current.wrap(function (change) {\n                var /** @type {?} */ rawUrlTree = _this.urlSerializer.parse(change['url']);\n                var /** @type {?} */ source = change['type'] === 'popstate' ? 'popstate' : 'hashchange';\n                setTimeout(function () { _this.scheduleNavigation(rawUrlTree, source, { replaceUrl: true }); }, 0);\n            })));\n        }\n    };\n    Object.defineProperty(Router.prototype, \"url\", {\n        /** The current url */\n        get: /**\n         * The current url\n         * @return {?}\n         */\n        function () { return this.serializeUrl(this.currentUrlTree); },\n        enumerable: true,\n        configurable: true\n    });\n    /** @internal */\n    /**\n     * \\@internal\n     * @param {?} e\n     * @return {?}\n     */\n    Router.prototype.triggerEvent = /**\n     * \\@internal\n     * @param {?} e\n     * @return {?}\n     */\n    function (e) { (/** @type {?} */ (this.events)).next(e); };\n    /**\n     * Resets the configuration used for navigation and generating links.\n     *\n     * ### Usage\n     *\n     * ```\n     * router.resetConfig([\n     *  { path: 'team/:id', component: TeamCmp, children: [\n     *    { path: 'simple', component: SimpleCmp },\n     *    { path: 'user/:name', component: UserCmp }\n     *  ]}\n     * ]);\n     * ```\n     */\n    /**\n     * Resets the configuration used for navigation and generating links.\n     *\n     * ### Usage\n     *\n     * ```\n     * router.resetConfig([\n     *  { path: 'team/:id', component: TeamCmp, children: [\n     *    { path: 'simple', component: SimpleCmp },\n     *    { path: 'user/:name', component: UserCmp }\n     *  ]}\n     * ]);\n     * ```\n     * @param {?} config\n     * @return {?}\n     */\n    Router.prototype.resetConfig = /**\n     * Resets the configuration used for navigation and generating links.\n     *\n     * ### Usage\n     *\n     * ```\n     * router.resetConfig([\n     *  { path: 'team/:id', component: TeamCmp, children: [\n     *    { path: 'simple', component: SimpleCmp },\n     *    { path: 'user/:name', component: UserCmp }\n     *  ]}\n     * ]);\n     * ```\n     * @param {?} config\n     * @return {?}\n     */\n    function (config) {\n        validateConfig(config);\n        this.config = config;\n        this.navigated = false;\n    };\n    /** @docsNotRequired */\n    /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    Router.prototype.ngOnDestroy = /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    function () { this.dispose(); };\n    /** Disposes of the router */\n    /**\n     * Disposes of the router\n     * @return {?}\n     */\n    Router.prototype.dispose = /**\n     * Disposes of the router\n     * @return {?}\n     */\n    function () {\n        if (this.locationSubscription) {\n            this.locationSubscription.unsubscribe();\n            this.locationSubscription = /** @type {?} */ ((null));\n        }\n    };\n    /**\n     * Applies an array of commands to the current url tree and creates a new url tree.\n     *\n     * When given an activate route, applies the given commands starting from the route.\n     * When not given a route, applies the given command starting from the root.\n     *\n     * ### Usage\n     *\n     * ```\n     * // create /team/33/user/11\n     * router.createUrlTree(['/team', 33, 'user', 11]);\n     *\n     * // create /team/33;expand=true/user/11\n     * router.createUrlTree(['/team', 33, {expand: true}, 'user', 11]);\n     *\n     * // you can collapse static segments like this (this works only with the first passed-in value):\n     * router.createUrlTree(['/team/33/user', userId]);\n     *\n     * // If the first segment can contain slashes, and you do not want the router to split it, you\n     * // can do the following:\n     *\n     * router.createUrlTree([{segmentPath: '/one/two'}]);\n     *\n     * // create /team/33/(user/11//right:chat)\n     * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: 'chat'}}]);\n     *\n     * // remove the right secondary node\n     * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: null}}]);\n     *\n     * // assuming the current url is `/team/33/user/11` and the route points to `user/11`\n     *\n     * // navigate to /team/33/user/11/details\n     * router.createUrlTree(['details'], {relativeTo: route});\n     *\n     * // navigate to /team/33/user/22\n     * router.createUrlTree(['../22'], {relativeTo: route});\n     *\n     * // navigate to /team/44/user/22\n     * router.createUrlTree(['../../team/44/user/22'], {relativeTo: route});\n     * ```\n     */\n    /**\n     * Applies an array of commands to the current url tree and creates a new url tree.\n     *\n     * When given an activate route, applies the given commands starting from the route.\n     * When not given a route, applies the given command starting from the root.\n     *\n     * ### Usage\n     *\n     * ```\n     * // create /team/33/user/11\n     * router.createUrlTree(['/team', 33, 'user', 11]);\n     *\n     * // create /team/33;expand=true/user/11\n     * router.createUrlTree(['/team', 33, {expand: true}, 'user', 11]);\n     *\n     * // you can collapse static segments like this (this works only with the first passed-in value):\n     * router.createUrlTree(['/team/33/user', userId]);\n     *\n     * // If the first segment can contain slashes, and you do not want the router to split it, you\n     * // can do the following:\n     *\n     * router.createUrlTree([{segmentPath: '/one/two'}]);\n     *\n     * // create /team/33/(user/11//right:chat)\n     * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: 'chat'}}]);\n     *\n     * // remove the right secondary node\n     * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: null}}]);\n     *\n     * // assuming the current url is `/team/33/user/11` and the route points to `user/11`\n     *\n     * // navigate to /team/33/user/11/details\n     * router.createUrlTree(['details'], {relativeTo: route});\n     *\n     * // navigate to /team/33/user/22\n     * router.createUrlTree(['../22'], {relativeTo: route});\n     *\n     * // navigate to /team/44/user/22\n     * router.createUrlTree(['../../team/44/user/22'], {relativeTo: route});\n     * ```\n     * @param {?} commands\n     * @param {?=} navigationExtras\n     * @return {?}\n     */\n    Router.prototype.createUrlTree = /**\n     * Applies an array of commands to the current url tree and creates a new url tree.\n     *\n     * When given an activate route, applies the given commands starting from the route.\n     * When not given a route, applies the given command starting from the root.\n     *\n     * ### Usage\n     *\n     * ```\n     * // create /team/33/user/11\n     * router.createUrlTree(['/team', 33, 'user', 11]);\n     *\n     * // create /team/33;expand=true/user/11\n     * router.createUrlTree(['/team', 33, {expand: true}, 'user', 11]);\n     *\n     * // you can collapse static segments like this (this works only with the first passed-in value):\n     * router.createUrlTree(['/team/33/user', userId]);\n     *\n     * // If the first segment can contain slashes, and you do not want the router to split it, you\n     * // can do the following:\n     *\n     * router.createUrlTree([{segmentPath: '/one/two'}]);\n     *\n     * // create /team/33/(user/11//right:chat)\n     * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: 'chat'}}]);\n     *\n     * // remove the right secondary node\n     * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: null}}]);\n     *\n     * // assuming the current url is `/team/33/user/11` and the route points to `user/11`\n     *\n     * // navigate to /team/33/user/11/details\n     * router.createUrlTree(['details'], {relativeTo: route});\n     *\n     * // navigate to /team/33/user/22\n     * router.createUrlTree(['../22'], {relativeTo: route});\n     *\n     * // navigate to /team/44/user/22\n     * router.createUrlTree(['../../team/44/user/22'], {relativeTo: route});\n     * ```\n     * @param {?} commands\n     * @param {?=} navigationExtras\n     * @return {?}\n     */\n    function (commands, navigationExtras) {\n        if (navigationExtras === void 0) { navigationExtras = {}; }\n        var relativeTo = navigationExtras.relativeTo, queryParams = navigationExtras.queryParams, fragment = navigationExtras.fragment, preserveQueryParams = navigationExtras.preserveQueryParams, queryParamsHandling = navigationExtras.queryParamsHandling, preserveFragment = navigationExtras.preserveFragment;\n        if (isDevMode() && preserveQueryParams && /** @type {?} */ (console) && /** @type {?} */ (console.warn)) {\n            console.warn('preserveQueryParams is deprecated, use queryParamsHandling instead.');\n        }\n        var /** @type {?} */ a = relativeTo || this.routerState.root;\n        var /** @type {?} */ f = preserveFragment ? this.currentUrlTree.fragment : fragment;\n        var /** @type {?} */ q = null;\n        if (queryParamsHandling) {\n            switch (queryParamsHandling) {\n                case 'merge':\n                    q = __assign({}, this.currentUrlTree.queryParams, queryParams);\n                    break;\n                case 'preserve':\n                    q = this.currentUrlTree.queryParams;\n                    break;\n                default:\n                    q = queryParams || null;\n            }\n        }\n        else {\n            q = preserveQueryParams ? this.currentUrlTree.queryParams : queryParams || null;\n        }\n        return createUrlTree(a, this.currentUrlTree, commands, /** @type {?} */ ((q)), /** @type {?} */ ((f)));\n    };\n    /**\n     * Navigate based on the provided url. This navigation is always absolute.\n     *\n     * Returns a promise that:\n     * - resolves to 'true' when navigation succeeds,\n     * - resolves to 'false' when navigation fails,\n     * - is rejected when an error happens.\n     *\n     * ### Usage\n     *\n     * ```\n     * router.navigateByUrl(\"/team/33/user/11\");\n     *\n     * // Navigate without updating the URL\n     * router.navigateByUrl(\"/team/33/user/11\", { skipLocationChange: true });\n     * ```\n     *\n     * In opposite to `navigate`, `navigateByUrl` takes a whole URL\n     * and does not apply any delta to the current one.\n     */\n    /**\n     * Navigate based on the provided url. This navigation is always absolute.\n     *\n     * Returns a promise that:\n     * - resolves to 'true' when navigation succeeds,\n     * - resolves to 'false' when navigation fails,\n     * - is rejected when an error happens.\n     *\n     * ### Usage\n     *\n     * ```\n     * router.navigateByUrl(\"/team/33/user/11\");\n     *\n     * // Navigate without updating the URL\n     * router.navigateByUrl(\"/team/33/user/11\", { skipLocationChange: true });\n     * ```\n     *\n     * In opposite to `navigate`, `navigateByUrl` takes a whole URL\n     * and does not apply any delta to the current one.\n     * @param {?} url\n     * @param {?=} extras\n     * @return {?}\n     */\n    Router.prototype.navigateByUrl = /**\n     * Navigate based on the provided url. This navigation is always absolute.\n     *\n     * Returns a promise that:\n     * - resolves to 'true' when navigation succeeds,\n     * - resolves to 'false' when navigation fails,\n     * - is rejected when an error happens.\n     *\n     * ### Usage\n     *\n     * ```\n     * router.navigateByUrl(\"/team/33/user/11\");\n     *\n     * // Navigate without updating the URL\n     * router.navigateByUrl(\"/team/33/user/11\", { skipLocationChange: true });\n     * ```\n     *\n     * In opposite to `navigate`, `navigateByUrl` takes a whole URL\n     * and does not apply any delta to the current one.\n     * @param {?} url\n     * @param {?=} extras\n     * @return {?}\n     */\n    function (url, extras) {\n        if (extras === void 0) { extras = { skipLocationChange: false }; }\n        var /** @type {?} */ urlTree = url instanceof UrlTree ? url : this.parseUrl(url);\n        var /** @type {?} */ mergedTree = this.urlHandlingStrategy.merge(urlTree, this.rawUrlTree);\n        return this.scheduleNavigation(mergedTree, 'imperative', extras);\n    };\n    /**\n     * Navigate based on the provided array of commands and a starting point.\n     * If no starting route is provided, the navigation is absolute.\n     *\n     * Returns a promise that:\n     * - resolves to 'true' when navigation succeeds,\n     * - resolves to 'false' when navigation fails,\n     * - is rejected when an error happens.\n     *\n     * ### Usage\n     *\n     * ```\n     * router.navigate(['team', 33, 'user', 11], {relativeTo: route});\n     *\n     * // Navigate without updating the URL\n     * router.navigate(['team', 33, 'user', 11], {relativeTo: route, skipLocationChange: true});\n     * ```\n     *\n     * In opposite to `navigateByUrl`, `navigate` always takes a delta that is applied to the current\n     * URL.\n     */\n    /**\n     * Navigate based on the provided array of commands and a starting point.\n     * If no starting route is provided, the navigation is absolute.\n     *\n     * Returns a promise that:\n     * - resolves to 'true' when navigation succeeds,\n     * - resolves to 'false' when navigation fails,\n     * - is rejected when an error happens.\n     *\n     * ### Usage\n     *\n     * ```\n     * router.navigate(['team', 33, 'user', 11], {relativeTo: route});\n     *\n     * // Navigate without updating the URL\n     * router.navigate(['team', 33, 'user', 11], {relativeTo: route, skipLocationChange: true});\n     * ```\n     *\n     * In opposite to `navigateByUrl`, `navigate` always takes a delta that is applied to the current\n     * URL.\n     * @param {?} commands\n     * @param {?=} extras\n     * @return {?}\n     */\n    Router.prototype.navigate = /**\n     * Navigate based on the provided array of commands and a starting point.\n     * If no starting route is provided, the navigation is absolute.\n     *\n     * Returns a promise that:\n     * - resolves to 'true' when navigation succeeds,\n     * - resolves to 'false' when navigation fails,\n     * - is rejected when an error happens.\n     *\n     * ### Usage\n     *\n     * ```\n     * router.navigate(['team', 33, 'user', 11], {relativeTo: route});\n     *\n     * // Navigate without updating the URL\n     * router.navigate(['team', 33, 'user', 11], {relativeTo: route, skipLocationChange: true});\n     * ```\n     *\n     * In opposite to `navigateByUrl`, `navigate` always takes a delta that is applied to the current\n     * URL.\n     * @param {?} commands\n     * @param {?=} extras\n     * @return {?}\n     */\n    function (commands, extras) {\n        if (extras === void 0) { extras = { skipLocationChange: false }; }\n        validateCommands(commands);\n        if (typeof extras.queryParams === 'object' && extras.queryParams !== null) {\n            extras.queryParams = this.removeEmptyProps(extras.queryParams);\n        }\n        return this.navigateByUrl(this.createUrlTree(commands, extras), extras);\n    };\n    /** Serializes a {@link UrlTree} into a string */\n    /**\n     * Serializes a {\\@link UrlTree} into a string\n     * @param {?} url\n     * @return {?}\n     */\n    Router.prototype.serializeUrl = /**\n     * Serializes a {\\@link UrlTree} into a string\n     * @param {?} url\n     * @return {?}\n     */\n    function (url) { return this.urlSerializer.serialize(url); };\n    /** Parses a string into a {@link UrlTree} */\n    /**\n     * Parses a string into a {\\@link UrlTree}\n     * @param {?} url\n     * @return {?}\n     */\n    Router.prototype.parseUrl = /**\n     * Parses a string into a {\\@link UrlTree}\n     * @param {?} url\n     * @return {?}\n     */\n    function (url) { return this.urlSerializer.parse(url); };\n    /** Returns whether the url is activated */\n    /**\n     * Returns whether the url is activated\n     * @param {?} url\n     * @param {?} exact\n     * @return {?}\n     */\n    Router.prototype.isActive = /**\n     * Returns whether the url is activated\n     * @param {?} url\n     * @param {?} exact\n     * @return {?}\n     */\n    function (url, exact) {\n        if (url instanceof UrlTree) {\n            return containsTree(this.currentUrlTree, url, exact);\n        }\n        var /** @type {?} */ urlTree = this.urlSerializer.parse(url);\n        return containsTree(this.currentUrlTree, urlTree, exact);\n    };\n    /**\n     * @param {?} params\n     * @return {?}\n     */\n    Router.prototype.removeEmptyProps = /**\n     * @param {?} params\n     * @return {?}\n     */\n    function (params) {\n        return Object.keys(params).reduce(function (result, key) {\n            var /** @type {?} */ value = params[key];\n            if (value !== null && value !== undefined) {\n                result[key] = value;\n            }\n            return result;\n        }, {});\n    };\n    /**\n     * @return {?}\n     */\n    Router.prototype.processNavigations = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        concatMap\n            .call(this.navigations, function (nav) {\n            if (nav) {\n                _this.executeScheduledNavigation(nav);\n                // a failed navigation should not stop the router from processing\n                // further navigations => the catch\n                return nav.promise.catch(function () { });\n            }\n            else {\n                return /** @type {?} */ (of(null));\n            }\n        })\n            .subscribe(function () { });\n    };\n    /**\n     * @param {?} rawUrl\n     * @param {?} source\n     * @param {?} extras\n     * @return {?}\n     */\n    Router.prototype.scheduleNavigation = /**\n     * @param {?} rawUrl\n     * @param {?} source\n     * @param {?} extras\n     * @return {?}\n     */\n    function (rawUrl, source, extras) {\n        var /** @type {?} */ lastNavigation = this.navigations.value;\n        // If the user triggers a navigation imperatively (e.g., by using navigateByUrl),\n        // and that navigation results in 'replaceState' that leads to the same URL,\n        // we should skip those.\n        if (lastNavigation && source !== 'imperative' && lastNavigation.source === 'imperative' &&\n            lastNavigation.rawUrl.toString() === rawUrl.toString()) {\n            return Promise.resolve(true); // return value is not used\n        }\n        // Because of a bug in IE and Edge, the location class fires two events (popstate and\n        // hashchange) every single time. The second one should be ignored. Otherwise, the URL will\n        // flicker.\n        if (lastNavigation && source == 'hashchange' && lastNavigation.source === 'popstate' &&\n            lastNavigation.rawUrl.toString() === rawUrl.toString()) {\n            return Promise.resolve(true); // return value is not used\n        }\n        var /** @type {?} */ resolve = null;\n        var /** @type {?} */ reject = null;\n        var /** @type {?} */ promise = new Promise(function (res, rej) {\n            resolve = res;\n            reject = rej;\n        });\n        var /** @type {?} */ id = ++this.navigationId;\n        this.navigations.next({ id: id, source: source, rawUrl: rawUrl, extras: extras, resolve: resolve, reject: reject, promise: promise });\n        // Make sure that the error is propagated even though `processNavigations` catch\n        // handler does not rethrow\n        return promise.catch(function (e) { return Promise.reject(e); });\n    };\n    /**\n     * @param {?} __0\n     * @return {?}\n     */\n    Router.prototype.executeScheduledNavigation = /**\n     * @param {?} __0\n     * @return {?}\n     */\n    function (_a) {\n        var _this = this;\n        var id = _a.id, rawUrl = _a.rawUrl, extras = _a.extras, resolve = _a.resolve, reject = _a.reject;\n        var /** @type {?} */ url = this.urlHandlingStrategy.extract(rawUrl);\n        var /** @type {?} */ urlTransition = !this.navigated || url.toString() !== this.currentUrlTree.toString();\n        if (urlTransition && this.urlHandlingStrategy.shouldProcessUrl(rawUrl)) {\n            (/** @type {?} */ (this.events)).next(new NavigationStart(id, this.serializeUrl(url)));\n            Promise.resolve()\n                .then(function (_) {\n                return _this.runNavigate(url, rawUrl, !!extras.skipLocationChange, !!extras.replaceUrl, id, null);\n            })\n                .then(resolve, reject);\n            // we cannot process the current URL, but we could process the previous one =>\n            // we need to do some cleanup\n        }\n        else if (urlTransition && this.rawUrlTree &&\n            this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)) {\n            (/** @type {?} */ (this.events)).next(new NavigationStart(id, this.serializeUrl(url)));\n            Promise.resolve()\n                .then(function (_) {\n                return _this.runNavigate(url, rawUrl, false, false, id, createEmptyState(url, _this.rootComponentType).snapshot);\n            })\n                .then(resolve, reject);\n        }\n        else {\n            this.rawUrlTree = rawUrl;\n            resolve(null);\n        }\n    };\n    /**\n     * @param {?} url\n     * @param {?} rawUrl\n     * @param {?} shouldPreventPushState\n     * @param {?} shouldReplaceUrl\n     * @param {?} id\n     * @param {?} precreatedState\n     * @return {?}\n     */\n    Router.prototype.runNavigate = /**\n     * @param {?} url\n     * @param {?} rawUrl\n     * @param {?} shouldPreventPushState\n     * @param {?} shouldReplaceUrl\n     * @param {?} id\n     * @param {?} precreatedState\n     * @return {?}\n     */\n    function (url, rawUrl, shouldPreventPushState, shouldReplaceUrl, id, precreatedState) {\n        var _this = this;\n        if (id !== this.navigationId) {\n            this.location.go(this.urlSerializer.serialize(this.currentUrlTree));\n            (/** @type {?} */ (this.events))\n                .next(new NavigationCancel(id, this.serializeUrl(url), \"Navigation ID \" + id + \" is not equal to the current navigation id \" + this.navigationId));\n            return Promise.resolve(false);\n        }\n        return new Promise(function (resolvePromise, rejectPromise) {\n            // create an observable of the url and route state snapshot\n            // this operation do not result in any side effects\n            var /** @type {?} */ urlAndSnapshot$;\n            if (!precreatedState) {\n                var /** @type {?} */ moduleInjector = _this.ngModule.injector;\n                var /** @type {?} */ redirectsApplied$ = applyRedirects(moduleInjector, _this.configLoader, _this.urlSerializer, url, _this.config);\n                urlAndSnapshot$ = mergeMap.call(redirectsApplied$, function (appliedUrl) {\n                    return map.call(recognize(_this.rootComponentType, _this.config, appliedUrl, _this.serializeUrl(appliedUrl)), function (snapshot) {\n                        (/** @type {?} */ (_this.events))\n                            .next(new RoutesRecognized(id, _this.serializeUrl(url), _this.serializeUrl(appliedUrl), snapshot));\n                        return { appliedUrl: appliedUrl, snapshot: snapshot };\n                    });\n                });\n            }\n            else {\n                urlAndSnapshot$ = of({ appliedUrl: url, snapshot: precreatedState });\n            }\n            var /** @type {?} */ beforePreactivationDone$ = mergeMap.call(urlAndSnapshot$, function (p) {\n                return map.call(_this.hooks.beforePreactivation(p.snapshot), function () { return p; });\n            });\n            // run preactivation: guards and data resolvers\n            var /** @type {?} */ preActivation;\n            var /** @type {?} */ preactivationSetup$ = map.call(beforePreactivationDone$, function (_a) {\n                var appliedUrl = _a.appliedUrl, snapshot = _a.snapshot;\n                var /** @type {?} */ moduleInjector = _this.ngModule.injector;\n                preActivation = new PreActivation(snapshot, _this.routerState.snapshot, moduleInjector, function (evt) { return _this.triggerEvent(evt); });\n                preActivation.initialize(_this.rootContexts);\n                return { appliedUrl: appliedUrl, snapshot: snapshot };\n            });\n            var /** @type {?} */ preactivationCheckGuards$ = mergeMap.call(preactivationSetup$, function (_a) {\n                var appliedUrl = _a.appliedUrl, snapshot = _a.snapshot;\n                if (_this.navigationId !== id)\n                    return of(false);\n                _this.triggerEvent(new GuardsCheckStart(id, _this.serializeUrl(url), appliedUrl, snapshot));\n                return map.call(preActivation.checkGuards(), function (shouldActivate) {\n                    _this.triggerEvent(new GuardsCheckEnd(id, _this.serializeUrl(url), appliedUrl, snapshot, shouldActivate));\n                    return { appliedUrl: appliedUrl, snapshot: snapshot, shouldActivate: shouldActivate };\n                });\n            });\n            var /** @type {?} */ preactivationResolveData$ = mergeMap.call(preactivationCheckGuards$, function (p) {\n                if (_this.navigationId !== id)\n                    return of(false);\n                if (p.shouldActivate && preActivation.isActivating()) {\n                    _this.triggerEvent(new ResolveStart(id, _this.serializeUrl(url), p.appliedUrl, p.snapshot));\n                    return map.call(preActivation.resolveData(), function () {\n                        _this.triggerEvent(new ResolveEnd(id, _this.serializeUrl(url), p.appliedUrl, p.snapshot));\n                        return p;\n                    });\n                }\n                else {\n                    return of(p);\n                }\n            });\n            var /** @type {?} */ preactivationDone$ = mergeMap.call(preactivationResolveData$, function (p) {\n                return map.call(_this.hooks.afterPreactivation(p.snapshot), function () { return p; });\n            });\n            // create router state\n            // this operation has side effects => route state is being affected\n            var /** @type {?} */ routerState$ = map.call(preactivationDone$, function (_a) {\n                var appliedUrl = _a.appliedUrl, snapshot = _a.snapshot, shouldActivate = _a.shouldActivate;\n                if (shouldActivate) {\n                    var /** @type {?} */ state = createRouterState(_this.routeReuseStrategy, snapshot, _this.routerState);\n                    return { appliedUrl: appliedUrl, state: state, shouldActivate: shouldActivate };\n                }\n                else {\n                    return { appliedUrl: appliedUrl, state: null, shouldActivate: shouldActivate };\n                }\n            });\n            // applied the new router state\n            // this operation has side effects\n            var /** @type {?} */ navigationIsSuccessful;\n            var /** @type {?} */ storedState = _this.routerState;\n            var /** @type {?} */ storedUrl = _this.currentUrlTree;\n            routerState$\n                .forEach(function (_a) {\n                var appliedUrl = _a.appliedUrl, state = _a.state, shouldActivate = _a.shouldActivate;\n                if (!shouldActivate || id !== _this.navigationId) {\n                    navigationIsSuccessful = false;\n                    return;\n                }\n                _this.currentUrlTree = appliedUrl;\n                _this.rawUrlTree = _this.urlHandlingStrategy.merge(_this.currentUrlTree, rawUrl);\n                (/** @type {?} */ (_this)).routerState = state;\n                if (!shouldPreventPushState) {\n                    var /** @type {?} */ path = _this.urlSerializer.serialize(_this.rawUrlTree);\n                    if (_this.location.isCurrentPathEqualTo(path) || shouldReplaceUrl) {\n                        _this.location.replaceState(path);\n                    }\n                    else {\n                        _this.location.go(path);\n                    }\n                }\n                new ActivateRoutes(_this.routeReuseStrategy, state, storedState, function (evt) { return _this.triggerEvent(evt); })\n                    .activate(_this.rootContexts);\n                navigationIsSuccessful = true;\n            })\n                .then(function () {\n                if (navigationIsSuccessful) {\n                    _this.navigated = true;\n                    (/** @type {?} */ (_this.events))\n                        .next(new NavigationEnd(id, _this.serializeUrl(url), _this.serializeUrl(_this.currentUrlTree)));\n                    resolvePromise(true);\n                }\n                else {\n                    _this.resetUrlToCurrentUrlTree();\n                    (/** @type {?} */ (_this.events))\n                        .next(new NavigationCancel(id, _this.serializeUrl(url), ''));\n                    resolvePromise(false);\n                }\n            }, function (e) {\n                if (isNavigationCancelingError(e)) {\n                    _this.resetUrlToCurrentUrlTree();\n                    _this.navigated = true;\n                    (/** @type {?} */ (_this.events))\n                        .next(new NavigationCancel(id, _this.serializeUrl(url), e.message));\n                    resolvePromise(false);\n                }\n                else {\n                    (/** @type {?} */ (_this.events))\n                        .next(new NavigationError(id, _this.serializeUrl(url), e));\n                    try {\n                        resolvePromise(_this.errorHandler(e));\n                    }\n                    catch (/** @type {?} */ ee) {\n                        rejectPromise(ee);\n                    }\n                }\n                (/** @type {?} */ (_this)).routerState = storedState;\n                _this.currentUrlTree = storedUrl;\n                _this.rawUrlTree = _this.urlHandlingStrategy.merge(_this.currentUrlTree, rawUrl);\n                _this.location.replaceState(_this.serializeUrl(_this.rawUrlTree));\n            });\n        });\n    };\n    /**\n     * @return {?}\n     */\n    Router.prototype.resetUrlToCurrentUrlTree = /**\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ path = this.urlSerializer.serialize(this.rawUrlTree);\n        this.location.replaceState(path);\n    };\n    return Router;\n}());\nvar ActivateRoutes = (function () {\n    function ActivateRoutes(routeReuseStrategy, futureState, currState, forwardEvent) {\n        this.routeReuseStrategy = routeReuseStrategy;\n        this.futureState = futureState;\n        this.currState = currState;\n        this.forwardEvent = forwardEvent;\n    }\n    /**\n     * @param {?} parentContexts\n     * @return {?}\n     */\n    ActivateRoutes.prototype.activate = /**\n     * @param {?} parentContexts\n     * @return {?}\n     */\n    function (parentContexts) {\n        var /** @type {?} */ futureRoot = this.futureState._root;\n        var /** @type {?} */ currRoot = this.currState ? this.currState._root : null;\n        this.deactivateChildRoutes(futureRoot, currRoot, parentContexts);\n        advanceActivatedRoute(this.futureState.root);\n        this.activateChildRoutes(futureRoot, currRoot, parentContexts);\n    };\n    /**\n     * @param {?} futureNode\n     * @param {?} currNode\n     * @param {?} contexts\n     * @return {?}\n     */\n    ActivateRoutes.prototype.deactivateChildRoutes = /**\n     * @param {?} futureNode\n     * @param {?} currNode\n     * @param {?} contexts\n     * @return {?}\n     */\n    function (futureNode, currNode, contexts) {\n        var _this = this;\n        var /** @type {?} */ children = nodeChildrenAsMap(currNode);\n        // Recurse on the routes active in the future state to de-activate deeper children\n        futureNode.children.forEach(function (futureChild) {\n            var /** @type {?} */ childOutletName = futureChild.value.outlet;\n            _this.deactivateRoutes(futureChild, children[childOutletName], contexts);\n            delete children[childOutletName];\n        });\n        // De-activate the routes that will not be re-used\n        forEach(children, function (v, childName) {\n            _this.deactivateRouteAndItsChildren(v, contexts);\n        });\n    };\n    /**\n     * @param {?} futureNode\n     * @param {?} currNode\n     * @param {?} parentContext\n     * @return {?}\n     */\n    ActivateRoutes.prototype.deactivateRoutes = /**\n     * @param {?} futureNode\n     * @param {?} currNode\n     * @param {?} parentContext\n     * @return {?}\n     */\n    function (futureNode, currNode, parentContext) {\n        var /** @type {?} */ future = futureNode.value;\n        var /** @type {?} */ curr = currNode ? currNode.value : null;\n        if (future === curr) {\n            // Reusing the node, check to see if the children need to be de-activated\n            if (future.component) {\n                // If we have a normal route, we need to go through an outlet.\n                var /** @type {?} */ context = parentContext.getContext(future.outlet);\n                if (context) {\n                    this.deactivateChildRoutes(futureNode, currNode, context.children);\n                }\n            }\n            else {\n                // if we have a componentless route, we recurse but keep the same outlet map.\n                this.deactivateChildRoutes(futureNode, currNode, parentContext);\n            }\n        }\n        else {\n            if (curr) {\n                // Deactivate the current route which will not be re-used\n                this.deactivateRouteAndItsChildren(currNode, parentContext);\n            }\n        }\n    };\n    /**\n     * @param {?} route\n     * @param {?} parentContexts\n     * @return {?}\n     */\n    ActivateRoutes.prototype.deactivateRouteAndItsChildren = /**\n     * @param {?} route\n     * @param {?} parentContexts\n     * @return {?}\n     */\n    function (route, parentContexts) {\n        if (this.routeReuseStrategy.shouldDetach(route.value.snapshot)) {\n            this.detachAndStoreRouteSubtree(route, parentContexts);\n        }\n        else {\n            this.deactivateRouteAndOutlet(route, parentContexts);\n        }\n    };\n    /**\n     * @param {?} route\n     * @param {?} parentContexts\n     * @return {?}\n     */\n    ActivateRoutes.prototype.detachAndStoreRouteSubtree = /**\n     * @param {?} route\n     * @param {?} parentContexts\n     * @return {?}\n     */\n    function (route, parentContexts) {\n        var /** @type {?} */ context = parentContexts.getContext(route.value.outlet);\n        if (context && context.outlet) {\n            var /** @type {?} */ componentRef = context.outlet.detach();\n            var /** @type {?} */ contexts = context.children.onOutletDeactivated();\n            this.routeReuseStrategy.store(route.value.snapshot, { componentRef: componentRef, route: route, contexts: contexts });\n        }\n    };\n    /**\n     * @param {?} route\n     * @param {?} parentContexts\n     * @return {?}\n     */\n    ActivateRoutes.prototype.deactivateRouteAndOutlet = /**\n     * @param {?} route\n     * @param {?} parentContexts\n     * @return {?}\n     */\n    function (route, parentContexts) {\n        var _this = this;\n        var /** @type {?} */ context = parentContexts.getContext(route.value.outlet);\n        if (context) {\n            var /** @type {?} */ children = nodeChildrenAsMap(route);\n            var /** @type {?} */ contexts_1 = route.value.component ? context.children : parentContexts;\n            forEach(children, function (v, k) { return _this.deactivateRouteAndItsChildren(v, contexts_1); });\n            if (context.outlet) {\n                // Destroy the component\n                context.outlet.deactivate();\n                // Destroy the contexts for all the outlets that were in the component\n                context.children.onOutletDeactivated();\n            }\n        }\n    };\n    /**\n     * @param {?} futureNode\n     * @param {?} currNode\n     * @param {?} contexts\n     * @return {?}\n     */\n    ActivateRoutes.prototype.activateChildRoutes = /**\n     * @param {?} futureNode\n     * @param {?} currNode\n     * @param {?} contexts\n     * @return {?}\n     */\n    function (futureNode, currNode, contexts) {\n        var _this = this;\n        var /** @type {?} */ children = nodeChildrenAsMap(currNode);\n        futureNode.children.forEach(function (c) {\n            _this.activateRoutes(c, children[c.value.outlet], contexts);\n            _this.forwardEvent(new ActivationEnd(c.value.snapshot));\n        });\n        if (futureNode.children.length) {\n            this.forwardEvent(new ChildActivationEnd(futureNode.value.snapshot));\n        }\n    };\n    /**\n     * @param {?} futureNode\n     * @param {?} currNode\n     * @param {?} parentContexts\n     * @return {?}\n     */\n    ActivateRoutes.prototype.activateRoutes = /**\n     * @param {?} futureNode\n     * @param {?} currNode\n     * @param {?} parentContexts\n     * @return {?}\n     */\n    function (futureNode, currNode, parentContexts) {\n        var /** @type {?} */ future = futureNode.value;\n        var /** @type {?} */ curr = currNode ? currNode.value : null;\n        advanceActivatedRoute(future);\n        // reusing the node\n        if (future === curr) {\n            if (future.component) {\n                // If we have a normal route, we need to go through an outlet.\n                var /** @type {?} */ context = parentContexts.getOrCreateContext(future.outlet);\n                this.activateChildRoutes(futureNode, currNode, context.children);\n            }\n            else {\n                // if we have a componentless route, we recurse but keep the same outlet map.\n                this.activateChildRoutes(futureNode, currNode, parentContexts);\n            }\n        }\n        else {\n            if (future.component) {\n                // if we have a normal route, we need to place the component into the outlet and recurse.\n                var /** @type {?} */ context = parentContexts.getOrCreateContext(future.outlet);\n                if (this.routeReuseStrategy.shouldAttach(future.snapshot)) {\n                    var /** @type {?} */ stored = (/** @type {?} */ (this.routeReuseStrategy.retrieve(future.snapshot)));\n                    this.routeReuseStrategy.store(future.snapshot, null);\n                    context.children.onOutletReAttached(stored.contexts);\n                    context.attachRef = stored.componentRef;\n                    context.route = stored.route.value;\n                    if (context.outlet) {\n                        // Attach right away when the outlet has already been instantiated\n                        // Otherwise attach from `RouterOutlet.ngOnInit` when it is instantiated\n                        context.outlet.attach(stored.componentRef, stored.route.value);\n                    }\n                    advanceActivatedRouteNodeAndItsChildren(stored.route);\n                }\n                else {\n                    var /** @type {?} */ config = parentLoadedConfig(future.snapshot);\n                    var /** @type {?} */ cmpFactoryResolver = config ? config.module.componentFactoryResolver : null;\n                    context.route = future;\n                    context.resolver = cmpFactoryResolver;\n                    if (context.outlet) {\n                        // Activate the outlet when it has already been instantiated\n                        // Otherwise it will get activated from its `ngOnInit` when instantiated\n                        context.outlet.activateWith(future, cmpFactoryResolver);\n                    }\n                    this.activateChildRoutes(futureNode, null, context.children);\n                }\n            }\n            else {\n                // if we have a componentless route, we recurse but keep the same outlet map.\n                this.activateChildRoutes(futureNode, null, parentContexts);\n            }\n        }\n    };\n    return ActivateRoutes;\n}());\n/**\n * @param {?} node\n * @return {?}\n */\nfunction advanceActivatedRouteNodeAndItsChildren(node) {\n    advanceActivatedRoute(node.value);\n    node.children.forEach(advanceActivatedRouteNodeAndItsChildren);\n}\n/**\n * @param {?} snapshot\n * @return {?}\n */\nfunction parentLoadedConfig(snapshot) {\n    for (var /** @type {?} */ s = snapshot.parent; s; s = s.parent) {\n        var /** @type {?} */ route = s.routeConfig;\n        if (route && route._loadedConfig)\n            return route._loadedConfig;\n        if (route && route.component)\n            return null;\n    }\n    return null;\n}\n/**\n * @param {?} commands\n * @return {?}\n */\nfunction validateCommands(commands) {\n    for (var /** @type {?} */ i = 0; i < commands.length; i++) {\n        var /** @type {?} */ cmd = commands[i];\n        if (cmd == null) {\n            throw new Error(\"The requested path contains \" + cmd + \" segment at index \" + i);\n        }\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * \\@whatItDoes Lets you link to specific parts of your app.\n *\n * \\@howToUse\n *\n * Consider the following route configuration:\n * `[{ path: 'user/:name', component: UserCmp }]`\n *\n * When linking to this `user/:name` route, you can write:\n * `<a routerLink='/user/bob'>link to user component</a>`\n *\n * \\@description\n *\n * The RouterLink directives let you link to specific parts of your app.\n *\n * When the link is static, you can use the directive as follows:\n * `<a routerLink=\"/user/bob\">link to user component</a>`\n *\n * If you use dynamic values to generate the link, you can pass an array of path\n * segments, followed by the params for each segment.\n *\n * For instance `['/team', teamId, 'user', userName, {details: true}]`\n * means that we want to generate a link to `/team/11/user/bob;details=true`.\n *\n * Multiple static segments can be merged into one\n * (e.g., `['/team/11/user', userName, {details: true}]`).\n *\n * The first segment name can be prepended with `/`, `./`, or `../`:\n * * If the first segment begins with `/`, the router will look up the route from the root of the\n *   app.\n * * If the first segment begins with `./`, or doesn't begin with a slash, the router will\n *   instead look in the children of the current activated route.\n * * And if the first segment begins with `../`, the router will go up one level.\n *\n * You can set query params and fragment as follows:\n *\n * ```\n * <a [routerLink]=\"['/user/bob']\" [queryParams]=\"{debug: true}\" fragment=\"education\">\n *   link to user component\n * </a>\n * ```\n * RouterLink will use these to generate this link: `/user/bob#education?debug=true`.\n *\n * (Deprecated in v4.0.0 use `queryParamsHandling` instead) You can also tell the\n * directive to preserve the current query params and fragment:\n *\n * ```\n * <a [routerLink]=\"['/user/bob']\" preserveQueryParams preserveFragment>\n *   link to user component\n * </a>\n * ```\n *\n * You can tell the directive to how to handle queryParams, available options are:\n *  - `'merge'`: merge the queryParams into the current queryParams\n *  - `'preserve'`: preserve the current queryParams\n *  - default/`''`: use the queryParams only\n *\n * Same options for {\\@link NavigationExtras#queryParamsHandling\n * NavigationExtras#queryParamsHandling}.\n *\n * ```\n * <a [routerLink]=\"['/user/bob']\" [queryParams]=\"{debug: true}\" queryParamsHandling=\"merge\">\n *   link to user component\n * </a>\n * ```\n *\n * The router link directive always treats the provided input as a delta to the current url.\n *\n * For instance, if the current url is `/user/(box//aux:team)`.\n *\n * Then the following link `<a [routerLink]=\"['/user/jim']\">Jim</a>` will generate the link\n * `/user/(jim//aux:team)`.\n *\n * See {\\@link Router#createUrlTree createUrlTree} for more information.\n *\n * \\@ngModule RouterModule\n *\n * \\@stable\n */\nvar RouterLink = (function () {\n    function RouterLink(router, route, tabIndex, renderer, el) {\n        this.router = router;\n        this.route = route;\n        this.commands = [];\n        if (tabIndex == null) {\n            renderer.setAttribute(el.nativeElement, 'tabindex', '0');\n        }\n    }\n    Object.defineProperty(RouterLink.prototype, \"routerLink\", {\n        set: /**\n         * @param {?} commands\n         * @return {?}\n         */\n        function (commands) {\n            if (commands != null) {\n                this.commands = Array.isArray(commands) ? commands : [commands];\n            }\n            else {\n                this.commands = [];\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(RouterLink.prototype, \"preserveQueryParams\", {\n        set: /**\n         * @deprecated 4.0.0 use `queryParamsHandling` instead.\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            if (isDevMode() && /** @type {?} */ (console) && /** @type {?} */ (console.warn)) {\n                console.warn('preserveQueryParams is deprecated!, use queryParamsHandling instead.');\n            }\n            this.preserve = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    RouterLink.prototype.onClick = /**\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ extras = {\n            skipLocationChange: attrBoolValue(this.skipLocationChange),\n            replaceUrl: attrBoolValue(this.replaceUrl),\n        };\n        this.router.navigateByUrl(this.urlTree, extras);\n        return true;\n    };\n    Object.defineProperty(RouterLink.prototype, \"urlTree\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            return this.router.createUrlTree(this.commands, {\n                relativeTo: this.route,\n                queryParams: this.queryParams,\n                fragment: this.fragment,\n                preserveQueryParams: attrBoolValue(this.preserve),\n                queryParamsHandling: this.queryParamsHandling,\n                preserveFragment: attrBoolValue(this.preserveFragment),\n            });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    RouterLink.decorators = [\n        { type: Directive, args: [{ selector: ':not(a)[routerLink]' },] },\n    ];\n    /** @nocollapse */\n    RouterLink.ctorParameters = function () { return [\n        { type: Router, },\n        { type: ActivatedRoute, },\n        { type: undefined, decorators: [{ type: Attribute, args: ['tabindex',] },] },\n        { type: Renderer2, },\n        { type: ElementRef, },\n    ]; };\n    RouterLink.propDecorators = {\n        \"queryParams\": [{ type: Input },],\n        \"fragment\": [{ type: Input },],\n        \"queryParamsHandling\": [{ type: Input },],\n        \"preserveFragment\": [{ type: Input },],\n        \"skipLocationChange\": [{ type: Input },],\n        \"replaceUrl\": [{ type: Input },],\n        \"routerLink\": [{ type: Input },],\n        \"preserveQueryParams\": [{ type: Input },],\n        \"onClick\": [{ type: HostListener, args: ['click',] },],\n    };\n    return RouterLink;\n}());\n/**\n * \\@whatItDoes Lets you link to specific parts of your app.\n *\n * See {\\@link RouterLink} for more information.\n *\n * \\@ngModule RouterModule\n *\n * \\@stable\n */\nvar RouterLinkWithHref = (function () {\n    function RouterLinkWithHref(router, route, locationStrategy) {\n        var _this = this;\n        this.router = router;\n        this.route = route;\n        this.locationStrategy = locationStrategy;\n        this.commands = [];\n        this.subscription = router.events.subscribe(function (s) {\n            if (s instanceof NavigationEnd) {\n                _this.updateTargetUrlAndHref();\n            }\n        });\n    }\n    Object.defineProperty(RouterLinkWithHref.prototype, \"routerLink\", {\n        set: /**\n         * @param {?} commands\n         * @return {?}\n         */\n        function (commands) {\n            if (commands != null) {\n                this.commands = Array.isArray(commands) ? commands : [commands];\n            }\n            else {\n                this.commands = [];\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(RouterLinkWithHref.prototype, \"preserveQueryParams\", {\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            if (isDevMode() && /** @type {?} */ (console) && /** @type {?} */ (console.warn)) {\n                console.warn('preserveQueryParams is deprecated, use queryParamsHandling instead.');\n            }\n            this.preserve = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    RouterLinkWithHref.prototype.ngOnChanges = /**\n     * @param {?} changes\n     * @return {?}\n     */\n    function (changes) { this.updateTargetUrlAndHref(); };\n    /**\n     * @return {?}\n     */\n    RouterLinkWithHref.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () { this.subscription.unsubscribe(); };\n    /**\n     * @param {?} button\n     * @param {?} ctrlKey\n     * @param {?} metaKey\n     * @param {?} shiftKey\n     * @return {?}\n     */\n    RouterLinkWithHref.prototype.onClick = /**\n     * @param {?} button\n     * @param {?} ctrlKey\n     * @param {?} metaKey\n     * @param {?} shiftKey\n     * @return {?}\n     */\n    function (button, ctrlKey, metaKey, shiftKey) {\n        if (button !== 0 || ctrlKey || metaKey || shiftKey) {\n            return true;\n        }\n        if (typeof this.target === 'string' && this.target != '_self') {\n            return true;\n        }\n        var /** @type {?} */ extras = {\n            skipLocationChange: attrBoolValue(this.skipLocationChange),\n            replaceUrl: attrBoolValue(this.replaceUrl),\n        };\n        this.router.navigateByUrl(this.urlTree, extras);\n        return false;\n    };\n    /**\n     * @return {?}\n     */\n    RouterLinkWithHref.prototype.updateTargetUrlAndHref = /**\n     * @return {?}\n     */\n    function () {\n        this.href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.urlTree));\n    };\n    Object.defineProperty(RouterLinkWithHref.prototype, \"urlTree\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            return this.router.createUrlTree(this.commands, {\n                relativeTo: this.route,\n                queryParams: this.queryParams,\n                fragment: this.fragment,\n                preserveQueryParams: attrBoolValue(this.preserve),\n                queryParamsHandling: this.queryParamsHandling,\n                preserveFragment: attrBoolValue(this.preserveFragment),\n            });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    RouterLinkWithHref.decorators = [\n        { type: Directive, args: [{ selector: 'a[routerLink]' },] },\n    ];\n    /** @nocollapse */\n    RouterLinkWithHref.ctorParameters = function () { return [\n        { type: Router, },\n        { type: ActivatedRoute, },\n        { type: LocationStrategy, },\n    ]; };\n    RouterLinkWithHref.propDecorators = {\n        \"target\": [{ type: HostBinding, args: ['attr.target',] }, { type: Input },],\n        \"queryParams\": [{ type: Input },],\n        \"fragment\": [{ type: Input },],\n        \"queryParamsHandling\": [{ type: Input },],\n        \"preserveFragment\": [{ type: Input },],\n        \"skipLocationChange\": [{ type: Input },],\n        \"replaceUrl\": [{ type: Input },],\n        \"href\": [{ type: HostBinding },],\n        \"routerLink\": [{ type: Input },],\n        \"preserveQueryParams\": [{ type: Input },],\n        \"onClick\": [{ type: HostListener, args: ['click', ['$event.button', '$event.ctrlKey', '$event.metaKey', '$event.shiftKey'],] },],\n    };\n    return RouterLinkWithHref;\n}());\n/**\n * @param {?} s\n * @return {?}\n */\nfunction attrBoolValue(s) {\n    return s === '' || !!s;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * \\@whatItDoes Lets you add a CSS class to an element when the link's route becomes active.\n *\n * \\@howToUse\n *\n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\">Bob</a>\n * ```\n *\n * \\@description\n *\n * The RouterLinkActive directive lets you add a CSS class to an element when the link's route\n * becomes active.\n *\n * Consider the following example:\n *\n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\">Bob</a>\n * ```\n *\n * When the url is either '/user' or '/user/bob', the active-link class will\n * be added to the `a` tag. If the url changes, the class will be removed.\n *\n * You can set more than one class, as follows:\n *\n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive=\"class1 class2\">Bob</a>\n * <a routerLink=\"/user/bob\" [routerLinkActive]=\"['class1', 'class2']\">Bob</a>\n * ```\n *\n * You can configure RouterLinkActive by passing `exact: true`. This will add the classes\n * only when the url matches the link exactly.\n *\n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\" [routerLinkActiveOptions]=\"{exact:\n * true}\">Bob</a>\n * ```\n *\n * You can assign the RouterLinkActive instance to a template variable and directly check\n * the `isActive` status.\n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive #rla=\"routerLinkActive\">\n *   Bob {{ rla.isActive ? '(already open)' : ''}}\n * </a>\n * ```\n *\n * Finally, you can apply the RouterLinkActive directive to an ancestor of a RouterLink.\n *\n * ```\n * <div routerLinkActive=\"active-link\" [routerLinkActiveOptions]=\"{exact: true}\">\n *   <a routerLink=\"/user/jim\">Jim</a>\n *   <a routerLink=\"/user/bob\">Bob</a>\n * </div>\n * ```\n *\n * This will set the active-link class on the div tag if the url is either '/user/jim' or\n * '/user/bob'.\n *\n * \\@ngModule RouterModule\n *\n * \\@stable\n */\nvar RouterLinkActive = (function () {\n    function RouterLinkActive(router, element, renderer, cdr) {\n        var _this = this;\n        this.router = router;\n        this.element = element;\n        this.renderer = renderer;\n        this.cdr = cdr;\n        this.classes = [];\n        this.isActive = false;\n        this.routerLinkActiveOptions = { exact: false };\n        this.subscription = router.events.subscribe(function (s) {\n            if (s instanceof NavigationEnd) {\n                _this.update();\n            }\n        });\n    }\n    /**\n     * @return {?}\n     */\n    RouterLinkActive.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this.links.changes.subscribe(function (_) { return _this.update(); });\n        this.linksWithHrefs.changes.subscribe(function (_) { return _this.update(); });\n        this.update();\n    };\n    Object.defineProperty(RouterLinkActive.prototype, \"routerLinkActive\", {\n        set: /**\n         * @param {?} data\n         * @return {?}\n         */\n        function (data) {\n            var /** @type {?} */ classes = Array.isArray(data) ? data : data.split(' ');\n            this.classes = classes.filter(function (c) { return !!c; });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    RouterLinkActive.prototype.ngOnChanges = /**\n     * @param {?} changes\n     * @return {?}\n     */\n    function (changes) { this.update(); };\n    /**\n     * @return {?}\n     */\n    RouterLinkActive.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () { this.subscription.unsubscribe(); };\n    /**\n     * @return {?}\n     */\n    RouterLinkActive.prototype.update = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (!this.links || !this.linksWithHrefs || !this.router.navigated)\n            return;\n        Promise.resolve().then(function () {\n            var /** @type {?} */ hasActiveLinks = _this.hasActiveLinks();\n            if (_this.isActive !== hasActiveLinks) {\n                (/** @type {?} */ (_this)).isActive = hasActiveLinks;\n                _this.classes.forEach(function (c) {\n                    if (hasActiveLinks) {\n                        _this.renderer.addClass(_this.element.nativeElement, c);\n                    }\n                    else {\n                        _this.renderer.removeClass(_this.element.nativeElement, c);\n                    }\n                });\n            }\n        });\n    };\n    /**\n     * @param {?} router\n     * @return {?}\n     */\n    RouterLinkActive.prototype.isLinkActive = /**\n     * @param {?} router\n     * @return {?}\n     */\n    function (router) {\n        var _this = this;\n        return function (link) {\n            return router.isActive(link.urlTree, _this.routerLinkActiveOptions.exact);\n        };\n    };\n    /**\n     * @return {?}\n     */\n    RouterLinkActive.prototype.hasActiveLinks = /**\n     * @return {?}\n     */\n    function () {\n        return this.links.some(this.isLinkActive(this.router)) ||\n            this.linksWithHrefs.some(this.isLinkActive(this.router));\n    };\n    RouterLinkActive.decorators = [\n        { type: Directive, args: [{\n                    selector: '[routerLinkActive]',\n                    exportAs: 'routerLinkActive',\n                },] },\n    ];\n    /** @nocollapse */\n    RouterLinkActive.ctorParameters = function () { return [\n        { type: Router, },\n        { type: ElementRef, },\n        { type: Renderer2, },\n        { type: ChangeDetectorRef, },\n    ]; };\n    RouterLinkActive.propDecorators = {\n        \"links\": [{ type: ContentChildren, args: [RouterLink, { descendants: true },] },],\n        \"linksWithHrefs\": [{ type: ContentChildren, args: [RouterLinkWithHref, { descendants: true },] },],\n        \"routerLinkActiveOptions\": [{ type: Input },],\n        \"routerLinkActive\": [{ type: Input },],\n    };\n    return RouterLinkActive;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Store contextual information about a {\\@link RouterOutlet}\n *\n * \\@stable\n */\nvar OutletContext = (function () {\n    function OutletContext() {\n        this.outlet = null;\n        this.route = null;\n        this.resolver = null;\n        this.children = new ChildrenOutletContexts();\n        this.attachRef = null;\n    }\n    return OutletContext;\n}());\n/**\n * Store contextual information about the children (= nested) {\\@link RouterOutlet}\n *\n * \\@stable\n */\nvar ChildrenOutletContexts = (function () {\n    function ChildrenOutletContexts() {\n        this.contexts = new Map();\n    }\n    /** Called when a `RouterOutlet` directive is instantiated */\n    /**\n     * Called when a `RouterOutlet` directive is instantiated\n     * @param {?} childName\n     * @param {?} outlet\n     * @return {?}\n     */\n    ChildrenOutletContexts.prototype.onChildOutletCreated = /**\n     * Called when a `RouterOutlet` directive is instantiated\n     * @param {?} childName\n     * @param {?} outlet\n     * @return {?}\n     */\n    function (childName, outlet) {\n        var /** @type {?} */ context = this.getOrCreateContext(childName);\n        context.outlet = outlet;\n        this.contexts.set(childName, context);\n    };\n    /**\n     * Called when a `RouterOutlet` directive is destroyed.\n     * We need to keep the context as the outlet could be destroyed inside a NgIf and might be\n     * re-created later.\n     */\n    /**\n     * Called when a `RouterOutlet` directive is destroyed.\n     * We need to keep the context as the outlet could be destroyed inside a NgIf and might be\n     * re-created later.\n     * @param {?} childName\n     * @return {?}\n     */\n    ChildrenOutletContexts.prototype.onChildOutletDestroyed = /**\n     * Called when a `RouterOutlet` directive is destroyed.\n     * We need to keep the context as the outlet could be destroyed inside a NgIf and might be\n     * re-created later.\n     * @param {?} childName\n     * @return {?}\n     */\n    function (childName) {\n        var /** @type {?} */ context = this.getContext(childName);\n        if (context) {\n            context.outlet = null;\n        }\n    };\n    /**\n     * Called when the corresponding route is deactivated during navigation.\n     * Because the component get destroyed, all children outlet are destroyed.\n     */\n    /**\n     * Called when the corresponding route is deactivated during navigation.\n     * Because the component get destroyed, all children outlet are destroyed.\n     * @return {?}\n     */\n    ChildrenOutletContexts.prototype.onOutletDeactivated = /**\n     * Called when the corresponding route is deactivated during navigation.\n     * Because the component get destroyed, all children outlet are destroyed.\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ contexts = this.contexts;\n        this.contexts = new Map();\n        return contexts;\n    };\n    /**\n     * @param {?} contexts\n     * @return {?}\n     */\n    ChildrenOutletContexts.prototype.onOutletReAttached = /**\n     * @param {?} contexts\n     * @return {?}\n     */\n    function (contexts) { this.contexts = contexts; };\n    /**\n     * @param {?} childName\n     * @return {?}\n     */\n    ChildrenOutletContexts.prototype.getOrCreateContext = /**\n     * @param {?} childName\n     * @return {?}\n     */\n    function (childName) {\n        var /** @type {?} */ context = this.getContext(childName);\n        if (!context) {\n            context = new OutletContext();\n            this.contexts.set(childName, context);\n        }\n        return context;\n    };\n    /**\n     * @param {?} childName\n     * @return {?}\n     */\n    ChildrenOutletContexts.prototype.getContext = /**\n     * @param {?} childName\n     * @return {?}\n     */\n    function (childName) { return this.contexts.get(childName) || null; };\n    return ChildrenOutletContexts;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * \\@whatItDoes Acts as a placeholder that Angular dynamically fills based on the current router\n * state.\n *\n * \\@howToUse\n *\n * ```\n * <router-outlet></router-outlet>\n * <router-outlet name='left'></router-outlet>\n * <router-outlet name='right'></router-outlet>\n * ```\n *\n * A router outlet will emit an activate event any time a new component is being instantiated,\n * and a deactivate event when it is being destroyed.\n *\n * ```\n * <router-outlet\n *   (activate)='onActivate($event)'\n *   (deactivate)='onDeactivate($event)'></router-outlet>\n * ```\n * \\@ngModule RouterModule\n *\n * \\@stable\n */\nvar RouterOutlet = (function () {\n    function RouterOutlet(parentContexts, location, resolver, name, changeDetector) {\n        this.parentContexts = parentContexts;\n        this.location = location;\n        this.resolver = resolver;\n        this.changeDetector = changeDetector;\n        this.activated = null;\n        this._activatedRoute = null;\n        this.activateEvents = new EventEmitter();\n        this.deactivateEvents = new EventEmitter();\n        this.name = name || PRIMARY_OUTLET;\n        parentContexts.onChildOutletCreated(this.name, this);\n    }\n    /**\n     * @return {?}\n     */\n    RouterOutlet.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () { this.parentContexts.onChildOutletDestroyed(this.name); };\n    /**\n     * @return {?}\n     */\n    RouterOutlet.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n        if (!this.activated) {\n            // If the outlet was not instantiated at the time the route got activated we need to populate\n            // the outlet when it is initialized (ie inside a NgIf)\n            var /** @type {?} */ context = this.parentContexts.getContext(this.name);\n            if (context && context.route) {\n                if (context.attachRef) {\n                    // `attachRef` is populated when there is an existing component to mount\n                    this.attach(context.attachRef, context.route);\n                }\n                else {\n                    // otherwise the component defined in the configuration is created\n                    this.activateWith(context.route, context.resolver || null);\n                }\n            }\n        }\n    };\n    Object.defineProperty(RouterOutlet.prototype, \"isActivated\", {\n        get: /**\n         * @return {?}\n         */\n        function () { return !!this.activated; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(RouterOutlet.prototype, \"component\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            if (!this.activated)\n                throw new Error('Outlet is not activated');\n            return this.activated.instance;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(RouterOutlet.prototype, \"activatedRoute\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            if (!this.activated)\n                throw new Error('Outlet is not activated');\n            return /** @type {?} */ (this._activatedRoute);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(RouterOutlet.prototype, \"activatedRouteData\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            if (this._activatedRoute) {\n                return this._activatedRoute.snapshot.data;\n            }\n            return {};\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Called when the `RouteReuseStrategy` instructs to detach the subtree\n     */\n    /**\n     * Called when the `RouteReuseStrategy` instructs to detach the subtree\n     * @return {?}\n     */\n    RouterOutlet.prototype.detach = /**\n     * Called when the `RouteReuseStrategy` instructs to detach the subtree\n     * @return {?}\n     */\n    function () {\n        if (!this.activated)\n            throw new Error('Outlet is not activated');\n        this.location.detach();\n        var /** @type {?} */ cmp = this.activated;\n        this.activated = null;\n        this._activatedRoute = null;\n        return cmp;\n    };\n    /**\n     * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree\n     */\n    /**\n     * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree\n     * @param {?} ref\n     * @param {?} activatedRoute\n     * @return {?}\n     */\n    RouterOutlet.prototype.attach = /**\n     * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree\n     * @param {?} ref\n     * @param {?} activatedRoute\n     * @return {?}\n     */\n    function (ref, activatedRoute) {\n        this.activated = ref;\n        this._activatedRoute = activatedRoute;\n        this.location.insert(ref.hostView);\n    };\n    /**\n     * @return {?}\n     */\n    RouterOutlet.prototype.deactivate = /**\n     * @return {?}\n     */\n    function () {\n        if (this.activated) {\n            var /** @type {?} */ c = this.component;\n            this.activated.destroy();\n            this.activated = null;\n            this._activatedRoute = null;\n            this.deactivateEvents.emit(c);\n        }\n    };\n    /**\n     * @param {?} activatedRoute\n     * @param {?} resolver\n     * @return {?}\n     */\n    RouterOutlet.prototype.activateWith = /**\n     * @param {?} activatedRoute\n     * @param {?} resolver\n     * @return {?}\n     */\n    function (activatedRoute, resolver) {\n        if (this.isActivated) {\n            throw new Error('Cannot activate an already activated outlet');\n        }\n        this._activatedRoute = activatedRoute;\n        var /** @type {?} */ snapshot = activatedRoute._futureSnapshot;\n        var /** @type {?} */ component = /** @type {?} */ (/** @type {?} */ ((snapshot.routeConfig)).component);\n        resolver = resolver || this.resolver;\n        var /** @type {?} */ factory = resolver.resolveComponentFactory(component);\n        var /** @type {?} */ childContexts = this.parentContexts.getOrCreateContext(this.name).children;\n        var /** @type {?} */ injector = new OutletInjector(activatedRoute, childContexts, this.location.injector);\n        this.activated = this.location.createComponent(factory, this.location.length, injector);\n        // Calling `markForCheck` to make sure we will run the change detection when the\n        // `RouterOutlet` is inside a `ChangeDetectionStrategy.OnPush` component.\n        this.changeDetector.markForCheck();\n        this.activateEvents.emit(this.activated.instance);\n    };\n    RouterOutlet.decorators = [\n        { type: Directive, args: [{ selector: 'router-outlet', exportAs: 'outlet' },] },\n    ];\n    /** @nocollapse */\n    RouterOutlet.ctorParameters = function () { return [\n        { type: ChildrenOutletContexts, },\n        { type: ViewContainerRef, },\n        { type: ComponentFactoryResolver, },\n        { type: undefined, decorators: [{ type: Attribute, args: ['name',] },] },\n        { type: ChangeDetectorRef, },\n    ]; };\n    RouterOutlet.propDecorators = {\n        \"activateEvents\": [{ type: Output, args: ['activate',] },],\n        \"deactivateEvents\": [{ type: Output, args: ['deactivate',] },],\n    };\n    return RouterOutlet;\n}());\nvar OutletInjector = (function () {\n    function OutletInjector(route, childContexts, parent) {\n        this.route = route;\n        this.childContexts = childContexts;\n        this.parent = parent;\n    }\n    /**\n     * @param {?} token\n     * @param {?=} notFoundValue\n     * @return {?}\n     */\n    OutletInjector.prototype.get = /**\n     * @param {?} token\n     * @param {?=} notFoundValue\n     * @return {?}\n     */\n    function (token, notFoundValue) {\n        if (token === ActivatedRoute) {\n            return this.route;\n        }\n        if (token === ChildrenOutletContexts) {\n            return this.childContexts;\n        }\n        return this.parent.get(token, notFoundValue);\n    };\n    return OutletInjector;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n*@license\n*Copyright Google Inc. All Rights Reserved.\n*\n*Use of this source code is governed by an MIT-style license that can be\n*found in the LICENSE file at https://angular.io/license\n*/\n/**\n * \\@whatItDoes Provides a preloading strategy.\n *\n * \\@experimental\n * @abstract\n */\nvar PreloadingStrategy = (function () {\n    function PreloadingStrategy() {\n    }\n    return PreloadingStrategy;\n}());\n/**\n * \\@whatItDoes Provides a preloading strategy that preloads all modules as quickly as possible.\n *\n * \\@howToUse\n *\n * ```\n * RouteModule.forRoot(ROUTES, {preloadingStrategy: PreloadAllModules})\n * ```\n *\n * \\@experimental\n */\nvar PreloadAllModules = (function () {\n    function PreloadAllModules() {\n    }\n    /**\n     * @param {?} route\n     * @param {?} fn\n     * @return {?}\n     */\n    PreloadAllModules.prototype.preload = /**\n     * @param {?} route\n     * @param {?} fn\n     * @return {?}\n     */\n    function (route, fn) {\n        return _catch.call(fn(), function () { return of(null); });\n    };\n    return PreloadAllModules;\n}());\n/**\n * \\@whatItDoes Provides a preloading strategy that does not preload any modules.\n *\n * \\@description\n *\n * This strategy is enabled by default.\n *\n * \\@experimental\n */\nvar NoPreloading = (function () {\n    function NoPreloading() {\n    }\n    /**\n     * @param {?} route\n     * @param {?} fn\n     * @return {?}\n     */\n    NoPreloading.prototype.preload = /**\n     * @param {?} route\n     * @param {?} fn\n     * @return {?}\n     */\n    function (route, fn) { return of(null); };\n    return NoPreloading;\n}());\n/**\n * The preloader optimistically loads all router configurations to\n * make navigations into lazily-loaded sections of the application faster.\n *\n * The preloader runs in the background. When the router bootstraps, the preloader\n * starts listening to all navigation events. After every such event, the preloader\n * will check if any configurations can be loaded lazily.\n *\n * If a route is protected by `canLoad` guards, the preloaded will not load it.\n *\n * \\@stable\n */\nvar RouterPreloader = (function () {\n    function RouterPreloader(router, moduleLoader, compiler, injector, preloadingStrategy) {\n        this.router = router;\n        this.injector = injector;\n        this.preloadingStrategy = preloadingStrategy;\n        var /** @type {?} */ onStartLoad = function (r) { return router.triggerEvent(new RouteConfigLoadStart(r)); };\n        var /** @type {?} */ onEndLoad = function (r) { return router.triggerEvent(new RouteConfigLoadEnd(r)); };\n        this.loader = new RouterConfigLoader(moduleLoader, compiler, onStartLoad, onEndLoad);\n    }\n    /**\n     * @return {?}\n     */\n    RouterPreloader.prototype.setUpPreloading = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        var /** @type {?} */ navigations$ = filter.call(this.router.events, function (e) { return e instanceof NavigationEnd; });\n        this.subscription = concatMap.call(navigations$, function () { return _this.preload(); }).subscribe(function () { });\n    };\n    /**\n     * @return {?}\n     */\n    RouterPreloader.prototype.preload = /**\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ ngModule = this.injector.get(NgModuleRef);\n        return this.processRoutes(ngModule, this.router.config);\n    };\n    // TODO(jasonaden): This class relies on code external to the class to call setUpPreloading. If\n    // this hasn't been done, ngOnDestroy will fail as this.subscription will be undefined. This\n    // should be refactored.\n    /**\n     * @return {?}\n     */\n    RouterPreloader.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () { this.subscription.unsubscribe(); };\n    /**\n     * @param {?} ngModule\n     * @param {?} routes\n     * @return {?}\n     */\n    RouterPreloader.prototype.processRoutes = /**\n     * @param {?} ngModule\n     * @param {?} routes\n     * @return {?}\n     */\n    function (ngModule, routes) {\n        var /** @type {?} */ res = [];\n        for (var _i = 0, routes_1 = routes; _i < routes_1.length; _i++) {\n            var route = routes_1[_i];\n            // we already have the config loaded, just recurse\n            if (route.loadChildren && !route.canLoad && route._loadedConfig) {\n                var /** @type {?} */ childConfig = route._loadedConfig;\n                res.push(this.processRoutes(childConfig.module, childConfig.routes));\n                // no config loaded, fetch the config\n            }\n            else if (route.loadChildren && !route.canLoad) {\n                res.push(this.preloadConfig(ngModule, route));\n                // recurse into children\n            }\n            else if (route.children) {\n                res.push(this.processRoutes(ngModule, route.children));\n            }\n        }\n        return mergeAll.call(from(res));\n    };\n    /**\n     * @param {?} ngModule\n     * @param {?} route\n     * @return {?}\n     */\n    RouterPreloader.prototype.preloadConfig = /**\n     * @param {?} ngModule\n     * @param {?} route\n     * @return {?}\n     */\n    function (ngModule, route) {\n        var _this = this;\n        return this.preloadingStrategy.preload(route, function () {\n            var /** @type {?} */ loaded$ = _this.loader.load(ngModule.injector, route);\n            return mergeMap.call(loaded$, function (config) {\n                route._loadedConfig = config;\n                return _this.processRoutes(config.module, config.routes);\n            });\n        });\n    };\n    RouterPreloader.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    RouterPreloader.ctorParameters = function () { return [\n        { type: Router, },\n        { type: NgModuleFactoryLoader, },\n        { type: Compiler, },\n        { type: Injector, },\n        { type: PreloadingStrategy, },\n    ]; };\n    return RouterPreloader;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * \\@whatItDoes Contains a list of directives\n * \\@stable\n */\nvar ROUTER_DIRECTIVES = [RouterOutlet, RouterLink, RouterLinkWithHref, RouterLinkActive];\n/**\n * \\@whatItDoes Is used in DI to configure the router.\n * \\@stable\n */\nvar ROUTER_CONFIGURATION = new InjectionToken('ROUTER_CONFIGURATION');\n/**\n * \\@docsNotRequired\n */\nvar ROUTER_FORROOT_GUARD = new InjectionToken('ROUTER_FORROOT_GUARD');\nvar ROUTER_PROVIDERS = [\n    Location,\n    { provide: UrlSerializer, useClass: DefaultUrlSerializer },\n    {\n        provide: Router,\n        useFactory: setupRouter,\n        deps: [\n            ApplicationRef, UrlSerializer, ChildrenOutletContexts, Location, Injector,\n            NgModuleFactoryLoader, Compiler, ROUTES, ROUTER_CONFIGURATION,\n            [UrlHandlingStrategy, new Optional()], [RouteReuseStrategy, new Optional()]\n        ]\n    },\n    ChildrenOutletContexts,\n    { provide: ActivatedRoute, useFactory: rootRoute, deps: [Router] },\n    { provide: NgModuleFactoryLoader, useClass: SystemJsNgModuleLoader },\n    RouterPreloader,\n    NoPreloading,\n    PreloadAllModules,\n    { provide: ROUTER_CONFIGURATION, useValue: { enableTracing: false } },\n];\n/**\n * @return {?}\n */\nfunction routerNgProbeToken() {\n    return new NgProbeToken('Router', Router);\n}\n/**\n * \\@whatItDoes Adds router directives and providers.\n *\n * \\@howToUse\n *\n * RouterModule can be imported multiple times: once per lazily-loaded bundle.\n * Since the router deals with a global shared resource--location, we cannot have\n * more than one router service active.\n *\n * That is why there are two ways to create the module: `RouterModule.forRoot` and\n * `RouterModule.forChild`.\n *\n * * `forRoot` creates a module that contains all the directives, the given routes, and the router\n *   service itself.\n * * `forChild` creates a module that contains all the directives and the given routes, but does not\n *   include the router service.\n *\n * When registered at the root, the module should be used as follows\n *\n * ```\n * \\@NgModule({\n *   imports: [RouterModule.forRoot(ROUTES)]\n * })\n * class MyNgModule {}\n * ```\n *\n * For submodules and lazy loaded submodules the module should be used as follows:\n *\n * ```\n * \\@NgModule({\n *   imports: [RouterModule.forChild(ROUTES)]\n * })\n * class MyNgModule {}\n * ```\n *\n * \\@description\n *\n * Managing state transitions is one of the hardest parts of building applications. This is\n * especially true on the web, where you also need to ensure that the state is reflected in the URL.\n * In addition, we often want to split applications into multiple bundles and load them on demand.\n * Doing this transparently is not trivial.\n *\n * The Angular router solves these problems. Using the router, you can declaratively specify\n * application states, manage state transitions while taking care of the URL, and load bundles on\n * demand.\n *\n * [Read this developer guide](https://angular.io/docs/ts/latest/guide/router.html) to get an\n * overview of how the router should be used.\n *\n * \\@stable\n */\nvar RouterModule = (function () {\n    // Note: We are injecting the Router so it gets created eagerly...\n    function RouterModule(guard, router) {\n    }\n    /**\n     * Creates a module with all the router providers and directives. It also optionally sets up an\n     * application listener to perform an initial navigation.\n     *\n     * Options:\n     * * `enableTracing` makes the router log all its internal events to the console.\n     * * `useHash` enables the location strategy that uses the URL fragment instead of the history\n     * API.\n     * * `initialNavigation` disables the initial navigation.\n     * * `errorHandler` provides a custom error handler.\n     */\n    /**\n     * Creates a module with all the router providers and directives. It also optionally sets up an\n     * application listener to perform an initial navigation.\n     *\n     * Options:\n     * * `enableTracing` makes the router log all its internal events to the console.\n     * * `useHash` enables the location strategy that uses the URL fragment instead of the history\n     * API.\n     * * `initialNavigation` disables the initial navigation.\n     * * `errorHandler` provides a custom error handler.\n     * @param {?} routes\n     * @param {?=} config\n     * @return {?}\n     */\n    RouterModule.forRoot = /**\n     * Creates a module with all the router providers and directives. It also optionally sets up an\n     * application listener to perform an initial navigation.\n     *\n     * Options:\n     * * `enableTracing` makes the router log all its internal events to the console.\n     * * `useHash` enables the location strategy that uses the URL fragment instead of the history\n     * API.\n     * * `initialNavigation` disables the initial navigation.\n     * * `errorHandler` provides a custom error handler.\n     * @param {?} routes\n     * @param {?=} config\n     * @return {?}\n     */\n    function (routes, config) {\n        return {\n            ngModule: RouterModule,\n            providers: [\n                ROUTER_PROVIDERS,\n                provideRoutes(routes),\n                {\n                    provide: ROUTER_FORROOT_GUARD,\n                    useFactory: provideForRootGuard,\n                    deps: [[Router, new Optional(), new SkipSelf()]]\n                },\n                { provide: ROUTER_CONFIGURATION, useValue: config ? config : {} },\n                {\n                    provide: LocationStrategy,\n                    useFactory: provideLocationStrategy,\n                    deps: [\n                        PlatformLocation, [new Inject(APP_BASE_HREF), new Optional()], ROUTER_CONFIGURATION\n                    ]\n                },\n                {\n                    provide: PreloadingStrategy,\n                    useExisting: config && config.preloadingStrategy ? config.preloadingStrategy :\n                        NoPreloading\n                },\n                { provide: NgProbeToken, multi: true, useFactory: routerNgProbeToken },\n                provideRouterInitializer(),\n            ],\n        };\n    };\n    /**\n     * Creates a module with all the router directives and a provider registering routes.\n     */\n    /**\n     * Creates a module with all the router directives and a provider registering routes.\n     * @param {?} routes\n     * @return {?}\n     */\n    RouterModule.forChild = /**\n     * Creates a module with all the router directives and a provider registering routes.\n     * @param {?} routes\n     * @return {?}\n     */\n    function (routes) {\n        return { ngModule: RouterModule, providers: [provideRoutes(routes)] };\n    };\n    RouterModule.decorators = [\n        { type: NgModule, args: [{ declarations: ROUTER_DIRECTIVES, exports: ROUTER_DIRECTIVES },] },\n    ];\n    /** @nocollapse */\n    RouterModule.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [ROUTER_FORROOT_GUARD,] },] },\n        { type: Router, decorators: [{ type: Optional },] },\n    ]; };\n    return RouterModule;\n}());\n/**\n * @param {?} platformLocationStrategy\n * @param {?} baseHref\n * @param {?=} options\n * @return {?}\n */\nfunction provideLocationStrategy(platformLocationStrategy, baseHref, options) {\n    if (options === void 0) { options = {}; }\n    return options.useHash ? new HashLocationStrategy(platformLocationStrategy, baseHref) :\n        new PathLocationStrategy(platformLocationStrategy, baseHref);\n}\n/**\n * @param {?} router\n * @return {?}\n */\nfunction provideForRootGuard(router) {\n    if (router) {\n        throw new Error(\"RouterModule.forRoot() called twice. Lazy loaded modules should use RouterModule.forChild() instead.\");\n    }\n    return 'guarded';\n}\n/**\n * \\@whatItDoes Registers routes.\n *\n * \\@howToUse\n *\n * ```\n * \\@NgModule({\n *   imports: [RouterModule.forChild(ROUTES)],\n *   providers: [provideRoutes(EXTRA_ROUTES)]\n * })\n * class MyNgModule {}\n * ```\n *\n * \\@stable\n * @param {?} routes\n * @return {?}\n */\nfunction provideRoutes(routes) {\n    return [\n        { provide: ANALYZE_FOR_ENTRY_COMPONENTS, multi: true, useValue: routes },\n        { provide: ROUTES, multi: true, useValue: routes },\n    ];\n}\n/**\n * \\@whatItDoes Represents options to configure the router.\n *\n * \\@stable\n * @record\n */\n\n/**\n * @param {?} ref\n * @param {?} urlSerializer\n * @param {?} contexts\n * @param {?} location\n * @param {?} injector\n * @param {?} loader\n * @param {?} compiler\n * @param {?} config\n * @param {?=} opts\n * @param {?=} urlHandlingStrategy\n * @param {?=} routeReuseStrategy\n * @return {?}\n */\nfunction setupRouter(ref, urlSerializer, contexts, location, injector, loader, compiler, config, opts, urlHandlingStrategy, routeReuseStrategy) {\n    if (opts === void 0) { opts = {}; }\n    var /** @type {?} */ router = new Router(null, urlSerializer, contexts, location, injector, loader, compiler, flatten(config));\n    if (urlHandlingStrategy) {\n        router.urlHandlingStrategy = urlHandlingStrategy;\n    }\n    if (routeReuseStrategy) {\n        router.routeReuseStrategy = routeReuseStrategy;\n    }\n    if (opts.errorHandler) {\n        router.errorHandler = opts.errorHandler;\n    }\n    if (opts.enableTracing) {\n        var /** @type {?} */ dom_1 = getDOM();\n        router.events.subscribe(function (e) {\n            dom_1.logGroup(\"Router Event: \" + ((/** @type {?} */ (e.constructor))).name);\n            dom_1.log(e.toString());\n            dom_1.log(e);\n            dom_1.logGroupEnd();\n        });\n    }\n    return router;\n}\n/**\n * @param {?} router\n * @return {?}\n */\nfunction rootRoute(router) {\n    return router.routerState.root;\n}\n/**\n * To initialize the router properly we need to do in two steps:\n *\n * We need to start the navigation in a APP_INITIALIZER to block the bootstrap if\n * a resolver or a guards executes asynchronously. Second, we need to actually run\n * activation in a BOOTSTRAP_LISTENER. We utilize the afterPreactivation\n * hook provided by the router to do that.\n *\n * The router navigation starts, reaches the point when preactivation is done, and then\n * pauses. It waits for the hook to be resolved. We then resolve it only in a bootstrap listener.\n */\nvar RouterInitializer = (function () {\n    function RouterInitializer(injector) {\n        this.injector = injector;\n        this.initNavigation = false;\n        this.resultOfPreactivationDone = new Subject();\n    }\n    /**\n     * @return {?}\n     */\n    RouterInitializer.prototype.appInitializer = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        var /** @type {?} */ p = this.injector.get(LOCATION_INITIALIZED, Promise.resolve(null));\n        return p.then(function () {\n            var /** @type {?} */ resolve = /** @type {?} */ ((null));\n            var /** @type {?} */ res = new Promise(function (r) { return resolve = r; });\n            var /** @type {?} */ router = _this.injector.get(Router);\n            var /** @type {?} */ opts = _this.injector.get(ROUTER_CONFIGURATION);\n            if (_this.isLegacyDisabled(opts) || _this.isLegacyEnabled(opts)) {\n                resolve(true);\n            }\n            else if (opts.initialNavigation === 'disabled') {\n                router.setUpLocationChangeListener();\n                resolve(true);\n            }\n            else if (opts.initialNavigation === 'enabled') {\n                router.hooks.afterPreactivation = function () {\n                    // only the initial navigation should be delayed\n                    if (!_this.initNavigation) {\n                        _this.initNavigation = true;\n                        resolve(true);\n                        return _this.resultOfPreactivationDone;\n                        // subsequent navigations should not be delayed\n                    }\n                    else {\n                        return /** @type {?} */ (of(null));\n                    }\n                };\n                router.initialNavigation();\n            }\n            else {\n                throw new Error(\"Invalid initialNavigation options: '\" + opts.initialNavigation + \"'\");\n            }\n            return res;\n        });\n    };\n    /**\n     * @param {?} bootstrappedComponentRef\n     * @return {?}\n     */\n    RouterInitializer.prototype.bootstrapListener = /**\n     * @param {?} bootstrappedComponentRef\n     * @return {?}\n     */\n    function (bootstrappedComponentRef) {\n        var /** @type {?} */ opts = this.injector.get(ROUTER_CONFIGURATION);\n        var /** @type {?} */ preloader = this.injector.get(RouterPreloader);\n        var /** @type {?} */ router = this.injector.get(Router);\n        var /** @type {?} */ ref = this.injector.get(ApplicationRef);\n        if (bootstrappedComponentRef !== ref.components[0]) {\n            return;\n        }\n        if (this.isLegacyEnabled(opts)) {\n            router.initialNavigation();\n        }\n        else if (this.isLegacyDisabled(opts)) {\n            router.setUpLocationChangeListener();\n        }\n        preloader.setUpPreloading();\n        router.resetRootComponentType(ref.componentTypes[0]);\n        this.resultOfPreactivationDone.next(/** @type {?} */ ((null)));\n        this.resultOfPreactivationDone.complete();\n    };\n    /**\n     * @param {?} opts\n     * @return {?}\n     */\n    RouterInitializer.prototype.isLegacyEnabled = /**\n     * @param {?} opts\n     * @return {?}\n     */\n    function (opts) {\n        return opts.initialNavigation === 'legacy_enabled' || opts.initialNavigation === true ||\n            opts.initialNavigation === undefined;\n    };\n    /**\n     * @param {?} opts\n     * @return {?}\n     */\n    RouterInitializer.prototype.isLegacyDisabled = /**\n     * @param {?} opts\n     * @return {?}\n     */\n    function (opts) {\n        return opts.initialNavigation === 'legacy_disabled' || opts.initialNavigation === false;\n    };\n    RouterInitializer.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    RouterInitializer.ctorParameters = function () { return [\n        { type: Injector, },\n    ]; };\n    return RouterInitializer;\n}());\n/**\n * @param {?} r\n * @return {?}\n */\nfunction getAppInitializer(r) {\n    return r.appInitializer.bind(r);\n}\n/**\n * @param {?} r\n * @return {?}\n */\nfunction getBootstrapListener(r) {\n    return r.bootstrapListener.bind(r);\n}\n/**\n * A token for the router initializer that will be called after the app is bootstrapped.\n *\n * \\@experimental\n */\nvar ROUTER_INITIALIZER = new InjectionToken('Router Initializer');\n/**\n * @return {?}\n */\nfunction provideRouterInitializer() {\n    return [\n        RouterInitializer,\n        {\n            provide: APP_INITIALIZER,\n            multi: true,\n            useFactory: getAppInitializer,\n            deps: [RouterInitializer]\n        },\n        { provide: ROUTER_INITIALIZER, useFactory: getBootstrapListener, deps: [RouterInitializer] },\n        { provide: APP_BOOTSTRAP_LISTENER, multi: true, useExisting: ROUTER_INITIALIZER },\n    ];\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @module\n * @description\n * Entry point for all public APIs of the common package.\n */\n/**\n * \\@stable\n */\nvar VERSION = new Version('5.0.1');\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @module\n * @description\n * Entry point for all public APIs of this package.\n */\n\n// This file only reexports content of the `src` folder. Keep it that way.\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { RouterLink, RouterLinkWithHref, RouterLinkActive, RouterOutlet, ActivationEnd, ActivationStart, ChildActivationEnd, ChildActivationStart, GuardsCheckEnd, GuardsCheckStart, NavigationCancel, NavigationEnd, NavigationError, NavigationStart, ResolveEnd, ResolveStart, RouteConfigLoadEnd, RouteConfigLoadStart, RouterEvent, RoutesRecognized, RouteReuseStrategy, Router, ROUTES, ROUTER_CONFIGURATION, ROUTER_INITIALIZER, RouterModule, provideRoutes, ChildrenOutletContexts, OutletContext, NoPreloading, PreloadAllModules, PreloadingStrategy, RouterPreloader, ActivatedRoute, ActivatedRouteSnapshot, RouterState, RouterStateSnapshot, PRIMARY_OUTLET, convertToParamMap, UrlHandlingStrategy, DefaultUrlSerializer, UrlSegment, UrlSegmentGroup, UrlSerializer, UrlTree, VERSION, ROUTER_PROVIDERS as ROUTER_PROVIDERS, flatten as flatten, ROUTER_FORROOT_GUARD as a, RouterInitializer as g, getAppInitializer as h, getBootstrapListener as i, provideForRootGuard as d, provideLocationStrategy as c, provideRouterInitializer as j, rootRoute as f, routerNgProbeToken as b, setupRouter as e, Tree as k, TreeNode as l };\n//# sourceMappingURL=router.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@angular/router/esm5/router.js\n// module id = 42\n// module chunks = 2","\"use strict\";\nvar ArrayObservable_1 = require('./ArrayObservable');\nexports.of = ArrayObservable_1.ArrayObservable.of;\n//# sourceMappingURL=of.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/observable/of.js\n// module id = 44\n// module chunks = 2","\"use strict\";\nvar concatMap_1 = require('../operators/concatMap');\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, in a serialized fashion waiting for each one to complete before\n * merging the next.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link concatAll}.</span>\n *\n * <img src=\"./img/concatMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each new inner Observable is\n * concatenated with the previous inner Observable.\n *\n * __Warning:__ if source values arrive endlessly and faster than their\n * corresponding inner Observables can complete, it will result in memory issues\n * as inner Observables amass in an unbounded buffer waiting for their turn to\n * be subscribed to.\n *\n * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set\n * to `1`.\n *\n * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.concatMap(ev => Rx.Observable.interval(1000).take(4));\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n *\n * @see {@link concat}\n * @see {@link concatAll}\n * @see {@link concatMapTo}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and taking values from each projected inner\n * Observable sequentially.\n * @method concatMap\n * @owner Observable\n */\nfunction concatMap(project, resultSelector) {\n    return concatMap_1.concatMap(project, resultSelector)(this);\n}\nexports.concatMap = concatMap;\n//# sourceMappingURL=concatMap.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operator/concatMap.js\n// module id = 45\n// module chunks = 2","\"use strict\";\nvar filter_1 = require('../operators/filter');\n/* tslint:enable:max-line-length */\n/**\n * Filter items emitted by the source Observable by only emitting those that\n * satisfy a specified predicate.\n *\n * <span class=\"informal\">Like\n * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n * it only emits a value from the source if it passes a criterion function.</span>\n *\n * <img src=\"./img/filter.png\" width=\"100%\">\n *\n * Similar to the well-known `Array.prototype.filter` method, this operator\n * takes values from the source Observable, passes them through a `predicate`\n * function and only emits those values that yielded `true`.\n *\n * @example <caption>Emit only click events whose target was a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');\n * clicksOnDivs.subscribe(x => console.log(x));\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n * @see {@link ignoreElements}\n * @see {@link partition}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted, if `false` the value is not passed to the output\n * Observable. The `index` parameter is the number `i` for the i-th source\n * emission that has happened since the subscription, starting from the number\n * `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable} An Observable of values from the source that were\n * allowed by the `predicate` function.\n * @method filter\n * @owner Observable\n */\nfunction filter(predicate, thisArg) {\n    return filter_1.filter(predicate, thisArg)(this);\n}\nexports.filter = filter;\n//# sourceMappingURL=filter.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operator/filter.js\n// module id = 46\n// module chunks = 2","import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\r\nimport { enableProdMode } from '@angular/core';\r\nimport { RootModule } from './root-module/root.module';\r\n\r\nif (process.env.NODE_ENV === 'production') {\r\n    enableProdMode();\r\n}\r\n\r\nplatformBrowserDynamic().bootstrapModule(RootModule);\r\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/angular2-template-loader!./node_modules/angular-router-loader/src!./components/main.ts","import { NgModule } from '@angular/core';\r\nimport { BrowserModule } from '@angular/platform-browser';\r\n\r\nimport { RootRoutingModule } from './root-routing.module';\r\nimport { RootComponent } from './root.component';\r\nimport { HomeComponent } from './home/home.component';\r\nimport { PageNotFoundComponent } from './page-not-found/page-not-found.component';\r\n\r\n@NgModule({\r\n    imports: [\r\n        BrowserModule,        \r\n        RootRoutingModule\r\n    ],\r\n    declarations: [\r\n        RootComponent,\r\n        HomeComponent,\r\n        PageNotFoundComponent\r\n    ],\r\n    bootstrap: [RootComponent]\r\n})\r\nexport class RootModule { }\r\n\r\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/angular2-template-loader!./node_modules/angular-router-loader/src!./components/root-module/root.module.ts","import { NgModule } from '@angular/core';\r\nimport { RouterModule, Routes } from '@angular/router';\r\n\r\nimport { HomeComponent } from './home/home.component';\r\nimport { PageNotFoundComponent } from './page-not-found/page-not-found.component';\r\n\r\nconst appRoutes: Routes = [\r\n    { path: '', redirectTo: 'home', pathMatch: 'full' },\r\n    { path: 'home', component: HomeComponent },\r\n    {\r\n        path: 'employees',\r\n        loadChildren: () => new Promise(function (resolve) {  (require as any).ensure([], function (require: any) {    resolve(require('employees-module\\\\employees.module')['EmployeesModule']);  });})\r\n    },    \r\n    { path: '**', component: PageNotFoundComponent }\r\n];\r\n\r\n@NgModule({\r\n    imports: [\r\n        RouterModule.forRoot(\r\n            appRoutes\r\n            //,{ enableTracing: true } // <-- debugging purposes only\r\n        )\r\n    ],\r\n    exports: [\r\n        RouterModule\r\n    ]\r\n})\r\nexport class RootRoutingModule { }\n\n\n// WEBPACK FOOTER //\n// ./node_modules/angular2-template-loader!./node_modules/angular-router-loader/src!./components/root-module/root-routing.module.ts","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = require('./Subject');\nvar ObjectUnsubscribedError_1 = require('./util/ObjectUnsubscribedError');\n/**\n * @class BehaviorSubject<T>\n */\nvar BehaviorSubject = (function (_super) {\n    __extends(BehaviorSubject, _super);\n    function BehaviorSubject(_value) {\n        _super.call(this);\n        this._value = _value;\n    }\n    Object.defineProperty(BehaviorSubject.prototype, \"value\", {\n        get: function () {\n            return this.getValue();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    BehaviorSubject.prototype._subscribe = function (subscriber) {\n        var subscription = _super.prototype._subscribe.call(this, subscriber);\n        if (subscription && !subscription.closed) {\n            subscriber.next(this._value);\n        }\n        return subscription;\n    };\n    BehaviorSubject.prototype.getValue = function () {\n        if (this.hasError) {\n            throw this.thrownError;\n        }\n        else if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        else {\n            return this._value;\n        }\n    };\n    BehaviorSubject.prototype.next = function (value) {\n        _super.prototype.next.call(this, this._value = value);\n    };\n    return BehaviorSubject;\n}(Subject_1.Subject));\nexports.BehaviorSubject = BehaviorSubject;\n//# sourceMappingURL=BehaviorSubject.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/BehaviorSubject.js\n// module id = 74\n// module chunks = 2","\"use strict\";\nvar mergeMap_1 = require('./mergeMap');\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, in a serialized fashion waiting for each one to complete before\n * merging the next.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link concatAll}.</span>\n *\n * <img src=\"./img/concatMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each new inner Observable is\n * concatenated with the previous inner Observable.\n *\n * __Warning:__ if source values arrive endlessly and faster than their\n * corresponding inner Observables can complete, it will result in memory issues\n * as inner Observables amass in an unbounded buffer waiting for their turn to\n * be subscribed to.\n *\n * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set\n * to `1`.\n *\n * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.concatMap(ev => Rx.Observable.interval(1000).take(4));\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n *\n * @see {@link concat}\n * @see {@link concatAll}\n * @see {@link concatMapTo}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and taking values from each projected inner\n * Observable sequentially.\n * @method concatMap\n * @owner Observable\n */\nfunction concatMap(project, resultSelector) {\n    return mergeMap_1.mergeMap(project, resultSelector, 1);\n}\nexports.concatMap = concatMap;\n//# sourceMappingURL=concatMap.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/concatMap.js\n// module id = 75\n// module chunks = 2","\"use strict\";\nvar mergeMap_1 = require('../operators/mergeMap');\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link mergeAll}.</span>\n *\n * <img src=\"./img/mergeMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger.\n *\n * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>\n * var letters = Rx.Observable.of('a', 'b', 'c');\n * var result = letters.mergeMap(x =>\n *   Rx.Observable.interval(1000).map(i => x+i)\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // a0\n * // b0\n * // c0\n * // a1\n * // b1\n * // c1\n * // continues to list a,b,c with respective ascending integers\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and merging the results of the Observables obtained\n * from this transformation.\n * @method mergeMap\n * @owner Observable\n */\nfunction mergeMap(project, resultSelector, concurrent) {\n    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n    return mergeMap_1.mergeMap(project, resultSelector, concurrent)(this);\n}\nexports.mergeMap = mergeMap;\n//# sourceMappingURL=mergeMap.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operator/mergeMap.js\n// module id = 76\n// module chunks = 2","\"use strict\";\nvar FromObservable_1 = require('./FromObservable');\nexports.from = FromObservable_1.FromObservable.create;\n//# sourceMappingURL=from.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/observable/from.js\n// module id = 77\n// module chunks = 2","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isArray_1 = require('../util/isArray');\nvar isArrayLike_1 = require('../util/isArrayLike');\nvar isPromise_1 = require('../util/isPromise');\nvar PromiseObservable_1 = require('./PromiseObservable');\nvar IteratorObservable_1 = require('./IteratorObservable');\nvar ArrayObservable_1 = require('./ArrayObservable');\nvar ArrayLikeObservable_1 = require('./ArrayLikeObservable');\nvar iterator_1 = require('../symbol/iterator');\nvar Observable_1 = require('../Observable');\nvar observeOn_1 = require('../operators/observeOn');\nvar observable_1 = require('../symbol/observable');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar FromObservable = (function (_super) {\n    __extends(FromObservable, _super);\n    function FromObservable(ish, scheduler) {\n        _super.call(this, null);\n        this.ish = ish;\n        this.scheduler = scheduler;\n    }\n    /**\n     * Creates an Observable from an Array, an array-like object, a Promise, an\n     * iterable object, or an Observable-like object.\n     *\n     * <span class=\"informal\">Converts almost anything to an Observable.</span>\n     *\n     * <img src=\"./img/from.png\" width=\"100%\">\n     *\n     * Convert various other objects and data types into Observables. `from`\n     * converts a Promise or an array-like or an\n     * [iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable)\n     * object into an Observable that emits the items in that promise or array or\n     * iterable. A String, in this context, is treated as an array of characters.\n     * Observable-like objects (contains a function named with the ES2015 Symbol\n     * for Observable) can also be converted through this operator.\n     *\n     * @example <caption>Converts an array to an Observable</caption>\n     * var array = [10, 20, 30];\n     * var result = Rx.Observable.from(array);\n     * result.subscribe(x => console.log(x));\n     *\n     * // Results in the following:\n     * // 10 20 30\n     *\n     * @example <caption>Convert an infinite iterable (from a generator) to an Observable</caption>\n     * function* generateDoubles(seed) {\n     *   var i = seed;\n     *   while (true) {\n     *     yield i;\n     *     i = 2 * i; // double it\n     *   }\n     * }\n     *\n     * var iterator = generateDoubles(3);\n     * var result = Rx.Observable.from(iterator).take(10);\n     * result.subscribe(x => console.log(x));\n     *\n     * // Results in the following:\n     * // 3 6 12 24 48 96 192 384 768 1536\n     *\n     * @see {@link create}\n     * @see {@link fromEvent}\n     * @see {@link fromEventPattern}\n     * @see {@link fromPromise}\n     *\n     * @param {ObservableInput<T>} ish A subscribable object, a Promise, an\n     * Observable-like, an Array, an iterable or an array-like object to be\n     * converted.\n     * @param {Scheduler} [scheduler] The scheduler on which to schedule the\n     * emissions of values.\n     * @return {Observable<T>} The Observable whose values are originally from the\n     * input object that was converted.\n     * @static true\n     * @name from\n     * @owner Observable\n     */\n    FromObservable.create = function (ish, scheduler) {\n        if (ish != null) {\n            if (typeof ish[observable_1.observable] === 'function') {\n                if (ish instanceof Observable_1.Observable && !scheduler) {\n                    return ish;\n                }\n                return new FromObservable(ish, scheduler);\n            }\n            else if (isArray_1.isArray(ish)) {\n                return new ArrayObservable_1.ArrayObservable(ish, scheduler);\n            }\n            else if (isPromise_1.isPromise(ish)) {\n                return new PromiseObservable_1.PromiseObservable(ish, scheduler);\n            }\n            else if (typeof ish[iterator_1.iterator] === 'function' || typeof ish === 'string') {\n                return new IteratorObservable_1.IteratorObservable(ish, scheduler);\n            }\n            else if (isArrayLike_1.isArrayLike(ish)) {\n                return new ArrayLikeObservable_1.ArrayLikeObservable(ish, scheduler);\n            }\n        }\n        throw new TypeError((ish !== null && typeof ish || ish) + ' is not observable');\n    };\n    FromObservable.prototype._subscribe = function (subscriber) {\n        var ish = this.ish;\n        var scheduler = this.scheduler;\n        if (scheduler == null) {\n            return ish[observable_1.observable]().subscribe(subscriber);\n        }\n        else {\n            return ish[observable_1.observable]().subscribe(new observeOn_1.ObserveOnSubscriber(subscriber, scheduler, 0));\n        }\n    };\n    return FromObservable;\n}(Observable_1.Observable));\nexports.FromObservable = FromObservable;\n//# sourceMappingURL=FromObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/observable/FromObservable.js\n// module id = 78\n// module chunks = 2","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar root_1 = require('../util/root');\nvar Observable_1 = require('../Observable');\nvar iterator_1 = require('../symbol/iterator');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar IteratorObservable = (function (_super) {\n    __extends(IteratorObservable, _super);\n    function IteratorObservable(iterator, scheduler) {\n        _super.call(this);\n        this.scheduler = scheduler;\n        if (iterator == null) {\n            throw new Error('iterator cannot be null.');\n        }\n        this.iterator = getIterator(iterator);\n    }\n    IteratorObservable.create = function (iterator, scheduler) {\n        return new IteratorObservable(iterator, scheduler);\n    };\n    IteratorObservable.dispatch = function (state) {\n        var index = state.index, hasError = state.hasError, iterator = state.iterator, subscriber = state.subscriber;\n        if (hasError) {\n            subscriber.error(state.error);\n            return;\n        }\n        var result = iterator.next();\n        if (result.done) {\n            subscriber.complete();\n            return;\n        }\n        subscriber.next(result.value);\n        state.index = index + 1;\n        if (subscriber.closed) {\n            if (typeof iterator.return === 'function') {\n                iterator.return();\n            }\n            return;\n        }\n        this.schedule(state);\n    };\n    IteratorObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var _a = this, iterator = _a.iterator, scheduler = _a.scheduler;\n        if (scheduler) {\n            return scheduler.schedule(IteratorObservable.dispatch, 0, {\n                index: index, iterator: iterator, subscriber: subscriber\n            });\n        }\n        else {\n            do {\n                var result = iterator.next();\n                if (result.done) {\n                    subscriber.complete();\n                    break;\n                }\n                else {\n                    subscriber.next(result.value);\n                }\n                if (subscriber.closed) {\n                    if (typeof iterator.return === 'function') {\n                        iterator.return();\n                    }\n                    break;\n                }\n            } while (true);\n        }\n    };\n    return IteratorObservable;\n}(Observable_1.Observable));\nexports.IteratorObservable = IteratorObservable;\nvar StringIterator = (function () {\n    function StringIterator(str, idx, len) {\n        if (idx === void 0) { idx = 0; }\n        if (len === void 0) { len = str.length; }\n        this.str = str;\n        this.idx = idx;\n        this.len = len;\n    }\n    StringIterator.prototype[iterator_1.iterator] = function () { return (this); };\n    StringIterator.prototype.next = function () {\n        return this.idx < this.len ? {\n            done: false,\n            value: this.str.charAt(this.idx++)\n        } : {\n            done: true,\n            value: undefined\n        };\n    };\n    return StringIterator;\n}());\nvar ArrayIterator = (function () {\n    function ArrayIterator(arr, idx, len) {\n        if (idx === void 0) { idx = 0; }\n        if (len === void 0) { len = toLength(arr); }\n        this.arr = arr;\n        this.idx = idx;\n        this.len = len;\n    }\n    ArrayIterator.prototype[iterator_1.iterator] = function () { return this; };\n    ArrayIterator.prototype.next = function () {\n        return this.idx < this.len ? {\n            done: false,\n            value: this.arr[this.idx++]\n        } : {\n            done: true,\n            value: undefined\n        };\n    };\n    return ArrayIterator;\n}());\nfunction getIterator(obj) {\n    var i = obj[iterator_1.iterator];\n    if (!i && typeof obj === 'string') {\n        return new StringIterator(obj);\n    }\n    if (!i && obj.length !== undefined) {\n        return new ArrayIterator(obj);\n    }\n    if (!i) {\n        throw new TypeError('object is not iterable');\n    }\n    return obj[iterator_1.iterator]();\n}\nvar maxSafeInteger = Math.pow(2, 53) - 1;\nfunction toLength(o) {\n    var len = +o.length;\n    if (isNaN(len)) {\n        return 0;\n    }\n    if (len === 0 || !numberIsFinite(len)) {\n        return len;\n    }\n    len = sign(len) * Math.floor(Math.abs(len));\n    if (len <= 0) {\n        return 0;\n    }\n    if (len > maxSafeInteger) {\n        return maxSafeInteger;\n    }\n    return len;\n}\nfunction numberIsFinite(value) {\n    return typeof value === 'number' && root_1.root.isFinite(value);\n}\nfunction sign(value) {\n    var valueAsNumber = +value;\n    if (valueAsNumber === 0) {\n        return valueAsNumber;\n    }\n    if (isNaN(valueAsNumber)) {\n        return valueAsNumber;\n    }\n    return valueAsNumber < 0 ? -1 : 1;\n}\n//# sourceMappingURL=IteratorObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/observable/IteratorObservable.js\n// module id = 79\n// module chunks = 2","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('../Observable');\nvar ScalarObservable_1 = require('./ScalarObservable');\nvar EmptyObservable_1 = require('./EmptyObservable');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar ArrayLikeObservable = (function (_super) {\n    __extends(ArrayLikeObservable, _super);\n    function ArrayLikeObservable(arrayLike, scheduler) {\n        _super.call(this);\n        this.arrayLike = arrayLike;\n        this.scheduler = scheduler;\n        if (!scheduler && arrayLike.length === 1) {\n            this._isScalar = true;\n            this.value = arrayLike[0];\n        }\n    }\n    ArrayLikeObservable.create = function (arrayLike, scheduler) {\n        var length = arrayLike.length;\n        if (length === 0) {\n            return new EmptyObservable_1.EmptyObservable();\n        }\n        else if (length === 1) {\n            return new ScalarObservable_1.ScalarObservable(arrayLike[0], scheduler);\n        }\n        else {\n            return new ArrayLikeObservable(arrayLike, scheduler);\n        }\n    };\n    ArrayLikeObservable.dispatch = function (state) {\n        var arrayLike = state.arrayLike, index = state.index, length = state.length, subscriber = state.subscriber;\n        if (subscriber.closed) {\n            return;\n        }\n        if (index >= length) {\n            subscriber.complete();\n            return;\n        }\n        subscriber.next(arrayLike[index]);\n        state.index = index + 1;\n        this.schedule(state);\n    };\n    ArrayLikeObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var _a = this, arrayLike = _a.arrayLike, scheduler = _a.scheduler;\n        var length = arrayLike.length;\n        if (scheduler) {\n            return scheduler.schedule(ArrayLikeObservable.dispatch, 0, {\n                arrayLike: arrayLike, index: index, length: length, subscriber: subscriber\n            });\n        }\n        else {\n            for (var i = 0; i < length && !subscriber.closed; i++) {\n                subscriber.next(arrayLike[i]);\n            }\n            subscriber.complete();\n        }\n    };\n    return ArrayLikeObservable;\n}(Observable_1.Observable));\nexports.ArrayLikeObservable = ArrayLikeObservable;\n//# sourceMappingURL=ArrayLikeObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/observable/ArrayLikeObservable.js\n// module id = 80\n// module chunks = 2","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar Notification_1 = require('../Notification');\n/**\n *\n * Re-emits all notifications from source Observable with specified scheduler.\n *\n * <span class=\"informal\">Ensure a specific scheduler is used, from outside of an Observable.</span>\n *\n * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule\n * notifications emitted by the source Observable. It might be useful, if you do not have control over\n * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.\n *\n * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,\n * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal\n * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits\n * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.\n * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split\n * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source\n * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a\n * little bit more, to ensure that they are emitted at expected moments.\n *\n * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications\n * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`\n * will delay all notifications - including error notifications - while `delay` will pass through error\n * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator\n * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used\n * for notification emissions in general.\n *\n * @example <caption>Ensure values in subscribe are called just before browser repaint.</caption>\n * const intervals = Rx.Observable.interval(10); // Intervals are scheduled\n *                                               // with async scheduler by default...\n *\n * intervals\n * .observeOn(Rx.Scheduler.animationFrame)       // ...but we will observe on animationFrame\n * .subscribe(val => {                           // scheduler to ensure smooth animation.\n *   someDiv.style.height = val + 'px';\n * });\n *\n * @see {@link delay}\n *\n * @param {IScheduler} scheduler Scheduler that will be used to reschedule notifications from source Observable.\n * @param {number} [delay] Number of milliseconds that states with what delay every notification should be rescheduled.\n * @return {Observable<T>} Observable that emits the same notifications as the source Observable,\n * but with provided scheduler.\n *\n * @method observeOn\n * @owner Observable\n */\nfunction observeOn(scheduler, delay) {\n    if (delay === void 0) { delay = 0; }\n    return function observeOnOperatorFunction(source) {\n        return source.lift(new ObserveOnOperator(scheduler, delay));\n    };\n}\nexports.observeOn = observeOn;\nvar ObserveOnOperator = (function () {\n    function ObserveOnOperator(scheduler, delay) {\n        if (delay === void 0) { delay = 0; }\n        this.scheduler = scheduler;\n        this.delay = delay;\n    }\n    ObserveOnOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));\n    };\n    return ObserveOnOperator;\n}());\nexports.ObserveOnOperator = ObserveOnOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ObserveOnSubscriber = (function (_super) {\n    __extends(ObserveOnSubscriber, _super);\n    function ObserveOnSubscriber(destination, scheduler, delay) {\n        if (delay === void 0) { delay = 0; }\n        _super.call(this, destination);\n        this.scheduler = scheduler;\n        this.delay = delay;\n    }\n    ObserveOnSubscriber.dispatch = function (arg) {\n        var notification = arg.notification, destination = arg.destination;\n        notification.observe(destination);\n        this.unsubscribe();\n    };\n    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {\n        this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));\n    };\n    ObserveOnSubscriber.prototype._next = function (value) {\n        this.scheduleMessage(Notification_1.Notification.createNext(value));\n    };\n    ObserveOnSubscriber.prototype._error = function (err) {\n        this.scheduleMessage(Notification_1.Notification.createError(err));\n    };\n    ObserveOnSubscriber.prototype._complete = function () {\n        this.scheduleMessage(Notification_1.Notification.createComplete());\n    };\n    return ObserveOnSubscriber;\n}(Subscriber_1.Subscriber));\nexports.ObserveOnSubscriber = ObserveOnSubscriber;\nvar ObserveOnMessage = (function () {\n    function ObserveOnMessage(notification, destination) {\n        this.notification = notification;\n        this.destination = destination;\n    }\n    return ObserveOnMessage;\n}());\nexports.ObserveOnMessage = ObserveOnMessage;\n//# sourceMappingURL=observeOn.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/observeOn.js\n// module id = 81\n// module chunks = 2","\"use strict\";\nvar Observable_1 = require('./Observable');\n/**\n * Represents a push-based event or value that an {@link Observable} can emit.\n * This class is particularly useful for operators that manage notifications,\n * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and\n * others. Besides wrapping the actual delivered value, it also annotates it\n * with metadata of, for instance, what type of push message it is (`next`,\n * `error`, or `complete`).\n *\n * @see {@link materialize}\n * @see {@link dematerialize}\n * @see {@link observeOn}\n *\n * @class Notification<T>\n */\nvar Notification = (function () {\n    function Notification(kind, value, error) {\n        this.kind = kind;\n        this.value = value;\n        this.error = error;\n        this.hasValue = kind === 'N';\n    }\n    /**\n     * Delivers to the given `observer` the value wrapped by this Notification.\n     * @param {Observer} observer\n     * @return\n     */\n    Notification.prototype.observe = function (observer) {\n        switch (this.kind) {\n            case 'N':\n                return observer.next && observer.next(this.value);\n            case 'E':\n                return observer.error && observer.error(this.error);\n            case 'C':\n                return observer.complete && observer.complete();\n        }\n    };\n    /**\n     * Given some {@link Observer} callbacks, deliver the value represented by the\n     * current Notification to the correctly corresponding callback.\n     * @param {function(value: T): void} next An Observer `next` callback.\n     * @param {function(err: any): void} [error] An Observer `error` callback.\n     * @param {function(): void} [complete] An Observer `complete` callback.\n     * @return {any}\n     */\n    Notification.prototype.do = function (next, error, complete) {\n        var kind = this.kind;\n        switch (kind) {\n            case 'N':\n                return next && next(this.value);\n            case 'E':\n                return error && error(this.error);\n            case 'C':\n                return complete && complete();\n        }\n    };\n    /**\n     * Takes an Observer or its individual callback functions, and calls `observe`\n     * or `do` methods accordingly.\n     * @param {Observer|function(value: T): void} nextOrObserver An Observer or\n     * the `next` callback.\n     * @param {function(err: any): void} [error] An Observer `error` callback.\n     * @param {function(): void} [complete] An Observer `complete` callback.\n     * @return {any}\n     */\n    Notification.prototype.accept = function (nextOrObserver, error, complete) {\n        if (nextOrObserver && typeof nextOrObserver.next === 'function') {\n            return this.observe(nextOrObserver);\n        }\n        else {\n            return this.do(nextOrObserver, error, complete);\n        }\n    };\n    /**\n     * Returns a simple Observable that just delivers the notification represented\n     * by this Notification instance.\n     * @return {any}\n     */\n    Notification.prototype.toObservable = function () {\n        var kind = this.kind;\n        switch (kind) {\n            case 'N':\n                return Observable_1.Observable.of(this.value);\n            case 'E':\n                return Observable_1.Observable.throw(this.error);\n            case 'C':\n                return Observable_1.Observable.empty();\n        }\n        throw new Error('unexpected notification kind value');\n    };\n    /**\n     * A shortcut to create a Notification instance of the type `next` from a\n     * given value.\n     * @param {T} value The `next` value.\n     * @return {Notification<T>} The \"next\" Notification representing the\n     * argument.\n     */\n    Notification.createNext = function (value) {\n        if (typeof value !== 'undefined') {\n            return new Notification('N', value);\n        }\n        return Notification.undefinedValueNotification;\n    };\n    /**\n     * A shortcut to create a Notification instance of the type `error` from a\n     * given error.\n     * @param {any} [err] The `error` error.\n     * @return {Notification<T>} The \"error\" Notification representing the\n     * argument.\n     */\n    Notification.createError = function (err) {\n        return new Notification('E', undefined, err);\n    };\n    /**\n     * A shortcut to create a Notification instance of the type `complete`.\n     * @return {Notification<any>} The valueless \"complete\" Notification.\n     */\n    Notification.createComplete = function () {\n        return Notification.completeNotification;\n    };\n    Notification.completeNotification = new Notification('C');\n    Notification.undefinedValueNotification = new Notification('N', undefined);\n    return Notification;\n}());\nexports.Notification = Notification;\n//# sourceMappingURL=Notification.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/Notification.js\n// module id = 82\n// module chunks = 2","\"use strict\";\nvar catchError_1 = require('../operators/catchError');\n/**\n * Catches errors on the observable to be handled by returning a new observable or throwing an error.\n *\n * <img src=\"./img/catch.png\" width=\"100%\">\n *\n * @example <caption>Continues with a different Observable when there's an error</caption>\n *\n * Observable.of(1, 2, 3, 4, 5)\n *   .map(n => {\n * \t   if (n == 4) {\n * \t     throw 'four!';\n *     }\n *\t   return n;\n *   })\n *   .catch(err => Observable.of('I', 'II', 'III', 'IV', 'V'))\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, I, II, III, IV, V\n *\n * @example <caption>Retries the caught source Observable again in case of error, similar to retry() operator</caption>\n *\n * Observable.of(1, 2, 3, 4, 5)\n *   .map(n => {\n * \t   if (n === 4) {\n * \t     throw 'four!';\n *     }\n * \t   return n;\n *   })\n *   .catch((err, caught) => caught)\n *   .take(30)\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, 1, 2, 3, ...\n *\n * @example <caption>Throws a new error when the source Observable throws an error</caption>\n *\n * Observable.of(1, 2, 3, 4, 5)\n *   .map(n => {\n *     if (n == 4) {\n *       throw 'four!';\n *     }\n *     return n;\n *   })\n *   .catch(err => {\n *     throw 'error in source. Details: ' + err;\n *   })\n *   .subscribe(\n *     x => console.log(x),\n *     err => console.log(err)\n *   );\n *   // 1, 2, 3, error in source. Details: four!\n *\n * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which\n *  is the source observable, in case you'd like to \"retry\" that observable by returning it again. Whatever observable\n *  is returned by the `selector` will be used to continue the observable chain.\n * @return {Observable} An observable that originates from either the source or the observable returned by the\n *  catch `selector` function.\n * @method catch\n * @name catch\n * @owner Observable\n */\nfunction _catch(selector) {\n    return catchError_1.catchError(selector)(this);\n}\nexports._catch = _catch;\n//# sourceMappingURL=catch.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operator/catch.js\n// module id = 83\n// module chunks = 2","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Catches errors on the observable to be handled by returning a new observable or throwing an error.\n *\n * <img src=\"./img/catch.png\" width=\"100%\">\n *\n * @example <caption>Continues with a different Observable when there's an error</caption>\n *\n * Observable.of(1, 2, 3, 4, 5)\n *   .map(n => {\n * \t   if (n == 4) {\n * \t     throw 'four!';\n *     }\n *\t   return n;\n *   })\n *   .catch(err => Observable.of('I', 'II', 'III', 'IV', 'V'))\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, I, II, III, IV, V\n *\n * @example <caption>Retries the caught source Observable again in case of error, similar to retry() operator</caption>\n *\n * Observable.of(1, 2, 3, 4, 5)\n *   .map(n => {\n * \t   if (n === 4) {\n * \t     throw 'four!';\n *     }\n * \t   return n;\n *   })\n *   .catch((err, caught) => caught)\n *   .take(30)\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, 1, 2, 3, ...\n *\n * @example <caption>Throws a new error when the source Observable throws an error</caption>\n *\n * Observable.of(1, 2, 3, 4, 5)\n *   .map(n => {\n *     if (n == 4) {\n *       throw 'four!';\n *     }\n *     return n;\n *   })\n *   .catch(err => {\n *     throw 'error in source. Details: ' + err;\n *   })\n *   .subscribe(\n *     x => console.log(x),\n *     err => console.log(err)\n *   );\n *   // 1, 2, 3, error in source. Details: four!\n *\n * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which\n *  is the source observable, in case you'd like to \"retry\" that observable by returning it again. Whatever observable\n *  is returned by the `selector` will be used to continue the observable chain.\n * @return {Observable} An observable that originates from either the source or the observable returned by the\n *  catch `selector` function.\n * @name catchError\n */\nfunction catchError(selector) {\n    return function catchErrorOperatorFunction(source) {\n        var operator = new CatchOperator(selector);\n        var caught = source.lift(operator);\n        return (operator.caught = caught);\n    };\n}\nexports.catchError = catchError;\nvar CatchOperator = (function () {\n    function CatchOperator(selector) {\n        this.selector = selector;\n    }\n    CatchOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));\n    };\n    return CatchOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar CatchSubscriber = (function (_super) {\n    __extends(CatchSubscriber, _super);\n    function CatchSubscriber(destination, selector, caught) {\n        _super.call(this, destination);\n        this.selector = selector;\n        this.caught = caught;\n    }\n    // NOTE: overriding `error` instead of `_error` because we don't want\n    // to have this flag this subscriber as `isStopped`. We can mimic the\n    // behavior of the RetrySubscriber (from the `retry` operator), where\n    // we unsubscribe from our source chain, reset our Subscriber flags,\n    // then subscribe to the selector result.\n    CatchSubscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            var result = void 0;\n            try {\n                result = this.selector(err, this.caught);\n            }\n            catch (err2) {\n                _super.prototype.error.call(this, err2);\n                return;\n            }\n            this._unsubscribeAndRecycle();\n            this.add(subscribeToResult_1.subscribeToResult(this, result));\n        }\n    };\n    return CatchSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=catchError.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/catchError.js\n// module id = 84\n// module chunks = 2","\"use strict\";\nvar concatAll_1 = require('../operators/concatAll');\n/* tslint:enable:max-line-length */\n/**\n * Converts a higher-order Observable into a first-order Observable by\n * concatenating the inner Observables in order.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by putting one\n * inner Observable after the other.</span>\n *\n * <img src=\"./img/concatAll.png\" width=\"100%\">\n *\n * Joins every Observable emitted by the source (a higher-order Observable), in\n * a serial fashion. It subscribes to each inner Observable only after the\n * previous inner Observable has completed, and merges all of their values into\n * the returned observable.\n *\n * __Warning:__ If the source Observable emits Observables quickly and\n * endlessly, and the inner Observables it emits generally complete slower than\n * the source emits, you can run into memory issues as the incoming Observables\n * collect in an unbounded buffer.\n *\n * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set\n * to `1`.\n *\n * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map(ev => Rx.Observable.interval(1000).take(4));\n * var firstOrder = higherOrder.concatAll();\n * firstOrder.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n *\n * @see {@link combineAll}\n * @see {@link concat}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n * @see {@link exhaust}\n * @see {@link mergeAll}\n * @see {@link switch}\n * @see {@link zipAll}\n *\n * @return {Observable} An Observable emitting values from all the inner\n * Observables concatenated.\n * @method concatAll\n * @owner Observable\n */\nfunction concatAll() {\n    return concatAll_1.concatAll()(this);\n}\nexports.concatAll = concatAll;\n//# sourceMappingURL=concatAll.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operator/concatAll.js\n// module id = 85\n// module chunks = 2","\"use strict\";\nvar mergeAll_1 = require('./mergeAll');\n/**\n * Converts a higher-order Observable into a first-order Observable by\n * concatenating the inner Observables in order.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by putting one\n * inner Observable after the other.</span>\n *\n * <img src=\"./img/concatAll.png\" width=\"100%\">\n *\n * Joins every Observable emitted by the source (a higher-order Observable), in\n * a serial fashion. It subscribes to each inner Observable only after the\n * previous inner Observable has completed, and merges all of their values into\n * the returned observable.\n *\n * __Warning:__ If the source Observable emits Observables quickly and\n * endlessly, and the inner Observables it emits generally complete slower than\n * the source emits, you can run into memory issues as the incoming Observables\n * collect in an unbounded buffer.\n *\n * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set\n * to `1`.\n *\n * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map(ev => Rx.Observable.interval(1000).take(4));\n * var firstOrder = higherOrder.concatAll();\n * firstOrder.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n *\n * @see {@link combineAll}\n * @see {@link concat}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n * @see {@link exhaust}\n * @see {@link mergeAll}\n * @see {@link switch}\n * @see {@link zipAll}\n *\n * @return {Observable} An Observable emitting values from all the inner\n * Observables concatenated.\n * @method concatAll\n * @owner Observable\n */\nfunction concatAll() {\n    return mergeAll_1.mergeAll(1);\n}\nexports.concatAll = concatAll;\n//# sourceMappingURL=concatAll.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/concatAll.js\n// module id = 86\n// module chunks = 2","\"use strict\";\nvar first_1 = require('../operators/first');\n/**\n * Emits only the first value (or the first value that meets some condition)\n * emitted by the source Observable.\n *\n * <span class=\"informal\">Emits only the first value. Or emits only the first\n * value that passes some test.</span>\n *\n * <img src=\"./img/first.png\" width=\"100%\">\n *\n * If called with no arguments, `first` emits the first value of the source\n * Observable, then completes. If called with a `predicate` function, `first`\n * emits the first value of the source that matches the specified condition. It\n * may also take a `resultSelector` function to produce the output value from\n * the input value, and a `defaultValue` to emit in case the source completes\n * before it is able to emit a valid value. Throws an error if `defaultValue`\n * was not provided and a matching element is not found.\n *\n * @example <caption>Emit only the first click that happens on the DOM</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.first();\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Emits the first click that happens on a DIV</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.first(ev => ev.target.tagName === 'DIV');\n * result.subscribe(x => console.log(x));\n *\n * @see {@link filter}\n * @see {@link find}\n * @see {@link take}\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} [predicate]\n * An optional function called with each item to test for condition matching.\n * @param {function(value: T, index: number): R} [resultSelector] A function to\n * produce the value on the output Observable based on the values\n * and the indices of the source Observable. The arguments passed to this\n * function are:\n * - `value`: the value that was emitted on the source.\n * - `index`: the \"index\" of the value from the source.\n * @param {R} [defaultValue] The default value emitted in case no valid value\n * was found on the source.\n * @return {Observable<T|R>} An Observable of the first item that matches the\n * condition.\n * @method first\n * @owner Observable\n */\nfunction first(predicate, resultSelector, defaultValue) {\n    return first_1.first(predicate, resultSelector, defaultValue)(this);\n}\nexports.first = first;\n//# sourceMappingURL=first.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operator/first.js\n// module id = 87\n// module chunks = 2","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar EmptyError_1 = require('../util/EmptyError');\n/**\n * Emits only the first value (or the first value that meets some condition)\n * emitted by the source Observable.\n *\n * <span class=\"informal\">Emits only the first value. Or emits only the first\n * value that passes some test.</span>\n *\n * <img src=\"./img/first.png\" width=\"100%\">\n *\n * If called with no arguments, `first` emits the first value of the source\n * Observable, then completes. If called with a `predicate` function, `first`\n * emits the first value of the source that matches the specified condition. It\n * may also take a `resultSelector` function to produce the output value from\n * the input value, and a `defaultValue` to emit in case the source completes\n * before it is able to emit a valid value. Throws an error if `defaultValue`\n * was not provided and a matching element is not found.\n *\n * @example <caption>Emit only the first click that happens on the DOM</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.first();\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Emits the first click that happens on a DIV</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.first(ev => ev.target.tagName === 'DIV');\n * result.subscribe(x => console.log(x));\n *\n * @see {@link filter}\n * @see {@link find}\n * @see {@link take}\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} [predicate]\n * An optional function called with each item to test for condition matching.\n * @param {function(value: T, index: number): R} [resultSelector] A function to\n * produce the value on the output Observable based on the values\n * and the indices of the source Observable. The arguments passed to this\n * function are:\n * - `value`: the value that was emitted on the source.\n * - `index`: the \"index\" of the value from the source.\n * @param {R} [defaultValue] The default value emitted in case no valid value\n * was found on the source.\n * @return {Observable<T|R>} An Observable of the first item that matches the\n * condition.\n * @method first\n * @owner Observable\n */\nfunction first(predicate, resultSelector, defaultValue) {\n    return function (source) { return source.lift(new FirstOperator(predicate, resultSelector, defaultValue, source)); };\n}\nexports.first = first;\nvar FirstOperator = (function () {\n    function FirstOperator(predicate, resultSelector, defaultValue, source) {\n        this.predicate = predicate;\n        this.resultSelector = resultSelector;\n        this.defaultValue = defaultValue;\n        this.source = source;\n    }\n    FirstOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new FirstSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));\n    };\n    return FirstOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar FirstSubscriber = (function (_super) {\n    __extends(FirstSubscriber, _super);\n    function FirstSubscriber(destination, predicate, resultSelector, defaultValue, source) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.resultSelector = resultSelector;\n        this.defaultValue = defaultValue;\n        this.source = source;\n        this.index = 0;\n        this.hasCompleted = false;\n        this._emitted = false;\n    }\n    FirstSubscriber.prototype._next = function (value) {\n        var index = this.index++;\n        if (this.predicate) {\n            this._tryPredicate(value, index);\n        }\n        else {\n            this._emit(value, index);\n        }\n    };\n    FirstSubscriber.prototype._tryPredicate = function (value, index) {\n        var result;\n        try {\n            result = this.predicate(value, index, this.source);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        if (result) {\n            this._emit(value, index);\n        }\n    };\n    FirstSubscriber.prototype._emit = function (value, index) {\n        if (this.resultSelector) {\n            this._tryResultSelector(value, index);\n            return;\n        }\n        this._emitFinal(value);\n    };\n    FirstSubscriber.prototype._tryResultSelector = function (value, index) {\n        var result;\n        try {\n            result = this.resultSelector(value, index);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this._emitFinal(result);\n    };\n    FirstSubscriber.prototype._emitFinal = function (value) {\n        var destination = this.destination;\n        if (!this._emitted) {\n            this._emitted = true;\n            destination.next(value);\n            destination.complete();\n            this.hasCompleted = true;\n        }\n    };\n    FirstSubscriber.prototype._complete = function () {\n        var destination = this.destination;\n        if (!this.hasCompleted && typeof this.defaultValue !== 'undefined') {\n            destination.next(this.defaultValue);\n            destination.complete();\n        }\n        else if (!this.hasCompleted) {\n            destination.error(new EmptyError_1.EmptyError);\n        }\n    };\n    return FirstSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=first.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/first.js\n// module id = 88\n// module chunks = 2","\"use strict\";\nvar every_1 = require('../operators/every');\n/**\n * Returns an Observable that emits whether or not every item of the source satisfies the condition specified.\n *\n * @example <caption>A simple example emitting true if all elements are less than 5, false otherwise</caption>\n *  Observable.of(1, 2, 3, 4, 5, 6)\n *     .every(x => x < 5)\n *     .subscribe(x => console.log(x)); // -> false\n *\n * @param {function} predicate A function for determining if an item meets a specified condition.\n * @param {any} [thisArg] Optional object to use for `this` in the callback.\n * @return {Observable} An Observable of booleans that determines if all items of the source Observable meet the condition specified.\n * @method every\n * @owner Observable\n */\nfunction every(predicate, thisArg) {\n    return every_1.every(predicate, thisArg)(this);\n}\nexports.every = every;\n//# sourceMappingURL=every.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operator/every.js\n// module id = 89\n// module chunks = 2","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/**\n * Returns an Observable that emits whether or not every item of the source satisfies the condition specified.\n *\n * @example <caption>A simple example emitting true if all elements are less than 5, false otherwise</caption>\n *  Observable.of(1, 2, 3, 4, 5, 6)\n *     .every(x => x < 5)\n *     .subscribe(x => console.log(x)); // -> false\n *\n * @param {function} predicate A function for determining if an item meets a specified condition.\n * @param {any} [thisArg] Optional object to use for `this` in the callback.\n * @return {Observable} An Observable of booleans that determines if all items of the source Observable meet the condition specified.\n * @method every\n * @owner Observable\n */\nfunction every(predicate, thisArg) {\n    return function (source) { return source.lift(new EveryOperator(predicate, thisArg, source)); };\n}\nexports.every = every;\nvar EveryOperator = (function () {\n    function EveryOperator(predicate, thisArg, source) {\n        this.predicate = predicate;\n        this.thisArg = thisArg;\n        this.source = source;\n    }\n    EveryOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));\n    };\n    return EveryOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar EverySubscriber = (function (_super) {\n    __extends(EverySubscriber, _super);\n    function EverySubscriber(destination, predicate, thisArg, source) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.thisArg = thisArg;\n        this.source = source;\n        this.index = 0;\n        this.thisArg = thisArg || this;\n    }\n    EverySubscriber.prototype.notifyComplete = function (everyValueMatch) {\n        this.destination.next(everyValueMatch);\n        this.destination.complete();\n    };\n    EverySubscriber.prototype._next = function (value) {\n        var result = false;\n        try {\n            result = this.predicate.call(this.thisArg, value, this.index++, this.source);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        if (!result) {\n            this.notifyComplete(false);\n        }\n    };\n    EverySubscriber.prototype._complete = function () {\n        this.notifyComplete(true);\n    };\n    return EverySubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=every.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/every.js\n// module id = 90\n// module chunks = 2","\"use strict\";\nvar last_1 = require('../operators/last');\n/* tslint:enable:max-line-length */\n/**\n * Returns an Observable that emits only the last item emitted by the source Observable.\n * It optionally takes a predicate function as a parameter, in which case, rather than emitting\n * the last item from the source Observable, the resulting Observable will emit the last item\n * from the source Observable that satisfies the predicate.\n *\n * <img src=\"./img/last.png\" width=\"100%\">\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n * @param {function} predicate - The condition any source emitted item has to satisfy.\n * @return {Observable} An Observable that emits only the last item satisfying the given condition\n * from the source, or an NoSuchElementException if no such items are emitted.\n * @throws - Throws if no items that match the predicate are emitted by the source Observable.\n * @method last\n * @owner Observable\n */\nfunction last(predicate, resultSelector, defaultValue) {\n    return last_1.last(predicate, resultSelector, defaultValue)(this);\n}\nexports.last = last;\n//# sourceMappingURL=last.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operator/last.js\n// module id = 91\n// module chunks = 2","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar EmptyError_1 = require('../util/EmptyError');\n/* tslint:enable:max-line-length */\n/**\n * Returns an Observable that emits only the last item emitted by the source Observable.\n * It optionally takes a predicate function as a parameter, in which case, rather than emitting\n * the last item from the source Observable, the resulting Observable will emit the last item\n * from the source Observable that satisfies the predicate.\n *\n * <img src=\"./img/last.png\" width=\"100%\">\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n * @param {function} predicate - The condition any source emitted item has to satisfy.\n * @return {Observable} An Observable that emits only the last item satisfying the given condition\n * from the source, or an NoSuchElementException if no such items are emitted.\n * @throws - Throws if no items that match the predicate are emitted by the source Observable.\n * @method last\n * @owner Observable\n */\nfunction last(predicate, resultSelector, defaultValue) {\n    return function (source) { return source.lift(new LastOperator(predicate, resultSelector, defaultValue, source)); };\n}\nexports.last = last;\nvar LastOperator = (function () {\n    function LastOperator(predicate, resultSelector, defaultValue, source) {\n        this.predicate = predicate;\n        this.resultSelector = resultSelector;\n        this.defaultValue = defaultValue;\n        this.source = source;\n    }\n    LastOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new LastSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));\n    };\n    return LastOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar LastSubscriber = (function (_super) {\n    __extends(LastSubscriber, _super);\n    function LastSubscriber(destination, predicate, resultSelector, defaultValue, source) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.resultSelector = resultSelector;\n        this.defaultValue = defaultValue;\n        this.source = source;\n        this.hasValue = false;\n        this.index = 0;\n        if (typeof defaultValue !== 'undefined') {\n            this.lastValue = defaultValue;\n            this.hasValue = true;\n        }\n    }\n    LastSubscriber.prototype._next = function (value) {\n        var index = this.index++;\n        if (this.predicate) {\n            this._tryPredicate(value, index);\n        }\n        else {\n            if (this.resultSelector) {\n                this._tryResultSelector(value, index);\n                return;\n            }\n            this.lastValue = value;\n            this.hasValue = true;\n        }\n    };\n    LastSubscriber.prototype._tryPredicate = function (value, index) {\n        var result;\n        try {\n            result = this.predicate(value, index, this.source);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        if (result) {\n            if (this.resultSelector) {\n                this._tryResultSelector(value, index);\n                return;\n            }\n            this.lastValue = value;\n            this.hasValue = true;\n        }\n    };\n    LastSubscriber.prototype._tryResultSelector = function (value, index) {\n        var result;\n        try {\n            result = this.resultSelector(value, index);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.lastValue = result;\n        this.hasValue = true;\n    };\n    LastSubscriber.prototype._complete = function () {\n        var destination = this.destination;\n        if (this.hasValue) {\n            destination.next(this.lastValue);\n            destination.complete();\n        }\n        else {\n            destination.error(new EmptyError_1.EmptyError);\n        }\n    };\n    return LastSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=last.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/last.js\n// module id = 92\n// module chunks = 2","\"use strict\";\nvar mergeAll_1 = require('../operators/mergeAll');\n/**\n * Converts a higher-order Observable into a first-order Observable which\n * concurrently delivers all values that are emitted on the inner Observables.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables.</span>\n *\n * <img src=\"./img/mergeAll.png\" width=\"100%\">\n *\n * `mergeAll` subscribes to an Observable that emits Observables, also known as\n * a higher-order Observable. Each time it observes one of these emitted inner\n * Observables, it subscribes to that and delivers all the values from the\n * inner Observable on the output Observable. The output Observable only\n * completes once all inner Observables have completed. Any error delivered by\n * a inner Observable will be immediately emitted on the output Observable.\n *\n * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));\n * var firstOrder = higherOrder.mergeAll();\n * firstOrder.subscribe(x => console.log(x));\n *\n * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));\n * var firstOrder = higherOrder.mergeAll(2);\n * firstOrder.subscribe(x => console.log(x));\n *\n * @see {@link combineAll}\n * @see {@link concatAll}\n * @see {@link exhaust}\n * @see {@link merge}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switch}\n * @see {@link zipAll}\n *\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits values coming from all the\n * inner Observables emitted by the source Observable.\n * @method mergeAll\n * @owner Observable\n */\nfunction mergeAll(concurrent) {\n    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n    return mergeAll_1.mergeAll(concurrent)(this);\n}\nexports.mergeAll = mergeAll;\n//# sourceMappingURL=mergeAll.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operator/mergeAll.js\n// module id = 93\n// module chunks = 2","\"use strict\";\nvar reduce_1 = require('../operators/reduce');\n/* tslint:enable:max-line-length */\n/**\n * Applies an accumulator function over the source Observable, and returns the\n * accumulated result when the source completes, given an optional seed value.\n *\n * <span class=\"informal\">Combines together all values emitted on the source,\n * using an accumulator function that knows how to join a new source value into\n * the accumulation from the past.</span>\n *\n * <img src=\"./img/reduce.png\" width=\"100%\">\n *\n * Like\n * [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce),\n * `reduce` applies an `accumulator` function against an accumulation and each\n * value of the source Observable (from the past) to reduce it to a single\n * value, emitted on the output Observable. Note that `reduce` will only emit\n * one value, only when the source Observable completes. It is equivalent to\n * applying operator {@link scan} followed by operator {@link last}.\n *\n * Returns an Observable that applies a specified `accumulator` function to each\n * item emitted by the source Observable. If a `seed` value is specified, then\n * that value will be used as the initial value for the accumulator. If no seed\n * value is specified, the first item of the source is used as the seed.\n *\n * @example <caption>Count the number of click events that happened in 5 seconds</caption>\n * var clicksInFiveSeconds = Rx.Observable.fromEvent(document, 'click')\n *   .takeUntil(Rx.Observable.interval(5000));\n * var ones = clicksInFiveSeconds.mapTo(1);\n * var seed = 0;\n * var count = ones.reduce((acc, one) => acc + one, seed);\n * count.subscribe(x => console.log(x));\n *\n * @see {@link count}\n * @see {@link expand}\n * @see {@link mergeScan}\n * @see {@link scan}\n *\n * @param {function(acc: R, value: T, index: number): R} accumulator The accumulator function\n * called on each source value.\n * @param {R} [seed] The initial accumulation value.\n * @return {Observable<R>} An Observable that emits a single value that is the\n * result of accumulating the values emitted by the source Observable.\n * @method reduce\n * @owner Observable\n */\nfunction reduce(accumulator, seed) {\n    // providing a seed of `undefined` *should* be valid and trigger\n    // hasSeed! so don't use `seed !== undefined` checks!\n    // For this reason, we have to check it here at the original call site\n    // otherwise inside Operator/Subscriber we won't know if `undefined`\n    // means they didn't provide anything or if they literally provided `undefined`\n    if (arguments.length >= 2) {\n        return reduce_1.reduce(accumulator, seed)(this);\n    }\n    return reduce_1.reduce(accumulator)(this);\n}\nexports.reduce = reduce;\n//# sourceMappingURL=reduce.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operator/reduce.js\n// module id = 94\n// module chunks = 2","\"use strict\";\nvar scan_1 = require('./scan');\nvar takeLast_1 = require('./takeLast');\nvar defaultIfEmpty_1 = require('./defaultIfEmpty');\nvar pipe_1 = require('../util/pipe');\n/* tslint:enable:max-line-length */\n/**\n * Applies an accumulator function over the source Observable, and returns the\n * accumulated result when the source completes, given an optional seed value.\n *\n * <span class=\"informal\">Combines together all values emitted on the source,\n * using an accumulator function that knows how to join a new source value into\n * the accumulation from the past.</span>\n *\n * <img src=\"./img/reduce.png\" width=\"100%\">\n *\n * Like\n * [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce),\n * `reduce` applies an `accumulator` function against an accumulation and each\n * value of the source Observable (from the past) to reduce it to a single\n * value, emitted on the output Observable. Note that `reduce` will only emit\n * one value, only when the source Observable completes. It is equivalent to\n * applying operator {@link scan} followed by operator {@link last}.\n *\n * Returns an Observable that applies a specified `accumulator` function to each\n * item emitted by the source Observable. If a `seed` value is specified, then\n * that value will be used as the initial value for the accumulator. If no seed\n * value is specified, the first item of the source is used as the seed.\n *\n * @example <caption>Count the number of click events that happened in 5 seconds</caption>\n * var clicksInFiveSeconds = Rx.Observable.fromEvent(document, 'click')\n *   .takeUntil(Rx.Observable.interval(5000));\n * var ones = clicksInFiveSeconds.mapTo(1);\n * var seed = 0;\n * var count = ones.reduce((acc, one) => acc + one, seed);\n * count.subscribe(x => console.log(x));\n *\n * @see {@link count}\n * @see {@link expand}\n * @see {@link mergeScan}\n * @see {@link scan}\n *\n * @param {function(acc: R, value: T, index: number): R} accumulator The accumulator function\n * called on each source value.\n * @param {R} [seed] The initial accumulation value.\n * @return {Observable<R>} An Observable that emits a single value that is the\n * result of accumulating the values emitted by the source Observable.\n * @method reduce\n * @owner Observable\n */\nfunction reduce(accumulator, seed) {\n    // providing a seed of `undefined` *should* be valid and trigger\n    // hasSeed! so don't use `seed !== undefined` checks!\n    // For this reason, we have to check it here at the original call site\n    // otherwise inside Operator/Subscriber we won't know if `undefined`\n    // means they didn't provide anything or if they literally provided `undefined`\n    if (arguments.length >= 2) {\n        return function reduceOperatorFunctionWithSeed(source) {\n            return pipe_1.pipe(scan_1.scan(accumulator, seed), takeLast_1.takeLast(1), defaultIfEmpty_1.defaultIfEmpty(seed))(source);\n        };\n    }\n    return function reduceOperatorFunction(source) {\n        return pipe_1.pipe(scan_1.scan(function (acc, value, index) {\n            return accumulator(acc, value, index + 1);\n        }), takeLast_1.takeLast(1))(source);\n    };\n}\nexports.reduce = reduce;\n//# sourceMappingURL=reduce.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/reduce.js\n// module id = 95\n// module chunks = 2","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/* tslint:enable:max-line-length */\n/**\n * Applies an accumulator function over the source Observable, and returns each\n * intermediate result, with an optional seed value.\n *\n * <span class=\"informal\">It's like {@link reduce}, but emits the current\n * accumulation whenever the source emits a value.</span>\n *\n * <img src=\"./img/scan.png\" width=\"100%\">\n *\n * Combines together all values emitted on the source, using an accumulator\n * function that knows how to join a new source value into the accumulation from\n * the past. Is similar to {@link reduce}, but emits the intermediate\n * accumulations.\n *\n * Returns an Observable that applies a specified `accumulator` function to each\n * item emitted by the source Observable. If a `seed` value is specified, then\n * that value will be used as the initial value for the accumulator. If no seed\n * value is specified, the first item of the source is used as the seed.\n *\n * @example <caption>Count the number of click events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var ones = clicks.mapTo(1);\n * var seed = 0;\n * var count = ones.scan((acc, one) => acc + one, seed);\n * count.subscribe(x => console.log(x));\n *\n * @see {@link expand}\n * @see {@link mergeScan}\n * @see {@link reduce}\n *\n * @param {function(acc: R, value: T, index: number): R} accumulator\n * The accumulator function called on each source value.\n * @param {T|R} [seed] The initial accumulation value.\n * @return {Observable<R>} An observable of the accumulated values.\n * @method scan\n * @owner Observable\n */\nfunction scan(accumulator, seed) {\n    var hasSeed = false;\n    // providing a seed of `undefined` *should* be valid and trigger\n    // hasSeed! so don't use `seed !== undefined` checks!\n    // For this reason, we have to check it here at the original call site\n    // otherwise inside Operator/Subscriber we won't know if `undefined`\n    // means they didn't provide anything or if they literally provided `undefined`\n    if (arguments.length >= 2) {\n        hasSeed = true;\n    }\n    return function scanOperatorFunction(source) {\n        return source.lift(new ScanOperator(accumulator, seed, hasSeed));\n    };\n}\nexports.scan = scan;\nvar ScanOperator = (function () {\n    function ScanOperator(accumulator, seed, hasSeed) {\n        if (hasSeed === void 0) { hasSeed = false; }\n        this.accumulator = accumulator;\n        this.seed = seed;\n        this.hasSeed = hasSeed;\n    }\n    ScanOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));\n    };\n    return ScanOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ScanSubscriber = (function (_super) {\n    __extends(ScanSubscriber, _super);\n    function ScanSubscriber(destination, accumulator, _seed, hasSeed) {\n        _super.call(this, destination);\n        this.accumulator = accumulator;\n        this._seed = _seed;\n        this.hasSeed = hasSeed;\n        this.index = 0;\n    }\n    Object.defineProperty(ScanSubscriber.prototype, \"seed\", {\n        get: function () {\n            return this._seed;\n        },\n        set: function (value) {\n            this.hasSeed = true;\n            this._seed = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ScanSubscriber.prototype._next = function (value) {\n        if (!this.hasSeed) {\n            this.seed = value;\n            this.destination.next(value);\n        }\n        else {\n            return this._tryNext(value);\n        }\n    };\n    ScanSubscriber.prototype._tryNext = function (value) {\n        var index = this.index++;\n        var result;\n        try {\n            result = this.accumulator(this.seed, value, index);\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n        this.seed = result;\n        this.destination.next(result);\n    };\n    return ScanSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=scan.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/scan.js\n// module id = 96\n// module chunks = 2","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar ArgumentOutOfRangeError_1 = require('../util/ArgumentOutOfRangeError');\nvar EmptyObservable_1 = require('../observable/EmptyObservable');\n/**\n * Emits only the last `count` values emitted by the source Observable.\n *\n * <span class=\"informal\">Remembers the latest `count` values, then emits those\n * only when the source completes.</span>\n *\n * <img src=\"./img/takeLast.png\" width=\"100%\">\n *\n * `takeLast` returns an Observable that emits at most the last `count` values\n * emitted by the source Observable. If the source emits fewer than `count`\n * values then all of its values are emitted. This operator must wait until the\n * `complete` notification emission from the source in order to emit the `next`\n * values on the output Observable, because otherwise it is impossible to know\n * whether or not more values will be emitted on the source. For this reason,\n * all values are emitted synchronously, followed by the complete notification.\n *\n * @example <caption>Take the last 3 values of an Observable with many values</caption>\n * var many = Rx.Observable.range(1, 100);\n * var lastThree = many.takeLast(3);\n * lastThree.subscribe(x => console.log(x));\n *\n * @see {@link take}\n * @see {@link takeUntil}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @throws {ArgumentOutOfRangeError} When using `takeLast(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.\n *\n * @param {number} count The maximum number of values to emit from the end of\n * the sequence of values emitted by the source Observable.\n * @return {Observable<T>} An Observable that emits at most the last count\n * values emitted by the source Observable.\n * @method takeLast\n * @owner Observable\n */\nfunction takeLast(count) {\n    return function takeLastOperatorFunction(source) {\n        if (count === 0) {\n            return new EmptyObservable_1.EmptyObservable();\n        }\n        else {\n            return source.lift(new TakeLastOperator(count));\n        }\n    };\n}\nexports.takeLast = takeLast;\nvar TakeLastOperator = (function () {\n    function TakeLastOperator(total) {\n        this.total = total;\n        if (this.total < 0) {\n            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;\n        }\n    }\n    TakeLastOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new TakeLastSubscriber(subscriber, this.total));\n    };\n    return TakeLastOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar TakeLastSubscriber = (function (_super) {\n    __extends(TakeLastSubscriber, _super);\n    function TakeLastSubscriber(destination, total) {\n        _super.call(this, destination);\n        this.total = total;\n        this.ring = new Array();\n        this.count = 0;\n    }\n    TakeLastSubscriber.prototype._next = function (value) {\n        var ring = this.ring;\n        var total = this.total;\n        var count = this.count++;\n        if (ring.length < total) {\n            ring.push(value);\n        }\n        else {\n            var index = count % total;\n            ring[index] = value;\n        }\n    };\n    TakeLastSubscriber.prototype._complete = function () {\n        var destination = this.destination;\n        var count = this.count;\n        if (count > 0) {\n            var total = this.count >= this.total ? this.total : this.count;\n            var ring = this.ring;\n            for (var i = 0; i < total; i++) {\n                var idx = (count++) % total;\n                destination.next(ring[idx]);\n            }\n        }\n        destination.complete();\n    };\n    return TakeLastSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=takeLast.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/takeLast.js\n// module id = 97\n// module chunks = 2","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * An error thrown when an element was queried at a certain index of an\n * Observable, but no such index or position exists in that sequence.\n *\n * @see {@link elementAt}\n * @see {@link take}\n * @see {@link takeLast}\n *\n * @class ArgumentOutOfRangeError\n */\nvar ArgumentOutOfRangeError = (function (_super) {\n    __extends(ArgumentOutOfRangeError, _super);\n    function ArgumentOutOfRangeError() {\n        var err = _super.call(this, 'argument out of range');\n        this.name = err.name = 'ArgumentOutOfRangeError';\n        this.stack = err.stack;\n        this.message = err.message;\n    }\n    return ArgumentOutOfRangeError;\n}(Error));\nexports.ArgumentOutOfRangeError = ArgumentOutOfRangeError;\n//# sourceMappingURL=ArgumentOutOfRangeError.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/util/ArgumentOutOfRangeError.js\n// module id = 98\n// module chunks = 2","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/* tslint:enable:max-line-length */\n/**\n * Emits a given value if the source Observable completes without emitting any\n * `next` value, otherwise mirrors the source Observable.\n *\n * <span class=\"informal\">If the source Observable turns out to be empty, then\n * this operator will emit a default value.</span>\n *\n * <img src=\"./img/defaultIfEmpty.png\" width=\"100%\">\n *\n * `defaultIfEmpty` emits the values emitted by the source Observable or a\n * specified default value if the source Observable is empty (completes without\n * having emitted any `next` value).\n *\n * @example <caption>If no clicks happen in 5 seconds, then emit \"no clicks\"</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var clicksBeforeFive = clicks.takeUntil(Rx.Observable.interval(5000));\n * var result = clicksBeforeFive.defaultIfEmpty('no clicks');\n * result.subscribe(x => console.log(x));\n *\n * @see {@link empty}\n * @see {@link last}\n *\n * @param {any} [defaultValue=null] The default value used if the source\n * Observable is empty.\n * @return {Observable} An Observable that emits either the specified\n * `defaultValue` if the source Observable emits no items, or the values emitted\n * by the source Observable.\n * @method defaultIfEmpty\n * @owner Observable\n */\nfunction defaultIfEmpty(defaultValue) {\n    if (defaultValue === void 0) { defaultValue = null; }\n    return function (source) { return source.lift(new DefaultIfEmptyOperator(defaultValue)); };\n}\nexports.defaultIfEmpty = defaultIfEmpty;\nvar DefaultIfEmptyOperator = (function () {\n    function DefaultIfEmptyOperator(defaultValue) {\n        this.defaultValue = defaultValue;\n    }\n    DefaultIfEmptyOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));\n    };\n    return DefaultIfEmptyOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DefaultIfEmptySubscriber = (function (_super) {\n    __extends(DefaultIfEmptySubscriber, _super);\n    function DefaultIfEmptySubscriber(destination, defaultValue) {\n        _super.call(this, destination);\n        this.defaultValue = defaultValue;\n        this.isEmpty = true;\n    }\n    DefaultIfEmptySubscriber.prototype._next = function (value) {\n        this.isEmpty = false;\n        this.destination.next(value);\n    };\n    DefaultIfEmptySubscriber.prototype._complete = function () {\n        if (this.isEmpty) {\n            this.destination.next(this.defaultValue);\n        }\n        this.destination.complete();\n    };\n    return DefaultIfEmptySubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=defaultIfEmpty.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/defaultIfEmpty.js\n// module id = 99\n// module chunks = 2","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/* tslint:enable:max-line-length */\n/**\n * Filter items emitted by the source Observable by only emitting those that\n * satisfy a specified predicate.\n *\n * <span class=\"informal\">Like\n * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n * it only emits a value from the source if it passes a criterion function.</span>\n *\n * <img src=\"./img/filter.png\" width=\"100%\">\n *\n * Similar to the well-known `Array.prototype.filter` method, this operator\n * takes values from the source Observable, passes them through a `predicate`\n * function and only emits those values that yielded `true`.\n *\n * @example <caption>Emit only click events whose target was a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');\n * clicksOnDivs.subscribe(x => console.log(x));\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n * @see {@link ignoreElements}\n * @see {@link partition}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted, if `false` the value is not passed to the output\n * Observable. The `index` parameter is the number `i` for the i-th source\n * emission that has happened since the subscription, starting from the number\n * `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable} An Observable of values from the source that were\n * allowed by the `predicate` function.\n * @method filter\n * @owner Observable\n */\nfunction filter(predicate, thisArg) {\n    return function filterOperatorFunction(source) {\n        return source.lift(new FilterOperator(predicate, thisArg));\n    };\n}\nexports.filter = filter;\nvar FilterOperator = (function () {\n    function FilterOperator(predicate, thisArg) {\n        this.predicate = predicate;\n        this.thisArg = thisArg;\n    }\n    FilterOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));\n    };\n    return FilterOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar FilterSubscriber = (function (_super) {\n    __extends(FilterSubscriber, _super);\n    function FilterSubscriber(destination, predicate, thisArg) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.thisArg = thisArg;\n        this.count = 0;\n    }\n    // the try catch block below is left specifically for\n    // optimization and perf reasons. a tryCatcher is not necessary here.\n    FilterSubscriber.prototype._next = function (value) {\n        var result;\n        try {\n            result = this.predicate.call(this.thisArg, value, this.count++);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        if (result) {\n            this.destination.next(value);\n        }\n    };\n    return FilterSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=filter.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/filter.js\n// module id = 100\n// module chunks = 2","module.exports = \"<h1>Home</h1>\\r\\n<p>\\r\\n    Welcome to the home page...\\r\\n</p>\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./components/root-module/home/home.component.html\n// module id = 101\n// module chunks = 2","module.exports = \"\\r\\n<h1>Page not found</h1>\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./components/root-module/page-not-found/page-not-found.component.html\n// module id = 102\n// module chunks = 2","import { Component } from '@angular/core';\r\n\r\n@Component({\r\n    selector: 'internal-root',\r\n    template: require('./root.component.html')\r\n})\r\nexport class RootComponent {         \r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/angular2-template-loader!./node_modules/angular-router-loader/src!./components/root-module/root.component.ts","module.exports = \"<div class=\\\"container-fluid\\\">\\r\\n    <div class=\\\"row\\\">\\r\\n        <div class=\\\"col-md-2\\\">\\r\\n            <ul class='list-unstyled'>\\r\\n                <li>\\r\\n                    <a routerLink=\\\"/home\\\" routerLinkActive=\\\"active-link\\\">Home</a>\\r\\n                </li>\\r\\n                <li>\\r\\n                    <a routerLink=\\\"/employees\\\" routerLinkActive=\\\"active-link\\\">Employees</a>\\r\\n                </li>\\r\\n            </ul>\\r\\n        </div>\\r\\n        <div class=\\\"col-md-10\\\">\\r\\n            <router-outlet></router-outlet>\\r\\n        </div>\\r\\n    </div>\\r\\n</div>\\r\\n\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./components/root-module/root.component.html\n// module id = 105\n// module chunks = 2"],"sourceRoot":""}